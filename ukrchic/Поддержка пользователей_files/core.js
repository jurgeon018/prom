/* Cafe 0.1.16 Thu Oct 08 2015 14:48:34 GMT+0300 (EEST) */

// Generated by CoffeeScript 1.9.2
(function() {
  "Simple common js bootstrapper.\nInspired by stitch.";
  var cache, diranme, expand, modules, partial, require;

  if (!this.require) {
    modules = {};
    cache = {};
    if (!window.bootstrapper) {
      window.bootstrapper = {};
    }
    window.bootstrapper.modules = modules;
    window.bootstrapper.cache = cache;
    partial = function(fn) {
      var partial_args;
      partial_args = Array.prototype.slice.call(arguments);
      partial_args.shift();
      return function() {
        var a, arg, i, j, len, new_args, ref;
        ref = [[], 0], new_args = ref[0], arg = ref[1];
        for (i = j = 0, len = partial_args.length; j < len; i = ++j) {
          a = partial_args[i];
          if (partial_args[i] === void 0) {
            new_args.push(arguments[arg++]);
          } else {
            new_args.push(partial_args[i]);
          }
        }
        return fn.apply(this, new_args);
      };
    };
    require = function(name, root, ns) {
      var e, fn, module, ns_module, ns_path, path, top_level_module;
      if (name === 'bootstrapper') {
        return window.bootstrapper;
      }
      path = expand(root, name);
      ns_path = ns + "/" + (expand('', name));
      top_level_module = modules[path] || modules[expand(path, './index')];
      if (ns && !top_level_module) {
        path = ns_path;
      }
      ns_module = modules[ns_path] || modules[expand(ns_path, './index')];
      if (ns && top_level_module && ns_module) {
        path = ns + "/" + (expand('', name));
      }
      module = cache[path] || cache[expand(path, './index')];
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {
          id: path,
          exports: {}
        };
        try {
          cache[path] = module;
          fn(module.exports, module);
          return module.exports;
        } catch (_error) {
          e = _error;
          delete cache[path];
          throw e;
        }
      } else {
        throw "module '" + name + "' is not found";
      }
    };
    expand = function(root, name) {
      var i, j, part, parts, ref, results;
      results = [];
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (i = j = 0, ref = parts.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        part = parts[i];
        if (part === '..') {
          results.pop();
        } else if (part !== '.' && part !== '') {
          results.push(part);
        }
      }
      return results.join('/');
    };
    diranme = function(path) {
      return path.split('/').slice(0).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    };
    this.require.define = function(ns, bundle) {
      var _key, _require, key, value;
      _require = partial(require, void 0, void 0, ns);
      for (key in bundle) {
        value = bundle[key];
        _key = ns ? ns + "/" + key : key;
        modules[_key] = partial(value, void 0, _require, void 0);
        void 0;
      }
      return void 0;
    };
  }

}).call(this);



/*ZB: lodash */
require.define('lodash', {

/*ZB:  lodash/index */
'index': function(exports, require, module) {(function() {
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this);}
});


/*ZB: libconfig */
require.define('libconfig', {

/*ZB:  libconfig/index */
'index': function(exports, require, module) {(function() {
// Generated by CoffeeScript 1.9.2
(function() {
  var _AppState, get, get_config, get_data, on_config_changed, pub, pubsubhub, ref, set, set_config, set_data, sub,
    slice = [].slice;

  _AppState = window.AppState;

  pubsubhub = require('libprotein').pubsubhub;

  ref = pubsubhub(), pub = ref.pub, sub = ref.sub;

  get_data = function(store, arg) {
    var k, tail;
    k = arg[0], tail = 2 <= arg.length ? slice.call(arg, 1) : [];
    if (!store) {
      return void 0;
    }
    if (tail.length) {
      return get_data(store[k], tail);
    } else {
      return store[k];
    }
  };

  set_data = function(store, arg, data) {
    var k, tail;
    k = arg[0], tail = 2 <= arg.length ? slice.call(arg, 1) : [];
    if (!k) {
      return void 0;
    }
    if (tail.length) {
      store[k] || (store[k] = {});
      store[k] = set_data(store[k], tail, data);
      return store;
    } else {
      store[k] = data;
      return store;
    }
  };

  get_config = function(key, arg) {
    var config;
    config = (arg != null ? arg : _AppState).config;
    return get_data(config, key.split('.'));
  };

  set_config = function(key, value, arg) {
    var config;
    config = (arg != null ? arg : _AppState).config;
    set_data(config, key.split('.'), value);
    return pub(key, get_config(key));
  };

  get = get_config;

  set = set_config;

  on_config_changed = function(key, handler, arg) {
    var config;
    config = (arg != null ? arg : _AppState).config;
    return sub(key, handler);
  };

  module.exports = {
    get_config: get_config,
    set_config: set_config,
    on_config_changed: on_config_changed,
    get: get,
    set: set
  };

}).call(this);

}).call(this);}
});


/*ZB:  */
require.define('', {

/*ZB:  /console-logger */
'console-logger': function(exports, require, module) {(function() {
(function() {
  if (Function.prototype.bind && console && typeof console.log == "object") {
    [
      "log","info","warn","error","assert","dir","clear","profile","profileEnd"
    ].forEach(function (method) {
        console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
}
if (Function.prototype.bind && console && typeof console.debug == "object") {
    [
      "debug"
    ].forEach(function (method) {
        console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
}
;
  var DEBUG, ERROR, INFO, LOG_ENABLED, LOG_LEVELS, NOTICE, UNK_NS, WARN, console, e, get_namespaced_logger, log, nullog, partial, root, say,
    slice = [].slice;

  partial = require('libprotein').partial;

  root = window;

  INFO = 'INFO';

  WARN = 'WARN';

  ERROR = 'ERROR';

  DEBUG = 'DEBUG';

  NOTICE = 'NOTICE';

  LOG_LEVELS = [INFO, WARN, ERROR, DEBUG, NOTICE];

  UNK_NS = 'UNK_NS';

  LOG_ENABLED = (function() {
    try {
      return window.is_debug;
    } catch (_error) {
      e = _error;
      return false;
    }
  })();

  if (!root.console) {
    root.console = {
      log: function() {},
      info: function() {},
      warn: function() {},
      error: function() {},
      assert: function() {},
      dir: function() {},
      clear: function() {},
      profile: function() {},
      profileEnd: function() {}
    };
  }

  console = root.console;

  say = function() {
    var log_level, log_ns, m, msgs;
    log_level = arguments[0], log_ns = arguments[1], msgs = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    m = [(log_level ? "[" + log_level + "]" : '[NOTICE]'), (log_ns ? "[" + log_ns + "]" : "[" + UNK_NS + "]")].concat(msgs);
    switch (log_level) {
      case ERROR:
        return console != null ? typeof console.error === "function" ? console.error.apply(console, m) : void 0 : void 0;
      case INFO:
        return console != null ? console.info.apply(console, m) : void 0;
      case DEBUG:
        if ((console != null ? console.debug : void 0) != null) {
          return console != null ? console.debug(m.join(' ')) : void 0;
        } else {
          return console != null ? console.log.apply(console, m) : void 0;
        }
        break;
      case WARN:
        return console != null ? console.warn.apply(console, m) : void 0;
      default:
        return console != null ? console.log.apply(console, m) : void 0;
    }
  };

  nullog = function() {};

  log = LOG_ENABLED ? say : nullog;

  get_namespaced_logger = function(log_ns) {
    return {
      info: partial(log, INFO, log_ns),
      warn: partial(log, WARN, log_ns),
      error: partial(log, ERROR, log_ns),
      debug: partial(log, DEBUG, log_ns),
      notice: partial(log, NOTICE, log_ns),
      nullog: nullog
    };
  };

  module.exports = {
    info: partial(log, INFO, UNK_NS),
    warn: partial(log, WARN, UNK_NS),
    error: partial(log, ERROR, UNK_NS),
    debug: partial(log, DEBUG, UNK_NS),
    notice: partial(log, NOTICE, UNK_NS),
    nullog: nullog,
    ns: get_namespaced_logger,
    protocols: {
      definitions: {
        ILogger: [
          [
            'info', [], {
              varargs: true
            }
          ], [
            'warn', [], {
              varargs: true
            }
          ], [
            'error', [], {
              varargs: true
            }
          ], [
            'debug', [], {
              varargs: true
            }
          ], [
            'notice', [], {
              varargs: true
            }
          ], [
            'nullog', [], {
              varargs: true
            }
          ]
        ]
      },
      implementations: {
        ILogger: get_namespaced_logger
      }
    }
  };

}).call(this);

}).call(this);}
});


/*ZB:  */
require.define('', {

/*ZB:  /service-locator */
'service-locator': function(exports, require, module) {(function() {
(function() {
  var default_dispatcher,
    slice = [].slice;

  default_dispatcher = function() {
    var AppState, args, i, instances, name;
    name = arguments[0], instances = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), AppState = arguments[i++];
    error("No dispatcher set for non-singleton service " + name + ", returning 1st one");
    return instances[0];
  };

  module.exports = {
    provide: function(arg, AppState) {
      var base, dispatcher, instance, name, singleton;
      name = arg.name, instance = arg.instance, singleton = arg.singleton, dispatcher = arg.dispatcher;
      if (!AppState.services) {
        AppState.services = {};
      }
      if (singleton) {
        if (AppState.services['name']) {
          return warn("There is already an instance of singleton service " + name);
        } else {
          return AppState.services[name] = {
            singleton: true,
            instance: instance
          };
        }
      } else {
        (base = AppState.services)[name] || (base[name] = {
          singleton: false,
          instances: [],
          dispatcher: dispatcher || default_dispatcher
        });
        return AppState.services[name].instances.push(instance);
      }
    },
    locate: function() {
      var AppState, dispatcher_args, i, name, ref;
      name = arguments[0], dispatcher_args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), AppState = arguments[i++];
      if (!AppState.services) {
        AppState.services = {};
      }
      if (AppState.services[name]) {
        if (AppState.services[name].singleton) {
          return AppState.services[name].instance;
        } else {
          return (ref = AppState.services[name]).dispatcher.apply(ref, [name, AppState.services[instances]].concat(slice.call(dispatcher_args), [AppState]));
        }
      } else {
        return void 0;
      }
    },
    dump: function(AppState) {
      if (!AppState.services) {
        AppState.services = {};
      }
      return AppState.services;
    }
  };

}).call(this);

}).call(this);}
});


/*ZB: event-channel */
require.define('event-channel', {

/*ZB:  event-channel/index */
'index': function(exports, require, module) {(function() {
module.exports = require('lib-js/ev_channel')
}).call(this);},

/*ZB:  event-channel/lib-js/ev_channel */
'lib-js/ev_channel': function(exports, require, module) {(function() {
// Generated by CoffeeScript 1.9.2
(function() {
  var Emitter, emitter,
    slice = [].slice;

  Emitter = function() {
    var callbacks, callbacks_map, pub, sub, unsub;
    callbacks = {};
    sub = function(ev, callback) {
      var calls, evs, j, len, name, results;
      evs = ev.split(' ');
      calls = callbacks;
      results = [];
      for (j = 0, len = evs.length; j < len; j++) {
        name = evs[j];
        callbacks[name] || (callbacks[name] = []);
        results.push(callbacks[name].push(callback));
      }
      return results;
    };
    pub = function() {
      var args, callback, ev, j, len, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ev = args.shift();
      if (!callbacks[ev]) {
        return;
      }
      ref = callbacks[ev];
      for (j = 0, len = ref.length; j < len; j++) {
        callback = ref[j];
        if (callback.apply(null, args) === false) {
          break;
        }
      }
      return true;
    };
    unsub = function(ev, callback) {
      var cb, evs, i, j, len, list, name, results;
      evs = ev.split(' ');
      results = [];
      for (j = 0, len = evs.length; j < len; j++) {
        name = evs[j];
        list = callbacks[name];
        if (!list) {
          continue;
        }
        if (!callback) {
          delete callbacks[name];
          continue;
        }
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (i = k = 0, len1 = list.length; k < len1; i = ++k) {
            cb = list[i];
            if (!(cb === callback)) {
              continue;
            }
            list = list.slice();
            list.splice(i, 1);
            callbacks[name] = list;
            break;
          }
          return results1;
        })());
      }
      return results;
    };
    callbacks_map = function() {
      return callbacks;
    };
    return {
      sub: sub,
      pub: pub,
      unsub: unsub,
      callbacks_map: callbacks_map
    };
  };

  emitter = new Emitter();

  module.exports = {
    emitter: emitter,
    Emitter: Emitter
  };

}).call(this);

}).call(this);}
});


/*ZB: libprotocol */
require.define('libprotocol', {

/*ZB:  libprotocol/index */
'index': function(exports, require, module) {(function() {
// Generated by CoffeeScript 1.9.2
(function() {
  var CONS, PROTO, PROTOCOL_CACHE, THIS, debug, discover_protocols, dispatch_impl, dump_impls, error, get_arity, get_meta, get_meta_key, get_method, get_protocol, info, is_array, is_async, is_vararg, partial, ref, ref1, register_exports, register_protocol, register_protocol_impl, uncache_protocol, unique, warn,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  ref = (require('console-logger')).ns('libprotocol'), info = ref.info, warn = ref.warn, error = ref.error, debug = ref.debug;

  PROTO = {
    Implementations: {},
    Protocols: {}
  };

  THIS = 'this';

  CONS = '*cons*';

  PROTOCOL_CACHE = window._libprotocol_cache;

  ref1 = require('libprotein'), partial = ref1.partial, is_array = ref1.is_array;

  get_protocol = function(p) {
    uncache_protocol(p);
    if (PROTO.Protocols.hasOwnProperty(p)) {
      return PROTO.Protocols[p];
    } else {
      throw "No such registered protocol: '" + p + "'";
    }
  };

  register_protocol = function(name, p) {
    if (!PROTO.Protocols.hasOwnProperty(p)) {
      return PROTO.Protocols[name] = p;
    } else {
      throw "Protocol already registered: '" + name + "'";
    }
  };

  get_method = function(ns, method_name) {
    var m, ref2;
    m = (ref2 = PROTO.Protocols[ns]) != null ? ref2.filter(function(arg) {
      var mn;
      mn = arg[0];
      return mn === method_name;
    }) : void 0;
    if (m.length === 1) {
      return m[0];
    } else {
      error("No such method:", ns, method_name);
      throw "No such method";
    }
  };

  get_meta = function(ns, method_name) {
    var _, meta, ref2;
    ref2 = get_method(ns, method_name), _ = ref2[0], _ = ref2[1], meta = ref2[2];
    return meta || {};
  };

  get_meta_key = function(prop, ns, method_name) {
    return (get_meta(ns, method_name))[prop];
  };

  is_async = partial(get_meta_key, 'async');

  is_vararg = partial(get_meta_key, 'vararg');

  get_arity = function(ns, method_name) {
    var _, argums, ref2;
    ref2 = get_method(ns, method_name), _ = ref2[0], argums = ref2[1], _ = 3 <= ref2.length ? slice.call(ref2, 2) : [];
    return argums.length;
  };

  register_protocol_impl = function(protocol, impl) {
    return PROTO.Implementations[protocol] = impl;
  };

  register_exports = function(exports) {
    var definition, impl, protocol, ref2, ref3, ref4, ref5, results;
    if ((ref2 = exports.protocols) != null ? ref2.definitions : void 0) {
      ref3 = exports.protocols.definitions;
      for (protocol in ref3) {
        definition = ref3[protocol];
        register_protocol(protocol, definition);
      }
    }
    if ((ref4 = exports.protocols) != null ? ref4.implementations : void 0) {
      ref5 = exports.protocols.implementations;
      results = [];
      for (protocol in ref5) {
        impl = ref5[protocol];
        results.push(register_protocol_impl(protocol, impl));
      }
      return results;
    }
  };

  discover_protocols = function() {
    var e, modname, modules, results;
    if (PROTOCOL_CACHE) {
      return info("Protocol cache available, skipping discovery");
    } else {
      modules = (function() {
        try {
          return require.modules();
        } catch (_error) {
          e = _error;
          return window.bootstrapper.modules;
        }
      })();
      results = [];
      for (modname in modules) {
        results.push(register_exports(require(modname)));
      }
      return results;
    }
  };

  unique = function(arr) {
    var a, i, j, k, len, results;
    a = {};
    for (j = 0, len = arr.length; j < len; j++) {
      i = arr[j];
      a[i] = true;
    }
    results = [];
    for (k in a) {
      if (!hasProp.call(a, k)) continue;
      results.push(k);
    }
    return results;
  };

  uncache_protocol = function(protocol) {
    var cache, j, len, mods;
    if (PROTOCOL_CACHE) {
      if (!(PROTO.Protocols[protocol] && PROTO.Implementations[protocol])) {
        mods = [];
        for (j = 0, len = PROTOCOL_CACHE.length; j < len; j++) {
          cache = PROTOCOL_CACHE[j];
          if (cache[protocol] !== void 0) {
            mods = mods.concat(cache[protocol]);
          }
        }
        mods = unique(mods);
        return mods.map(function(modname) {
          return register_exports(require(modname));
        });
      }
    }
  };

  dispatch_impl = function(protocol, opts) {
    var concerns, cons, f, fun, j, k, len, meta, name, q, ref2, ref3, ref4, v, xopts;
    if (opts == null) {
      opts = void 0;
    }
    if (!(PROTO.Protocols[protocol] && PROTO.Implementations[protocol])) {
      uncache_protocol(protocol);
      discover_protocols();
    }
    if (PROTO.Protocols[protocol] && PROTO.Implementations[protocol]) {
      cons = PROTO.Protocols[protocol].filter(function(m) {
        return m[0] === CONS;
      })[0];
      if (cons) {
        meta = get_meta(protocol, CONS);
        if ((ref2 = meta.concerns) != null ? ref2.before : void 0) {
          concerns = is_array(meta.concerns.before) ? meta.concerns.before : [meta.concerns.before];
          xopts = [opts];
          for (j = 0, len = concerns.length; j < len; j++) {
            f = concerns[j];
            xopts.push(f.apply(null, xopts));
          }
          opts = xopts;
        }
      }
      q = (ref3 = PROTO.Implementations)[protocol].apply(ref3, (is_array(opts) ? opts : [opts]));
      for (name in q) {
        if (!hasProp.call(q, name)) continue;
        fun = q[name];
        fun.meta || (fun.meta = {});
        fun.meta.name = name;
        fun.meta.protocol = protocol;
        fun.meta.arity = get_arity(protocol, name);
        ref4 = get_meta(protocol, name);
        for (k in ref4) {
          v = ref4[k];
          fun.meta[k] = v;
        }
      }
      return q;
    } else {
      debug("Cant find implementations for protocol " + protocol);
      return null;
    }
  };

  dump_impls = function() {
    return debug("Currently registered PROTO.Implementations:", PROTO.Implementations);
  };

  module.exports = {
    register_protocol_impl: register_protocol_impl,
    register_protocol: register_protocol,
    get_protocol: get_protocol,
    dispatch_impl: dispatch_impl,
    dump_impls: dump_impls,
    is_async: is_async,
    is_vararg: is_vararg,
    get_arity: get_arity,
    discover_protocols: discover_protocols
  };

}).call(this);

}).call(this);}
});


/*ZB:  */
require.define('', {

/*ZB:  /config */
'config': function(exports, require, module) {(function() {
(function() {
  var _AppState, get, get_config, get_data, on_config_changed, pub, pubsubhub, ref, set, set_config, set_data, sub,
    slice = [].slice;

  _AppState = window.AppState;

  pubsubhub = require('libprotein').pubsubhub;

  ref = pubsubhub(), pub = ref.pub, sub = ref.sub;

  get_data = function(store, arg) {
    var k, tail;
    k = arg[0], tail = 2 <= arg.length ? slice.call(arg, 1) : [];
    if (!store) {
      return void 0;
    }
    if (tail.length) {
      return get_data(store[k], tail);
    } else {
      return store[k];
    }
  };

  set_data = function(store, arg, data) {
    var k, tail;
    k = arg[0], tail = 2 <= arg.length ? slice.call(arg, 1) : [];
    if (!k) {
      return void 0;
    }
    if (tail.length) {
      store[k] || (store[k] = {});
      store[k] = set_data(store[k], tail, data);
      return store;
    } else {
      store[k] = data;
      return store;
    }
  };

  get_config = function(key, arg) {
    var config;
    config = (arg != null ? arg : _AppState).config;
    return get_data(config, key.split('.'));
  };

  set_config = function(key, value, arg) {
    var config;
    config = (arg != null ? arg : _AppState).config;
    set_data(config, key.split('.'), value);
    return pub(key, get_config(key));
  };

  get = get_config;

  set = set_config;

  on_config_changed = function(key, handler, arg) {
    var config;
    config = (arg != null ? arg : _AppState).config;
    return sub(key, handler);
  };

  module.exports = {
    get_config: get_config,
    set_config: set_config,
    on_config_changed: on_config_changed,
    get: get,
    set: set
  };

}).call(this);

}).call(this);}
});


/*ZB: libprotein */
require.define('libprotein', {

/*ZB:  libprotein/index */
'index': function(exports, require, module) {(function() {
// Generated by CoffeeScript 1.9.2
(function() {
  var X,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  X = {
    partial: function() {
      var f, partial_args, y;
      f = arguments[0], partial_args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      y = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return f.apply(null, partial_args.concat(args));
      };
      return X.metabolize(f, y);
    },
    complement: function(f) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return !(f.apply(null, args));
      };
    },
    compose2: function(f, g) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return f(g.apply(null, args));
      };
    },
    compose3: function(f, g, h) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return f(g(h.apply(null, args)));
      };
    },
    first: function(s) {
      return s[0];
    },
    identity: function(x) {
      return x;
    },
    drop_while: function(f, s) {
      var i, j, len;
      for (j = 0, len = s.length; j < len; j++) {
        i = s[j];
        if (!(f(i))) {
          return i;
        }
      }
    },
    is_function: function(v) {
      return typeof v === 'function';
    },
    is_array: function(v) {
      return Array.isArray(v);
    },
    is_object: function(v) {
      if (X.is_array(v)) {
        return false;
      } else {
        return v instanceof {}.constructor;
      }
    },
    is_nan: function(v) {
      return v !== v;
    },
    is_string: function(v) {
      return typeof v === 'string';
    },
    bool: function(v) {
      if (X.is_array(v)) {
        return !!v.length;
      } else if (X.is_object(v)) {
        return !!(Object.keys(v).length);
      } else {
        return !!v;
      }
    },
    and_: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return args.reduce(function(a, b) {
        return (X.bool(a)) && (X.bool(b));
      }, true);
    },
    or_: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return args.reduce(function(a, b) {
        return (X.bool(a)) || (X.bool(b));
      }, false);
    },
    to_hash: function(list_of_tuples) {
      var h;
      h = {};
      list_of_tuples.map(function(arg) {
        var k, v;
        k = arg[0], v = arg[1];
        return h[k] = v;
      });
      return h;
    },
    metabolize: function(f, g) {
      g.meta = f.meta;
      return g;
    },
    data_to_opts: function(sufx, node) {
      var $node, keys;
      $node = jQuery(node);
      if ($node.data()) {
        keys = Object.keys($node.data());
        return X.to_hash(keys.filter(function(key) {
          return key.slice(0, sufx.length) === sufx;
        }).map(function(key) {
          return [key.slice(sufx.length), $node.data(key)];
        }));
      } else {
        return {};
      }
    },
    add2: function(a, b) {
      var k, ret, v;
      if ((X.is_array(a)) && (X.is_array(b))) {
        return a.concat(b);
      } else if ((X.is_object(a)) && (X.is_object(b))) {
        ret = {};
        for (k in a) {
          if (!hasProp.call(a, k)) continue;
          v = a[k];
          ret[k] = v;
        }
        for (k in b) {
          if (!hasProp.call(b, k)) continue;
          v = b[k];
          ret[k] = v;
        }
        return ret;
      } else {
        return a + b;
      }
    },
    add: function() {
      var values;
      values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return values.reduce(function(a, b) {
        return X.add2(a, b);
      });
    },
    pubsubhub: function() {
      return (function() {
        var q;
        q = {};
        return {
          sub: function(name, f) {
            q[name] || (q[name] = []);
            return q[name].push(f);
          },
          pub: function() {
            var data, name, ref;
            name = arguments[0], data = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return (ref = q[name]) != null ? ref.map(function(f) {
              return f.apply(null, data);
            }) : void 0;
          },
          unsub: function(name, f) {
            if (q[name]) {
              return q[name] = q[name].filter(function(s) {
                return s !== f;
              });
            }
          },
          unsuball: function(name) {
            if (q[name]) {
              return q[name] = [];
            }
          },
          unsubcond: function(name, cond) {
            if (q[name]) {
              return q[name] = q[name].filter(cond);
            }
          },
          get: function(name) {
            return q[name];
          }
        };
      })();
    },
    distinct: function(list) {
      var i, j, k, len, results, t, v;
      t = {};
      for (j = 0, len = list.length; j < len; j++) {
        i = list[j];
        t[i] = i;
      }
      results = [];
      for (k in t) {
        v = t[k];
        results.push(v);
      }
      return results;
    },
    repeat: function(v, n) {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push(v);
      }
      return results;
    },
    make_lambda: function(expression) {
      var expr;
      if (expression === "" || expression === null) {
        return X.identity;
      } else if ((expression.indexOf("=>")) === -1) {
        return new Function("_,__,___,____", "return " + expression);
      } else {
        expr = expression.match(/^[(\s]*([^()]*?)[)\s]*=>(.*)/);
        return new Function(expr[1], "return " + expr[2]);
      }
    },
    urlencode: function(d) {
      var k, v;
      return ((function() {
        var results;
        results = [];
        for (k in d) {
          v = d[k];
          results.push((encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
        }
        return results;
      })()).join('&');
    },
    add_params_to_url: function(url, params) {
      var has_params, start_char;
      has_params = (url.indexOf('?')) > -1;
      start_char = has_params ? '&' : '?';
      return url + start_char + (X.urlencode(params));
    },
    zip: function(one, two) {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = Math.min(one.length, two.length); 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push([one[i], two[i]]);
      }
      return results;
    }
  };

  module.exports = X;

}).call(this);

}).call(this);}
});


/*ZB: WormholeClient */
require.define('WormholeClient', {

/*ZB:  WormholeClient/index */
'index': function(exports, require, module) {(function() {
(function() {
  var IFRAME_ID, SERVER_SUFFIX, STATUS_SERVER_READY, TRANSACTION_NAME_PREFIX, WormholeClient, _postMessage, _receiveMessage, debug, emitter, error, get_config, has_hostname, info, ref, ref1, ref2, ref3, set_config, uuid, warn,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ref = require('lib/PostMessage'), _postMessage = ref[0], _receiveMessage = ref[1];

  ref1 = require('lib/util'), has_hostname = ref1.has_hostname, uuid = ref1.uuid;

  STATUS_SERVER_READY = require('lib/defs').STATUS_SERVER_READY;

  TRANSACTION_NAME_PREFIX = 'cswh_';

  IFRAME_ID = 'wormhole';

  SERVER_SUFFIX = '/remote/wormhole/iframe';

  ref2 = require('config'), set_config = ref2.set_config, get_config = ref2.get_config;

  ref3 = (require('console-logger')).ns('WormholeClient'), info = ref3.info, warn = ref3.warn, error = ref3.error, debug = ref3.debug;

  emitter = require('event-channel').emitter;

  WormholeClient = (function() {
    function WormholeClient(SERVER_ORIGIN1) {
      var SERVER_ORIGIN, SERVER_URL, SERVER_WINDOW, server_status, transactions;
      this.SERVER_ORIGIN = SERVER_ORIGIN1;
      this.on_server_ready = bind(this.on_server_ready, this);
      this.transactions = {};
      this.pending_queue = [];
      this.server_status = void 0;
      this.init_time = new Date();
      if (this.SERVER_ORIGIN.substr(this.SERVER_ORIGIN.length - 1) === '/') {
        this.SERVER_ORIGIN = this.SERVER_ORIGIN.substr(0, this.SERVER_ORIGIN.length - 1);
      }
      this.SERVER_URL = this.SERVER_ORIGIN + SERVER_SUFFIX;
      this.SERVER_WINDOW = this.create_iframe(this.SERVER_URL);
      SERVER_ORIGIN = this.SERVER_ORIGIN;
      SERVER_URL = this.SERVER_URL;
      SERVER_WINDOW = this.SERVER_WINDOW;
      transactions = this.transactions;
      server_status = this.server_status;
      emitter.sub(STATUS_SERVER_READY, this.on_server_ready);
      _receiveMessage(function(event) {
        var callbacks, e, payload;
        payload = (function() {
          try {
            return JSON.parse(event.data);
          } catch (_error) {
            e = _error;
            return null;
          }
        })();
        if ((payload != null ? payload._status : void 0) === STATUS_SERVER_READY) {
          info("Re-setting CS.USER configuration domain");
          info("old value:", get_config('CS.USER'));
          info('new value', payload._cfg.user);
          set_config('CS.USER', payload._cfg.user);
          info("Re-setting CS.SHOPPING_CART_COOKIE configuration domain");
          info("old value:", get_config('CS.SHOPPING_CART_COOKIE'));
          info('new value:', payload._cfg.shopping_cart_cookie);
          set_config('CS.SHOPPING_CART_COOKIE', payload._cfg.shopping_cart_cookie);
          emitter.pub(STATUS_SERVER_READY, true);
          return true;
        }
        if ((payload != null ? payload.transaction_id : void 0) && transactions[payload.transaction_id]) {
          callbacks = transactions[payload.transaction_id];
          if (payload.error) {
            if (typeof callbacks.error_callback === "function") {
              callbacks.error_callback(payload.xhr, payload.status, payload.error);
            }
          } else {
            if (typeof callbacks.success_callback === "function") {
              callbacks.success_callback(payload.data, payload.status, payload.xhr);
            }
          }
          return typeof callbacks.complete_callback === "function" ? callbacks.complete_callback(payload.data, payload.status, payload.xhr) : void 0;
        } else {
          return error("Event with unknown origin received: '" + event.origin + "'\nor No callbacks\nor Unexpected data from server:", payload);
        }
      }, SERVER_ORIGIN);
    }

    WormholeClient.prototype.on_server_ready = function() {
      var now, payload, results;
      now = new Date();
      info("Wormhole server has become ready, timeout was " + (now - this.init_time) + " ms.\nPushing " + this.pending_queue.length + " pending transactions.");
      this.server_status = STATUS_SERVER_READY;
      results = [];
      while (payload = this.pending_queue.shift()) {
        results.push(_postMessage(JSON.stringify(payload), this.SERVER_URL, this.SERVER_WINDOW));
      }
      return results;
    };

    WormholeClient.prototype.create_iframe = function(SERVER_URL) {
      var iframe;
      iframe = document.getElementById(IFRAME_ID);
      if (iframe) {
        warn("An iframe with id " + IFRAME_ID + " already exists, hoping it works");
        return iframe.contentWindow;
      } else {
        iframe = document.createElement('iframe');
        iframe.src = SERVER_URL;
        iframe.id = IFRAME_ID;
        iframe.style.display = 'none';
        iframe.style.width = '0px';
        iframe.style.height = '0px';
        document.body.appendChild(iframe);
        return iframe.contentWindow;
      }
    };

    WormholeClient.prototype.postMessage = function(payload, success_callback, error_callback) {
      var ref4, ref5, transaction_id;
      transaction_id = TRANSACTION_NAME_PREFIX + uuid();
      payload.transaction_id = transaction_id;
      this.transactions[transaction_id] = {
        'success_callback': success_callback,
        'error_callback': error_callback,
        'complete_callback': (ref4 = payload.options) != null ? ref4.complete : void 0
      };
      if ((ref5 = payload.options) != null) {
        ref5.complete = void 0;
      }
      if (has_hostname(payload.url)) {
        debug("Dropping hostname from url " + payload.url + ", consider refactoring url creation logic");
      }
      if (this.server_status !== STATUS_SERVER_READY) {
        warn('Wormhole server is not ready, putting transaction to queue');
        return this.pending_queue.push(payload);
      } else {
        return _postMessage(JSON.stringify(payload), this.SERVER_URL, this.SERVER_WINDOW);
      }
    };

    return WormholeClient;

  })();

  module.exports = {
    Client: WormholeClient
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeClient/lib/PostMessage */
'lib/PostMessage': function(exports, require, module) {(function() {
(function() {
  var ADD_EVENT_LISTENER, ATTACH_EVENT, DETACH_EVENT, HAS_POST_MESSAGE, POST_MESSAGE, REMOVE_EVENT_LISTENER, ROOT_OBJECT, cache_bust, is_function, last_hash, p_receiveMessage, postMessage;

  is_function = require('libprotein').is_function;

  ADD_EVENT_LISTENER = 'addEventListener';

  REMOVE_EVENT_LISTENER = 'removeEventListener';

  ATTACH_EVENT = 'attachEvent';

  DETACH_EVENT = 'detachEvent';

  POST_MESSAGE = 'postMessage';

  ROOT_OBJECT = window;

  HAS_POST_MESSAGE = !!ROOT_OBJECT[POST_MESSAGE];

  cache_bust = 1;

  last_hash = '';

  postMessage = function(message, target_urls, target) {
    var target_url;
    target_url = Array.isArray(target_urls) ? target_urls[0] : target_urls;
    if (target_url && target) {
      message = typeof message === 'string' ? message : JSON.stringify(message);
      if (HAS_POST_MESSAGE) {
        target[POST_MESSAGE](message, target_url.replace(/([^:]+:\/\/[^\/]+).*/, '$1'));
      } else if (target_url) {
        target.location = target_url.replace(/#.*$/, '') + '#' + (+(new Date)) + (cache_bust++) + '&' + message;
      }
      return true;
    } else {
      return false;
    }
  };

  p_receiveMessage = function(callback, source_origin, delay) {
    var interval_id, rm_callback;
    if (typeof source_origin === 'string' && source_origin.substr(source_origin.length - 1) === '/') {
      source_origin = source_origin.substr(0, source_origin.length - 1);
    }
    if (HAS_POST_MESSAGE) {
      if (callback) {
        (typeof rm_callback !== "undefined" && rm_callback !== null) && p_receiveMessage();
        rm_callback = function(e) {
          if ((typeof source_origin === 'string' && e.origin === source_origin) || (is_function(source_origin) && source_origin(e.origin) === true)) {
            return callback(e);
          }
        };
      }
      if (ROOT_OBJECT[ADD_EVENT_LISTENER]) {
        return ROOT_OBJECT[callback ? ADD_EVENT_LISTENER : REMOVE_EVENT_LISTENER]('message', rm_callback, false);
      } else {
        return ROOT_OBJECT[callback ? ATTACH_EVENT : DETACH_EVENT]('onmessage', rm_callback);
      }
    } else {
      (typeof interval_id !== "undefined" && interval_id !== null) && clearInterval(interval_id);
      interval_id = null;
      if (callback) {
        delay = typeof source_origin === 'number' ? source_origin : typeof delay === 'number' ? delay : 100;
      }
      return interval_id = setInterval(function() {
        var hash, re;
        hash = document.location.hash;
        re = /^#?\d+&/;
        if (hash !== last_hash && re.test(hash)) {
          last_hash = hash;
          return callback({
            data: hash.replace(re, '')
          });
        }
      }, delay);
    }
  };

  module.exports = [postMessage, p_receiveMessage];

}).call(this);

}).call(this);},

/*ZB:  WormholeClient/lib/defs */
'lib/defs': function(exports, require, module) {(function() {
(function() {
  module.exports = {
    STATUS_SERVER_READY: 'wormhole_server_ready'
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeClient/lib/util */
'lib/util': function(exports, require, module) {(function() {
(function() {
  var has_hostname, relative_url, uuid;

  relative_url = function(url) {
    var a;
    a = document.createElement('a');
    a.href = url;
    return a.pathname + a.search;
  };

  has_hostname = function(url) {
    return (url != null) && (url.match(/https?:\/\//) != null);
  };

  uuid = function() {
    var i, itoh, s;
    s = [];
    itoh = '0123456789ABCDEF'.split('');
    s = (function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 36; i = ++j) {
        results.push(Math.floor(Math.random() * 0x10));
      }
      return results;
    })();
    s[14] = 4;
    s[19] = (s[19] & 0x3) | 0x8;
    s = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = s.length; j < len; j++) {
        i = s[j];
        results.push(itoh[s[i]]);
      }
      return results;
    })();
    s[8] = s[13] = s[18] = s[23] = '-';
    return s.join('');
  };

  module.exports = {
    relative_url: relative_url,
    has_hostname: has_hostname,
    uuid: uuid
  };

}).call(this);

}).call(this);}
});


/*ZB:  */
require.define('', {

/*ZB:  /gettext */
'gettext': function(exports, require, module) {(function() {
(function() {
  var gettext;

  gettext = function(a) {
    return a;
  };

  module.exports = {
    gettext: gettext
  };

}).call(this);

}).call(this);}
});


/*ZB: CSLib */
require.define('CSLib', {

/*ZB:  CSLib/CSLib */
'CSLib': function(exports, require, module) {(function() {
(function() {
  var $, Spine, lib;

  require('lib/setup');

  Spine = require('spine');

  $ = Spine.$;

  lib = {
    IO: require('lib/io'),
    AUTOIO: require('lib/autoio'),
    uuid: require('lib/uuid'),
    utils: require('lib/utils'),
    object_utils: require('lib/object_utils'),
    custom_widgets: require('lib/custom_widgets')
  };

  module.exports = lib;

}).call(this);

}).call(this);},

/*ZB:  CSLib/index */
'index': function(exports, require, module) {(function() {
(function() {
  var _AppState, get_config, sl, wc, whc;

  _AppState = window.AppState;

  sl = require('service-locator');

  whc = sl.locate('WormholeClient', _AppState);

  if (!whc) {
    wc = require('WormholeClient');
    get_config = require('config').get_config;
    sl.provide({
      name: 'WormholeClient',
      instance: new wc.Client(get_config('CS.DEFAULT_ORIGIN', _AppState)),
      singleton: true
    }, _AppState);
  }

  module.exports = {
    IO: require('lib/io'),
    AUTOIO: require('lib/autoio'),
    uuid: require('lib/uuid'),
    utils: require('lib/utils'),
    pluralize: require('lib/pluralize'),
    object_utils: require('lib/object_utils'),
    custom_widgets: require('lib/custom_widgets'),
    validation: require('lib/validation'),
    async: require('lib/async'),
    storage: require('lib/storage')
  };

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/async */
'lib/async': function(exports, require, module) {(function() {
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                setImmediate(fn);
            };
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
        }
    }
    else {
        async.nextTick = process.nextTick;
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            var sync = true;
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        if (sync) {
                            async.nextTick(iterate);
                        }
                        else {
                            iterate();
                        }
                    }
                }
            });
            sync = false;
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                if (err) {
                    callback(err);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    async.nextTick(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.nextTick(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            var sync = true;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                if (sync) {
                    async.nextTick(function () {
                        async.whilst(test, iterator, callback);
                    });
                }
                else {
                    async.whilst(test, iterator, callback);
                }
            });
            sync = false;
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        var sync = true;
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                if (sync) {
                    async.nextTick(function () {
                        async.doWhilst(iterator, test, callback);
                    });
                }
                else {
                    async.doWhilst(iterator, test, callback);
                }
            }
            else {
                callback();
            }
        });
        sync = false;
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            var sync = true;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                if (sync) {
                    async.nextTick(function () {
                        async.until(test, iterator, callback);
                    });
                }
                else {
                    async.until(test, iterator, callback);
                }
            });
            sync = false;
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        var sync = true;
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                if (sync) {
                    async.nextTick(function () {
                        async.doUntil(iterator, test, callback);
                    });
                }
                else {
                    async.doUntil(iterator, test, callback);
                }
            }
            else {
                callback();
            }
        });
        sync = false;
    };

    async.queue = function (worker, concurrency) {
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.nextTick(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var sync = true;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(function () {
                        var cbArgs = arguments;

                        if (sync) {
                            async.nextTick(function () {
                                next.apply(null, cbArgs);
                            });
                        } else {
                            next.apply(null, arguments);
                        }
                    });
                    worker(task.data, cb);
                    sync = false;
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.nextTick(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this);},

/*ZB:  CSLib/lib/autoio */
'lib/autoio': function(exports, require, module) {(function() {
(function() {
  var TRANSPORT_TYPE, TYPE, WH, _AppState, emitter, get_config, is_foreign_origin, ref, ref1, set_config, sl, whc;

  ref = require('config'), get_config = ref.get_config, set_config = ref.set_config;

  is_foreign_origin = require('lib/utils').is_foreign_origin;

  sl = require('service-locator');

  _AppState = window.AppState;

  TRANSPORT_TYPE = 'Wormhole';

  TYPE = 'io';

  module.exports = is_foreign_origin() ? (WH = sl.locate('Wormhole', _AppState), WH ? WH.Client : ((ref1 = require('event-channel'), emitter = ref1.emitter, ref1), whc = sl.locate('WormholeClient', _AppState), WH = {
    Client: {
      GET: function(url, success_callback, error_callback, options, data) {
        var payload;
        payload = {
          method: 'GET',
          data: data,
          url: url,
          options: options,
          _type: TYPE
        };
        return whc.postMessage(payload, success_callback, error_callback);
      },
      POST: function(url, data, success_callback, error_callback, options) {
        var payload;
        payload = {
          method: 'POST',
          data: data,
          url: url,
          options: options,
          _type: TYPE
        };
        return whc.postMessage(payload, success_callback, error_callback);
      },
      PUT: function(url, data, success_callback, error_callback, options) {
        var payload;
        payload = {
          method: 'PUT',
          data: data,
          url: url,
          options: options,
          _type: TYPE
        };
        return whc.postMessage(payload, success_callback, error_callback);
      },
      DELETE: function(url, data, success_callback, error_callback, options) {
        var payload;
        payload = {
          method: 'DELETE',
          data: data,
          url: url,
          options: options,
          _type: TYPE
        };
        return whc.postMessage(payload, success_callback, error_callback);
      },
      type: TRANSPORT_TYPE
    },
    on_ready: (function() {
      var WH_READY, WORMHOLE_STATUS_SERVER_READY, queue;
      WH_READY = false;
      WORMHOLE_STATUS_SERVER_READY = 'wormhole_server_ready';
      queue = [];
      emitter.sub(WORMHOLE_STATUS_SERVER_READY, function() {
        WH_READY = true;
        queue.map(function(f) {
          return f();
        });
        return queue = [];
      });
      return function(cb) {
        if (WH_READY) {
          return cb();
        } else {
          return queue.push(cb);
        }
      };
    })()
  }, sl.provide({
    name: 'Wormhole',
    instance: WH,
    singleton: true
  }, _AppState), WH.Client)) : require("lib/io");

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/custom_widgets */
'lib/custom_widgets': function(exports, require, module) {(function() {
(function() {
  var $;

  $ = jQuery;

  module.exports = {
    select_dropdown: function(drop_down) {

      /*
          Transform functionality of the html select tag to div
          The chosen value sets to dropdown hidden input
      
            +------------------+
            |  dropdown value  | DropDown
          +----------------------+
          |  dropdown list item  | DropDown List
          +----------------------+
      
          select_dropdown takes a dict:
          drop_down = {
              CSS_DROP_DOWN_SEL
              CSS_DROP_DOWN_VALUE_SEL
              CSS_DROP_DOWN_LIST_SEL
              CSS_DROP_DOWN_LIST_ITEM_SEL
          }
       */
      var _set_val, drop_down_el, drop_down_value_el, input_el, list_el, list_item_el, select_val;
      _set_val = function(item_el) {
        var option_value;
        option_value = item_el.data('value');
        drop_down_value_el.html(item_el.html());
        input_el.val(option_value);
        return input_el.trigger("change");
      };
      drop_down_el = $(drop_down.CSS_DROP_DOWN_SEL);
      drop_down_value_el = $(drop_down.CSS_DROP_DOWN_VALUE_SEL);
      list_el = $(drop_down.CSS_DROP_DOWN_LIST_SEL);
      list_item_el = $(drop_down.CSS_DROP_DOWN_LIST_ITEM_SEL);
      input_el = drop_down_el.find('input:first');
      select_val = input_el.val();
      if (select_val) {
        list_item_el.each(function(idx, item) {
          if ($(item).val() === select_val) {
            return _set_val($(item));
          }
        });
      }
      drop_down_el.click(function(ev) {
        if (list_el.is(":hidden")) {
          if (drop_down.CSS_DROP_DOWN_ACTIVE_STATE_CLS) {
            return drop_down_el.addClass(drop_down.CSS_DROP_DOWN_ACTIVE_STATE_CLS);
          } else {
            return list_el.show();
          }
        } else {
          if (drop_down.CSS_DROP_DOWN_ACTIVE_STATE_CLS) {
            return drop_down_el.removeClass(drop_down.CSS_DROP_DOWN_ACTIVE_STATE_CLS);
          } else {
            return list_el.hide();
          }
        }
      });
      list_item_el.click(function(ev) {
        return _set_val($(ev.target));
      });
      return $(document.body).click(function(ev) {
        var element;
        element = $(ev.target);
        if (element.parents(drop_down.CSS_DROP_DOWN_SEL).length === 0) {
          if (!element.is(drop_down_el)) {
            if (drop_down.CSS_DROP_DOWN_ACTIVE_STATE_CLS) {
              return drop_down_el.removeClass(drop_down.CSS_DROP_DOWN_ACTIVE_STATE_CLS);
            } else {
              return list_el.hide();
            }
          }
        }
      });
    },
    replace_with_input: function(from_el, to_el, style_cls, input_cls) {
      var content, div, id, input, with_name;
      if (from_el.is(":input")) {
        return null;
      } else {
        input_cls || (input_cls = 'b-input__field');
        id = to_el.attr('id');
        to_el.remove();
        with_name = to_el.attr('name');
        content = $.trim(from_el.text());
        input = $("<input>", {
          'class': input_cls
        });
        input.attr('type', 'input').attr('id', id).attr('name', with_name).attr('value', content);
        div = $("<div>", {
          'class': style_cls
        });
        div.append(input);
        from_el.replaceWith(div);
        return input.focus();
      }
    },
    tumbler: function(arg) {
      var switcher_s, view;
      view = arg.view, switcher_s = arg.switcher_s;
      "@view: template for toggler rendering\n@switcher_s:\n    _______________________\n    |  __________________\n    |  |        |      | |\n    |  | Yes/No |   1  | |\n    |  |________|______|_|\n    |________________________\n\n        1: switcher_s - selector fot switch tumbler.";
      return function(arg1) {
        var active, el, j_el, render, switcher_click_handler, toggle_cb;
        el = arg1.el, active = arg1.active, toggle_cb = arg1.toggle_cb;
        "@el : placeholder for toggler rendering.\n@active : tumbler state\n@toggle_cb : if we need to validate tumbler logic somehow we may provide cb function\n  that will be executed after tumbler toggling, and will accept current status of tumbler.";
        j_el = $(el);
        render = function() {
          return j_el.html(require(view)({
            active: active
          }));
        };
        render();
        switcher_click_handler = toggle_cb ? function() {
          active = !active;
          return toggle_cb(active);
        } : function() {
          active = !active;
          return render();
        };
        j_el.delegate(switcher_s, 'click', switcher_click_handler);
        return {
          render: render,
          check: function() {
            active = true;
            return render();
          },
          uncheck: function() {
            active = false;
            return render();
          },
          val: function() {
            return active;
          }
        };
      };
    }
  };

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/io */
'lib/io': function(exports, require, module) {(function() {
(function() {
  var $, EXPECTED_CONTENT_TYPE, SENT_CONTENT_TYPE;

  $ = jQuery;

  EXPECTED_CONTENT_TYPE = 'json';

  SENT_CONTENT_TYPE = 'application/json; charset=utf-8';

  module.exports = {
    type: 'direct',
    GET: function(url, success_cb, error_cb, options, data) {
      options || (options = {});
      return $.ajax(url, {
        type: 'GET',
        dataType: options.dataType || EXPECTED_CONTENT_TYPE,
        data: data,
        contentType: options.contentType || SENT_CONTENT_TYPE,
        success: success_cb || void 0,
        error: error_cb || void 0,
        complete: options.complete,
        async: options.async === false ? false : true
      });
    },
    POST: function(url, data, success_cb, error_cb, options) {
      options || (options = {});
      return $.ajax(url, {
        type: 'POST',
        dataType: options.dataType || EXPECTED_CONTENT_TYPE,
        contentType: options.contentType || SENT_CONTENT_TYPE,
        data: data,
        success: success_cb || void 0,
        error: error_cb || void 0,
        complete: options.complete,
        async: options.async === false ? false : true
      });
    },
    PUT: function(url, data, success_cb, error_cb, options) {
      options || (options = {});
      return $.ajax(url, {
        type: 'PUT',
        dataType: options.dataType || EXPECTED_CONTENT_TYPE,
        contentType: options.contentType || SENT_CONTENT_TYPE,
        data: data,
        success: success_cb || void 0,
        error: error_cb || void 0,
        complete: options.complete,
        async: options.async === false ? false : true
      });
    },
    DELETE: function(url, data, success_cb, error_cb, options) {
      options || (options = {});
      return $.ajax(url, {
        type: 'DELETE',
        dataType: options.dataType || EXPECTED_CONTENT_TYPE,
        contentType: options.contentType || SENT_CONTENT_TYPE,
        data: data,
        success: success_cb || void 0,
        error: error_cb || void 0,
        complete: options.complete,
        async: options.async === false ? false : true
      });
    }
  };

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/model_extender */
'lib/model_extender': function(exports, require, module) {(function() {
(function() {
  var $, Ajax_Extend, Spine, parse_responce;

  Spine = require('spine');

  $ = Spine.$;

  parse_responce = function(d) {
    if (typeof d === "string") {
      return JSON.parse(d);
    } else {
      return d;
    }
  };

  Ajax_Extend = {
    url: function() {
      return Spine.Model.host + "/" + (this.className.toLowerCase());
    },
    get_all: function(params, cb) {
      var data, url;
      data = (params.filters ? {
        filters: JSON.stringify(params.filters)
      } : void 0, params.match ? {
        match: JSON.stringify(params.match)
      } : void 0, params.order_by ? {
        order_by: JSON.stringify(params.order_by)
      } : void 0);
      if (params.page) {
        data['page'] = params.page;
      }
      url = params['url_append'] != null ? (this.url()) + "/" + params['url_append'] : this.url();
      return $.ajax({
        type: "GET",
        url: url,
        data: data,
        dataType: "json",
        success: (function(_this) {
          return function(data, status, xhr) {
            return typeof cb === "function" ? cb(null, data.data, data.meta) : void 0;
          };
        })(this),
        error: function(xhr, status, error) {
          return typeof cb === "function" ? cb(error, xhr) : void 0;
        }
      });
    },
    get_one: function(params, cb) {
      var data, id, url, url_append;
      id = params.id, url_append = params.url_append;
      url = (this.url()) + "/" + id;
      data = (params.filters ? {
        filters: JSON.stringify(params.filters)
      } : void 0, params.match ? {
        match: JSON.stringify(params.match)
      } : void 0, params.order_by ? {
        order_by: JSON.stringify(params.order_by)
      } : void 0);
      if (url_append != null) {
        url = url + "/" + url_append;
      }
      return $.ajax({
        contentType: 'application/json',
        type: "GET",
        url: url,
        data: data,
        dataType: "json",
        success: function(data) {
          return typeof cb === "function" ? cb(null, data) : void 0;
        },
        error: function(xhr, status, error) {
          return typeof cb === "function" ? cb(error, xhr) : void 0;
        }
      });
    },
    add_one: function(question, cb) {
      var xhr_;
      delete question.id;
      return xhr_ = $.ajax({
        contentType: 'application/json',
        type: "POST",
        url: this.url(),
        data: JSON.stringify(question.toJSON()),
        dataType: "json",
        success: function(data, status, xhr) {
          return typeof cb === "function" ? cb(null, data, xhr_) : void 0;
        },
        error: function(xhr, status, error) {
          return typeof cb === "function" ? cb(JSON.parse(xhr.responseText)) : void 0;
        }
      });
    },
    edit_one: function(id, attributes, params, cb) {
      var url;
      url = params['url_append'] != null ? (this.url()) + "/" + id + "/" + params['url_append'] : (this.url()) + "/" + id;
      return $.ajax({
        contentType: 'application/json',
        type: "PUT",
        url: url,
        dataType: "json",
        data: JSON.stringify(attributes),
        success: function(data) {
          return typeof cb === "function" ? cb(null, data) : void 0;
        },
        error: function(xhr, status, error) {
          return typeof cb === "function" ? cb(error, JSON.parse(xhr.responseText)) : void 0;
        }
      });
    },
    get_one_cached: function(params, cb) {
      return this.get_one(params, cb);
    },
    delete_one: function(id, cb) {
      return $.ajax({
        contentType: 'application/json',
        type: "DELETE",
        url: (this.url()) + "/" + id,
        dataType: "json",
        success: function(data) {
          return typeof cb === "function" ? cb(null, data) : void 0;
        },
        error: function(xhr, status, error) {
          return typeof cb === "function" ? cb(error, JSON.parse(xhr.responseText)) : void 0;
        }
      });
    },
    get_one_cached: function(id, cb) {
      return this.get_one(id, cb);
    },
    validate: function(item, params, cb) {
      var url, validate_url_prefix, xhr_;
      validate_url_prefix = params.url_append || 'validate';
      url = (this.url()) + "/" + validate_url_prefix;
      return xhr_ = $.ajax({
        contentType: 'application/json',
        type: "GET",
        url: url,
        data: {
          item: JSON.stringify(item.toJSON())
        },
        dataType: "json",
        success: function(data, status, xhr) {
          return typeof cb === "function" ? cb(null, data, xhr_) : void 0;
        },
        error: function(xhr, status, error) {
          return typeof cb === "function" ? cb(JSON.parse(xhr.responseText)) : void 0;
        }
      });
    }
  };

  module.exports = Ajax_Extend;

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/object_utils */
'lib/object_utils': function(exports, require, module) {(function() {
(function() {
  var copy_obj, is_empty, is_object;

  copy_obj = function(o) {
    var i, o_;
    o_ = new Object();
    for (i in o) {
      o_[i] = o[i];
    }
    return o_;
  };

  is_object = function(o) {
    return typeof o === 'object';
  };

  is_empty = function(o) {
    var i;
    if (is_object(o)) {
      return ((function() {
        var results;
        results = [];
        for (i in o) {
          results.push(i);
        }
        return results;
      })()).length === 0;
    } else if (o) {
      return o.length === 0;
    } else {
      return true;
    }
  };

  module.exports = {
    copy_obj: copy_obj,
    is_object: is_object,
    is_empty: is_empty
  };

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/pluralize */
'lib/pluralize': function(exports, require, module) {(function() {
(function() {
  var _process_ones, _process_seconds, get_plural;

  _process_ones = function(count, ones, second, others) {
    var last_two;
    if (("" + count).length > 1) {
      last_two = ("" + count).slice(-2);
      switch (last_two) {
        case "11":
          return others;
        default:
          return ones;
      }
    } else {
      return ones;
    }
  };

  _process_seconds = function(count, ones, second, others) {
    var last_two;
    if (("" + count).length > 1) {
      last_two = ("" + count).slice(-2);
      switch (last_two) {
        case "12":
        case "13":
        case "14":
          return others;
        default:
          return second;
      }
    } else {
      return second;
    }
  };

  get_plural = function(count, ones, second, others) {
    var last;
    last = ("" + count).slice(-1);
    switch (last) {
      case "1":
        return _process_ones(count, ones, second, others);
      case "2":
      case "3":
      case "4":
        return _process_seconds(count, ones, second, others);
      default:
        return others;
    }
  };

  module.exports = get_plural;

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/popup_extend */
'lib/popup_extend': function(exports, require, module) {(function() {
(function() {
  var $, EVENT_CREATE_POPUP_HELP, EVENT_CREATE_POPUP_HINT, EVENT_REMOVE_POPUPS, Popup_Extend, Spine, base;

  Spine = require('spine');

  $ = require('jquery');

  EVENT_CREATE_POPUP_HELP = 'Popup.create_popup_help';

  EVENT_CREATE_POPUP_HINT = 'Popup.create_popup_hint';

  EVENT_REMOVE_POPUPS = 'Popup.remove_popup';

  Spine.support || (Spine.support = {});

  (base = Spine.support).popups || (base.popups = []);

  Popup_Extend = {
    popups: [],
    call_popup: function(el, msg, params, title) {
      var callback, event;
      if (title == null) {
        title = '';
      }
      callback = function(popup_id) {
        return Spine.support.popups.push(popup_id);
      };
      params.callback = callback;
      event = params.is_popup_hint ? EVENT_CREATE_POPUP_HINT : EVENT_CREATE_POPUP_HELP;
      return Spine.trigger(event, el, {
        title: title,
        body: msg
      }, params);
    },
    remove_popups: function() {
      return Spine.trigger(EVENT_REMOVE_POPUPS, Spine.support.popups);
    },
    show_popups: function(container_selector, popups, popup_params, replace_map) {
      var el, ex, field, from_id, mes, results, to_id;
      if (replace_map == null) {
        replace_map = null;
      }
      "container_selector - selector of parent container for textarea\nreplace_map - dict <id from replace>: <id to replace>. This param allows to_id\n    replace some popup selectors. For example for CKEditor.";
      this.remove_popups();
      results = [];
      for (field in popups) {
        mes = popups[field];
        el = $(container_selector).find("[name='" + field + "']");
        for (from_id in replace_map) {
          to_id = replace_map[from_id];
          if (el.attr('id') === from_id) {
            el = $(to_id);
          }
        }
        try {
          if (el) {
            results.push(this.call_popup(el, mes, popup_params));
          } else {
            results.push(void 0);
          }
        } catch (_error) {
          ex = _error;
          results.push(console.log("Popup> field <" + field + "> was not found for popup"));
        }
      }
      return results;
    }
  };

  module.exports = Popup_Extend;

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/setup */
'lib/setup': function(exports, require, module) {(function() {
(function() {
  require('spine');

  require('spine/lib/local');

  require('spine/lib/ajax');

  require('spine/lib/manager');

  require('spine/lib/route');

  require('spine/lib/tmpl');

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/storage */
'lib/storage': function(exports, require, module) {(function() {
(function() {
  var TYPE, _AppState, get_config, ref, set_config, sl, whc;

  TYPE = 'storage';

  ref = require('config'), get_config = ref.get_config, set_config = ref.set_config;

  sl = require('service-locator');

  _AppState = window.AppState;

  whc = sl.locate('WormholeClient', _AppState);

  module.exports = {
    get: function(ns, key, success_callback, error_callback) {
      var payload;
      payload = {
        ns: ns,
        key: key,
        method: 'get',
        _type: TYPE
      };
      return whc.postMessage(payload, success_callback, error_callback);
    },
    set: function(ns, key, value, success_callback, error_callback) {
      var payload;
      payload = {
        ns: ns,
        key: key,
        value: value,
        method: 'set',
        _type: TYPE
      };
      return whc.postMessage(payload, success_callback, error_callback);
    },
    remove: function(ns, key, success_callback, error_callback) {
      var payload;
      payload = {
        ns: ns,
        key: key,
        method: 'remove',
        _type: TYPE
      };
      return whc.postMessage(payload, success_callback, error_callback);
    },
    observe: function() {
      throw 'not implemented yet';
    }
  };

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/utils */
'lib/utils': function(exports, require, module) {(function() {
(function() {
  var $, CS, SCHEME_SEP, U, URL_SEP, get_config, warn;

  $ = require('jquery');

  get_config = require('config').get_config;

  warn = (require('console-logger')).ns('utils').warn;

  CS = get_config('CS');

  SCHEME_SEP = '://';

  URL_SEP = '/';

  U = {
    capitalize: function(str) {
      return str.toLowerCase().replace(/^.|\s\S/g, function(a) {
        return a.toUpperCase();
      });
    },
    get_first_level_domain: function(domain) {
      if (document.location.hostname.split('.').length > 2) {
        return document.location.hostname.split('.').slice(1).join('.');
      } else {
        return document.location.hostname;
      }
    },
    get_domain: function(capitalized) {
      var domain;
      domain = U.get_first_level_domain();
      if (capitalized) {
        return U.capitalize(domain);
      } else {
        return domain;
      }
    },
    get_param_by_name: function(name) {
      var regex, regexS, results;
      name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
      regexS = "[\\?&]" + name + "=([^&#]*)";
      regex = new RegExp(regexS);
      results = regex.exec(location.search);
      if (results) {
        return decodeURIComponent(results[1].replace(/\+/g, " "));
      } else {
        return "";
      }
    },
    retrieve_scheme: function(url) {
      if (url.indexOf(SCHEME_SEP) > -1) {
        return url.split(SCHEME_SEP)[0];
      } else {
        return null;
      }
    },
    retrieve_host: function(url) {
      var host, protocol;
      protocol = retrieve_scheme(url);
      if (protocol) {
        host = url.split(URL_SEP)[2];
        return "" + protocol + SCHEME_SEP + host;
      } else {
        return url.split(URL_SEP)[0];
      }
    },
    get_max_z_index: function() {
      var z_index;
      z_index = null;
      $("*").each(function(idx, el) {
        var _z_index, el_o;
        el_o = $(el);
        _z_index = parseInt(el_o.css('z-index'), 10) || 0;
        if (_z_index > z_index) {
          return z_index = _z_index;
        }
      });
      return z_index;
    },
    validate_email: function(email_str) {
      var re;
      re = /^[a-z0-9._%+-]{1,64}@(?:[a-z0-9][a-z0-9\-]{0,62}\.)+[a-z]{2,}$/;
      return re.test(email_str.toString().toLowerCase());
    },
    apify: function(version, scope) {
      var base, routing_version, routing_version_scope, scope_url_prefix, version_str, version_url_prefix;
      if (version == null) {
        version = void 0;
      }
      if (scope == null) {
        scope = void 0;
      }
      if (version != null) {
        version_str = 'v' + version;
        version_url_prefix = "/" + version_str;
        if ((base = CS.ROUTING)[version_str] == null) {
          base[version_str] = {};
        }
        routing_version = CS.ROUTING[version_str];
      } else {
        version_url_prefix = '';
        routing_version = CS.ROUTING;
      }
      if (scope != null) {
        scope_url_prefix = "/" + scope;
        if (routing_version[scope] == null) {
          routing_version[scope] = {};
        }
        routing_version_scope = routing_version[scope];
      } else {
        scope_url_prefix = '';
        routing_version_scope = routing_version;
      }
      return function(urls) {
        var action, results1, url;
        results1 = [];
        for (action in urls) {
          url = urls[action];
          results1.push(routing_version_scope[action] = "/api" + version_url_prefix + scope_url_prefix + url);
        }
        return results1;
      };
    },
    is_foreign_origin: function() {
      return CS.DEFAULT_ORIGIN !== CS.CURRENT_ORIGIN;
    },
    bool: function(val) {
      return !!val;
    },
    is_uaprom: function() {
      return CS.COUNTRY.code === "UA";
    },
    is_ruprom: function() {
      return CS.COUNTRY.code === "RU";
    },
    is_belprom: function() {
      return CS.COUNTRY.code === "BY";
    },
    is_kzprom: function() {
      return CS.COUNTRY.code === "KZ";
    },
    is_mdprom: function() {
      return CS.COUNTRY.code === "MD";
    },
    is_numeric: $.isNumeric,
    format_rank: function(val) {
      if (!val) {
        return null;
      }
      val = val.toString();
      return val.replace(/(\d)(?=(\d{3})+([^\d]|$))/g, '$1 ');
    },
    all: function(lst) {
      return U.asbool(lst.reduce((function(a, b) {
        return a && b;
      }), true));
    },
    any: function(lst) {
      return U.asbool(lst.reduce((function(a, b) {
        return a || b;
      }), false));
    },
    first: function(lst) {
      if (lst.length) {
        return lst[0];
      } else {
        return null;
      }
    },
    object_length: function(object) {
      return (Object.keys(object)).length;
    },
    hide: function(el) {
      return $(el).addClass("h-hidden");
    },
    show: function(el) {
      return $(el).removeClass("h-hidden");
    },
    escape: function(str) {
      return $('<div/>').text(str).html();
    },
    flatten: function(array, results) {
      var item, j, len;
      if (results == null) {
        results = [];
      }
      if (!(array != null ? array.length : void 0)) {
        return [];
      }
      for (j = 0, len = array.length; j < len; j++) {
        item = array[j];
        if (Array.isArray(item)) {
          U.flatten(item, results);
        } else {
          results.push(item);
        }
      }
      return results;
    },
    find: function(func, iterator, _default) {
      return U.first(iterator.filter(func)) || _default;
    },
    regexp_quote: function(s) {
      return s.replace(/([.?*+^$[(){}|\\])/g, "\\$1");
    },
    pluralize: require('lib/pluralize'),
    asbool: function(value) {
      switch (U.trim(String(value).toLowerCase())) {
        case "true":
        case '1':
        case 'yes':
        case 'on':
          return true;
        case 'false':
        case '0':
        case 'no':
        case 'off':
          return false;
        default:
          throw "Can't coerce to boolean:" + value;
      }
    },
    show_element: function(element) {
      return ($("#" + element)).show();
    },
    hide_element: function(element) {
      return ($("#" + element)).hide();
    },
    is_type_text: function(element) {
      return element.type === "text";
    },
    is_type_checkbox: function(element) {
      return element.type === "checkbox";
    },
    is_type_select_one: function(element) {
      return element.type === "select-one";
    },
    is_type_radio: function(element) {
      return element.type === "radio";
    },
    is_type_radio_group: function(element) {
      return element.length && U.is_type_radio(element[0]);
    },
    is_type_label: function(element) {
      return element.tagName.toLowerCase() === "label";
    },
    trim: function(str) {
      return str.replace(/^\s+|\s+$/g, '');
    },
    strip: function(str) {
      return str.replace(/^\s+|\s+$/g, '');
    },
    group_set_property: function(elements_ids, property, value) {
      var id, results1;
      results1 = [];
      for (id in elements_ids) {
        results1.push(($("#" + id)).prop(property, value));
      }
      return results1;
    },
    group_set_checked: function(elements_ids, checked) {
      return U.group_set_property(elements_ids, "checked", checked);
    },
    group_conjunct_property: function(elements_ids, property) {
      var i;
      return ((function() {
        var results1;
        results1 = [];
        for (i in elements_ids) {
          results1.push(i);
        }
        return results1;
      })()).map(function(id) {
        return ($("#" + id)).prop(property);
      }).reduce(function(a, b) {
        return a && b;
      });
    },
    grayscaleImage: function(imgObj) {
      var avg, canvas, canvasContext, i, imgH, imgPixels, imgW, j, k, ref, ref1, x, y;
      canvas = document.createElement('canvas');
      if (!canvas.getContext) {
        return '';
      }
      canvasContext = canvas.getContext('2d');
      imgW = imgObj.width;
      imgH = imgObj.height;
      canvas.width = imgW;
      canvas.height = imgH;
      canvasContext.drawImage(imgObj, 0, 0);
      imgPixels = canvasContext.getImageData(0, 0, imgW, imgH);
      for (y = j = 0, ref = imgPixels.height; j <= ref; y = j += 1) {
        for (x = k = 0, ref1 = imgPixels.width; k <= ref1; x = k += 1) {
          i = (y * 4) * imgPixels.width + x * 4;
          avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
          imgPixels.data[i] = avg;
          imgPixels.data[i + 1] = avg;
          imgPixels.data[i + 2] = avg;
        }
      }
      canvasContext.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);
      return canvas.toDataURL();
    }
  };

  module.exports = U;

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/uuid */
'lib/uuid': function(exports, require, module) {(function() {
(function() {
  var uuid;

  uuid = function() {
    var i, itoh, s;
    s = [];
    itoh = '0123456789ABCDEF'.split('');
    s = (function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 36; i = ++j) {
        results.push(Math.floor(Math.random() * 0x10));
      }
      return results;
    })();
    s[14] = 4;
    s[19] = (s[19] & 0x3) | 0x8;
    s = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = s.length; j < len; j++) {
        i = s[j];
        results.push(itoh[s[i]]);
      }
      return results;
    })();
    s[8] = s[13] = s[18] = s[23] = '-';
    return s.join('');
  };

  module.exports = uuid;

}).call(this);

}).call(this);},

/*ZB:  CSLib/lib/validation */
'lib/validation': function(exports, require, module) {(function() {
(function() {
  var $, EVENT_CREATE_POPUP_HELP, EVENT_REMOVE_POPUPS, POPUPS, POPUP_TYPE_ERROR, POPUP_TYPE_NORMAL, POPUP_Z_INDEX, Spine, TEXT, _popup, country_phone_code, get_config, gettext, hide_error_popups, is_valid_country_code, is_valid_phone, is_valid_phone_code, is_valid_phone_field, show_error_popup, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  gettext = require("gettext").gettext;

  Spine = require('spine');

  $ = require('jquery');

  get_config = require('config').get_config;

  country_phone_code = get_config('CS.COUNTRY.phone_code');

  util = require('lib/utils');

  EVENT_CREATE_POPUP_HELP = 'Popup.create_popup_help';

  EVENT_REMOVE_POPUPS = 'Popup.remove_popup';

  POPUP_TYPE_NORMAL = 'NORMAL';

  POPUP_TYPE_ERROR = 'ERROR';

  TEXT = {
    PHONE: gettext("Неверный формат номера. Укажите только цифры, например " + country_phone_code + " 12 3456789"),
    COUNTRY_CODE: gettext("Заполните код страны, например " + country_phone_code)
  };

  POPUP_Z_INDEX = 6000;

  POPUPS = [];

  _popup = function(el, msg, type) {
    Spine.trigger(EVENT_REMOVE_POPUPS, POPUPS);
    return Spine.trigger(EVENT_CREATE_POPUP_HELP, el, {
      title: '',
      body: msg
    }, {
      callback: function(popup_id) {
        return POPUPS.push(popup_id);
      },
      z_index: POPUP_Z_INDEX,
      fixed: true,
      css_class: 'b-popup_type_hint-with-closer',
      type: type || POPUP_TYPE_NORMAL
    });
  };

  show_error_popup = function(el, msg, POPUP_TYPE_ERROR) {
    return _popup(el, msg, POPUP_TYPE_ERROR);
  };

  hide_error_popups = function() {
    return Spine.trigger(EVENT_REMOVE_POPUPS, POPUPS);
  };

  is_valid_country_code = function(code) {
    var ref;
    return indexOf.call(code, '+') < 0 && (1 <= (ref = code.length) && ref <= 4) && $.isNumeric(code);
  };

  is_valid_phone_code = function(phone_code) {
    var ref;
    if (!$.isNumeric(phone_code)) {
      return false;
    } else if ((1 < (ref = phone_code.length) && ref < 7)) {
      return true;
    } else {
      return false;
    }
  };

  is_valid_phone = function(phone) {
    var ref;
    if (!$.isNumeric(phone)) {
      return false;
    } else if ((4 < (ref = phone.length) && ref <= 12)) {
      return true;
    } else {
      return false;
    }
  };

  is_valid_phone_field = function(fields, values, success_cb, error_cb) {
    var code_el, country_code, country_code_el, phone, phone_code, phone_dict, phone_el;
    country_code_el = fields.country_code_el;
    code_el = fields.code_el;
    phone_el = fields.phone_el;
    country_code = values.country_code;
    phone_code = values.phone_code;
    phone = values.phone;
    if ((is_valid_phone(phone)) && (is_valid_phone_code(phone_code))) {
      if ((country_code_el.is(":input")) && !(is_valid_country_code(country_code))) {
        return show_error_popup(country_code_el, TEXT.COUNTRY_CODE);
      } else {
        phone_dict = {
          country_code: country_code,
          phone_code: phone_code,
          phone: phone
        };
        hide_error_popups();
        return typeof success_cb === "function" ? success_cb(phone_dict) : void 0;
      }
    } else {
      if (typeof error_cb === "function") {
        error_cb();
      }
      if (country_code_el) {
        country_code_el.focus();
      } else {
        code_el.focus();
      }
      if ((country_code_el.is(":input")) && !(is_valid_country_code(country_code))) {
        return show_error_popup(country_code_el, TEXT.COUNTRY_CODE);
      } else if (!(is_valid_phone_code(phone_code))) {
        return show_error_popup(code_el, TEXT.PHONE);
      } else if (!(is_valid_phone(phone))) {
        return show_error_popup(phone_el, TEXT.PHONE);
      } else {
        return true;
      }
    }
  };

  module.exports = {
    show_error_popup: show_error_popup,
    hide_error_popups: hide_error_popups,
    is_valid_country_code: is_valid_country_code,
    is_valid_phone_code: is_valid_phone_code,
    is_valid_phone: is_valid_phone,
    is_valid_phone_field: is_valid_phone_field
  };

}).call(this);

}).call(this);}
});


/*ZB: commonjs-jquery */
require.define('commonjs-jquery', {

/*ZB:  commonjs-jquery/index */
'index': function(exports, require, module) {(function() {
module.exports = require('commonjs-jquery')
}).call(this);},

/*ZB:  commonjs-jquery/commonjs-jquery */
'commonjs-jquery': function(exports, require, module) {(function() {
(function() {
  var create = function(window, noConflictMode) {
    var navigator = window.navigator;
    var location = window.location;
    /*!
     * jQuery JavaScript Library v1.7.1
     * http://jquery.com/
     *
     * Copyright 2011, John Resig
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     *
     * Includes Sizzle.js
     * http://sizzlejs.com/
     * Copyright 2011, The Dojo Foundation
     * Released under the MIT, BSD, and GPL Licenses.
     *
     * Date: Mon Nov 21 21:11:03 2011 -0500
     */
    (function( window, undefined ) {
    
    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
    	navigator = window.navigator,
    	location = window.location;
    var jQuery = (function() {
    
    // Define a local copy of jQuery
    var jQuery = function( selector, context ) {
    		// The jQuery object is actually just the init constructor 'enhanced'
    		return new jQuery.fn.init( selector, context, rootjQuery );
    	},
    
    	// Map over jQuery in case of overwrite
    	_jQuery = window.jQuery,
    
    	// Map over the $ in case of overwrite
    	_$ = window.$,
    
    	// A central reference to the root jQuery(document)
    	rootjQuery,
    
    	// A simple way to check for HTML strings or ID strings
    	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
    
    	// Check if a string has a non-whitespace character in it
    	rnotwhite = /\S/,
    
    	// Used for trimming whitespace
    	trimLeft = /^\s+/,
    	trimRight = /\s+$/,
    
    	// Match a standalone tag
    	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
    
    	// JSON RegExp
    	rvalidchars = /^[\],:{}\s]*$/,
    	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
    	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
    	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
    
    	// Useragent RegExp
    	rwebkit = /(webkit)[ \/]([\w.]+)/,
    	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
    	rmsie = /(msie) ([\w.]+)/,
    	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,
    
    	// Matches dashed string for camelizing
    	rdashAlpha = /-([a-z]|[0-9])/ig,
    	rmsPrefix = /^-ms-/,
    
    	// Used by jQuery.camelCase as callback to replace()
    	fcamelCase = function( all, letter ) {
    		return ( letter + "" ).toUpperCase();
    	},
    
    	// Keep a UserAgent string for use with jQuery.browser
    	userAgent = navigator.userAgent,
    
    	// For matching the engine and version of the browser
    	browserMatch,
    
    	// The deferred used on DOM ready
    	readyList,
    
    	// The ready event handler
    	DOMContentLoaded,
    
    	// Save a reference to some core methods
    	toString = Object.prototype.toString,
    	hasOwn = Object.prototype.hasOwnProperty,
    	push = Array.prototype.push,
    	slice = Array.prototype.slice,
    	trim = String.prototype.trim,
    	indexOf = Array.prototype.indexOf,
    
    	// [[Class]] -> type pairs
    	class2type = {};
    
    jQuery.fn = jQuery.prototype = {
    	constructor: jQuery,
    	init: function( selector, context, rootjQuery ) {
    		var match, elem, ret, doc;
    
    		// Handle $(""), $(null), or $(undefined)
    		if ( !selector ) {
    			return this;
    		}
    
    		// Handle $(DOMElement)
    		if ( selector.nodeType ) {
    			this.context = this[0] = selector;
    			this.length = 1;
    			return this;
    		}
    
    		// The body element only exists once, optimize finding it
    		if ( selector === "body" && !context && document.body ) {
    			this.context = document;
    			this[0] = document.body;
    			this.selector = selector;
    			this.length = 1;
    			return this;
    		}
    
    		// Handle HTML strings
    		if ( typeof selector === "string" ) {
    			// Are we dealing with HTML string or an ID?
    			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
    				// Assume that strings that start and end with <> are HTML and skip the regex check
    				match = [ null, selector, null ];
    
    			} else {
    				match = quickExpr.exec( selector );
    			}
    
    			// Verify a match, and that no context was specified for #id
    			if ( match && (match[1] || !context) ) {
    
    				// HANDLE: $(html) -> $(array)
    				if ( match[1] ) {
    					context = context instanceof jQuery ? context[0] : context;
    					doc = ( context ? context.ownerDocument || context : document );
    
    					// If a single string is passed in and it's a single tag
    					// just do a createElement and skip the rest
    					ret = rsingleTag.exec( selector );
    
    					if ( ret ) {
    						if ( jQuery.isPlainObject( context ) ) {
    							selector = [ document.createElement( ret[1] ) ];
    							jQuery.fn.attr.call( selector, context, true );
    
    						} else {
    							selector = [ doc.createElement( ret[1] ) ];
    						}
    
    					} else {
    						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
    						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
    					}
    
    					return jQuery.merge( this, selector );
    
    				// HANDLE: $("#id")
    				} else {
    					elem = document.getElementById( match[2] );
    
    					// Check parentNode to catch when Blackberry 4.6 returns
    					// nodes that are no longer in the document #6963
    					if ( elem && elem.parentNode ) {
    						// Handle the case where IE and Opera return items
    						// by name instead of ID
    						if ( elem.id !== match[2] ) {
    							return rootjQuery.find( selector );
    						}
    
    						// Otherwise, we inject the element directly into the jQuery object
    						this.length = 1;
    						this[0] = elem;
    					}
    
    					this.context = document;
    					this.selector = selector;
    					return this;
    				}
    
    			// HANDLE: $(expr, $(...))
    			} else if ( !context || context.jquery ) {
    				return ( context || rootjQuery ).find( selector );
    
    			// HANDLE: $(expr, context)
    			// (which is just equivalent to: $(context).find(expr)
    			} else {
    				return this.constructor( context ).find( selector );
    			}
    
    		// HANDLE: $(function)
    		// Shortcut for document ready
    		} else if ( jQuery.isFunction( selector ) ) {
    			return rootjQuery.ready( selector );
    		}
    
    		if ( selector.selector !== undefined ) {
    			this.selector = selector.selector;
    			this.context = selector.context;
    		}
    
    		return jQuery.makeArray( selector, this );
    	},
    
    	// Start with an empty selector
    	selector: "",
    
    	// The current version of jQuery being used
    	jquery: "1.7.1",
    
    	// The default length of a jQuery object is 0
    	length: 0,
    
    	// The number of elements contained in the matched element set
    	size: function() {
    		return this.length;
    	},
    
    	toArray: function() {
    		return slice.call( this, 0 );
    	},
    
    	// Get the Nth element in the matched element set OR
    	// Get the whole matched element set as a clean array
    	get: function( num ) {
    		return num == null ?
    
    			// Return a 'clean' array
    			this.toArray() :
    
    			// Return just the object
    			( num < 0 ? this[ this.length + num ] : this[ num ] );
    	},
    
    	// Take an array of elements and push it onto the stack
    	// (returning the new matched element set)
    	pushStack: function( elems, name, selector ) {
    		// Build a new jQuery matched element set
    		var ret = this.constructor();
    
    		if ( jQuery.isArray( elems ) ) {
    			push.apply( ret, elems );
    
    		} else {
    			jQuery.merge( ret, elems );
    		}
    
    		// Add the old object onto the stack (as a reference)
    		ret.prevObject = this;
    
    		ret.context = this.context;
    
    		if ( name === "find" ) {
    			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
    		} else if ( name ) {
    			ret.selector = this.selector + "." + name + "(" + selector + ")";
    		}
    
    		// Return the newly-formed element set
    		return ret;
    	},
    
    	// Execute a callback for every element in the matched set.
    	// (You can seed the arguments with an array of args, but this is
    	// only used internally.)
    	each: function( callback, args ) {
    		return jQuery.each( this, callback, args );
    	},
    
    	ready: function( fn ) {
    		// Attach the listeners
    		jQuery.bindReady();
    
    		// Add the callback
    		readyList.add( fn );
    
    		return this;
    	},
    
    	eq: function( i ) {
    		i = +i;
    		return i === -1 ?
    			this.slice( i ) :
    			this.slice( i, i + 1 );
    	},
    
    	first: function() {
    		return this.eq( 0 );
    	},
    
    	last: function() {
    		return this.eq( -1 );
    	},
    
    	slice: function() {
    		return this.pushStack( slice.apply( this, arguments ),
    			"slice", slice.call(arguments).join(",") );
    	},
    
    	map: function( callback ) {
    		return this.pushStack( jQuery.map(this, function( elem, i ) {
    			return callback.call( elem, i, elem );
    		}));
    	},
    
    	end: function() {
    		return this.prevObject || this.constructor(null);
    	},
    
    	// For internal use only.
    	// Behaves like an Array's method, not like a jQuery method.
    	push: push,
    	sort: [].sort,
    	splice: [].splice
    };
    
    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;
    
    jQuery.extend = jQuery.fn.extend = function() {
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[0] || {},
    		i = 1,
    		length = arguments.length,
    		deep = false;
    
    	// Handle a deep copy situation
    	if ( typeof target === "boolean" ) {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	}
    
    	// Handle case when target is a string or something (possible in deep copy)
    	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
    		target = {};
    	}
    
    	// extend jQuery itself if only one argument is passed
    	if ( length === i ) {
    		target = this;
    		--i;
    	}
    
    	for ( ; i < length; i++ ) {
    		// Only deal with non-null/undefined values
    		if ( (options = arguments[ i ]) != null ) {
    			// Extend the base object
    			for ( name in options ) {
    				src = target[ name ];
    				copy = options[ name ];
    
    				// Prevent never-ending loop
    				if ( target === copy ) {
    					continue;
    				}
    
    				// Recurse if we're merging plain objects or arrays
    				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
    					if ( copyIsArray ) {
    						copyIsArray = false;
    						clone = src && jQuery.isArray(src) ? src : [];
    
    					} else {
    						clone = src && jQuery.isPlainObject(src) ? src : {};
    					}
    
    					// Never move original objects, clone them
    					target[ name ] = jQuery.extend( deep, clone, copy );
    
    				// Don't bring in undefined values
    				} else if ( copy !== undefined ) {
    					target[ name ] = copy;
    				}
    			}
    		}
    	}
    
    	// Return the modified object
    	return target;
    };
    
    jQuery.extend({
    	noConflict: function( deep ) {
    		if ( window.$ === jQuery ) {
    			window.$ = _$;
    		}
    
    		if ( deep && window.jQuery === jQuery ) {
    			window.jQuery = _jQuery;
    		}
    
    		return jQuery;
    	},
    
    	// Is the DOM ready to be used? Set to true once it occurs.
    	isReady: false,
    
    	// A counter to track how many items to wait for before
    	// the ready event fires. See #6781
    	readyWait: 1,
    
    	// Hold (or release) the ready event
    	holdReady: function( hold ) {
    		if ( hold ) {
    			jQuery.readyWait++;
    		} else {
    			jQuery.ready( true );
    		}
    	},
    
    	// Handle when the DOM is ready
    	ready: function( wait ) {
    		// Either a released hold or an DOMready/load event and not yet ready
    		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
    			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
    			if ( !document.body ) {
    				return setTimeout( jQuery.ready, 1 );
    			}
    
    			// Remember that the DOM is ready
    			jQuery.isReady = true;
    
    			// If a normal DOM Ready event fired, decrement, and wait if need be
    			if ( wait !== true && --jQuery.readyWait > 0 ) {
    				return;
    			}
    
    			// If there are functions bound, to execute
    			readyList.fireWith( document, [ jQuery ] );
    
    			// Trigger any bound ready events
    			if ( jQuery.fn.trigger ) {
    				jQuery( document ).trigger( "ready" ).off( "ready" );
    			}
    		}
    	},
    
    	bindReady: function() {
    		if ( readyList ) {
    			return;
    		}
    
    		readyList = jQuery.Callbacks( "once memory" );
    
    		// Catch cases where $(document).ready() is called after the
    		// browser event has already occurred.
    		if ( document.readyState === "complete" ) {
    			// Handle it asynchronously to allow scripts the opportunity to delay ready
    			return setTimeout( jQuery.ready, 1 );
    		}
    
    		// Mozilla, Opera and webkit nightlies currently support this event
    		if ( document.addEventListener ) {
    			// Use the handy event callback
    			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
    
    			// A fallback to window.onload, that will always work
    			window.addEventListener( "load", jQuery.ready, false );
    
    		// If IE event model is used
    		} else if ( document.attachEvent ) {
    			// ensure firing before onload,
    			// maybe late but safe also for iframes
    			document.attachEvent( "onreadystatechange", DOMContentLoaded );
    
    			// A fallback to window.onload, that will always work
    			window.attachEvent( "onload", jQuery.ready );
    
    			// If IE and not a frame
    			// continually check to see if the document is ready
    			var toplevel = false;
    
    			try {
    				toplevel = window.frameElement == null;
    			} catch(e) {}
    
    			if ( document.documentElement.doScroll && toplevel ) {
    				doScrollCheck();
    			}
    		}
    	},
    
    	// See test/unit/core.js for details concerning isFunction.
    	// Since version 1.3, DOM methods and functions like alert
    	// aren't supported. They return false on IE (#2968).
    	isFunction: function( obj ) {
    		return jQuery.type(obj) === "function";
    	},
    
    	isArray: Array.isArray || function( obj ) {
    		return jQuery.type(obj) === "array";
    	},
    
    	// A crude way of determining if an object is a window
    	isWindow: function( obj ) {
    		return obj && typeof obj === "object" && "setInterval" in obj;
    	},
    
    	isNumeric: function( obj ) {
    		return !isNaN( parseFloat(obj) ) && isFinite( obj );
    	},
    
    	type: function( obj ) {
    		return obj == null ?
    			String( obj ) :
    			class2type[ toString.call(obj) ] || "object";
    	},
    
    	isPlainObject: function( obj ) {
    		// Must be an Object.
    		// Because of IE, we also have to check the presence of the constructor property.
    		// Make sure that DOM nodes and window objects don't pass through, as well
    		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
    			return false;
    		}
    
    		try {
    			// Not own constructor property must be Object
    			if ( obj.constructor &&
    				!hasOwn.call(obj, "constructor") &&
    				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
    				return false;
    			}
    		} catch ( e ) {
    			// IE8,9 Will throw exceptions on certain host objects #9897
    			return false;
    		}
    
    		// Own properties are enumerated firstly, so to speed up,
    		// if last one is own, then all properties are own.
    
    		var key;
    		for ( key in obj ) {}
    
    		return key === undefined || hasOwn.call( obj, key );
    	},
    
    	isEmptyObject: function( obj ) {
    		for ( var name in obj ) {
    			return false;
    		}
    		return true;
    	},
    
    	error: function( msg ) {
    		throw new Error( msg );
    	},
    
    	parseJSON: function( data ) {
    		if ( typeof data !== "string" || !data ) {
    			return null;
    		}
    
    		// Make sure leading/trailing whitespace is removed (IE can't handle it)
    		data = jQuery.trim( data );
    
    		// Attempt to parse using the native JSON parser first
    		if ( window.JSON && window.JSON.parse ) {
    			return window.JSON.parse( data );
    		}
    
    		// Make sure the incoming data is actual JSON
    		// Logic borrowed from http://json.org/json2.js
    		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
    			.replace( rvalidtokens, "]" )
    			.replace( rvalidbraces, "")) ) {
    
    			return ( new Function( "return " + data ) )();
    
    		}
    		jQuery.error( "Invalid JSON: " + data );
    	},
    
    	// Cross-browser xml parsing
    	parseXML: function( data ) {
    		var xml, tmp;
    		try {
    			if ( window.DOMParser ) { // Standard
    				tmp = new DOMParser();
    				xml = tmp.parseFromString( data , "text/xml" );
    			} else { // IE
    				xml = new ActiveXObject( "Microsoft.XMLDOM" );
    				xml.async = "false";
    				xml.loadXML( data );
    			}
    		} catch( e ) {
    			xml = undefined;
    		}
    		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
    			jQuery.error( "Invalid XML: " + data );
    		}
    		return xml;
    	},
    
    	noop: function() {},
    
    	// Evaluates a script in a global context
    	// Workarounds based on findings by Jim Driscoll
    	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    	globalEval: function( data ) {
    		if ( data && rnotwhite.test( data ) ) {
    			// We use execScript on Internet Explorer
    			// We use an anonymous function so that context is window
    			// rather than jQuery in Firefox
    			( window.execScript || function( data ) {
    				window[ "eval" ].call( window, data );
    			} )( data );
    		}
    	},
    
    	// Convert dashed to camelCase; used by the css and data modules
    	// Microsoft forgot to hump their vendor prefix (#9572)
    	camelCase: function( string ) {
    		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    	},
    
    	nodeName: function( elem, name ) {
    		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
    	},
    
    	// args is for internal usage only
    	each: function( object, callback, args ) {
    		var name, i = 0,
    			length = object.length,
    			isObj = length === undefined || jQuery.isFunction( object );
    
    		if ( args ) {
    			if ( isObj ) {
    				for ( name in object ) {
    					if ( callback.apply( object[ name ], args ) === false ) {
    						break;
    					}
    				}
    			} else {
    				for ( ; i < length; ) {
    					if ( callback.apply( object[ i++ ], args ) === false ) {
    						break;
    					}
    				}
    			}
    
    		// A special, fast, case for the most common use of each
    		} else {
    			if ( isObj ) {
    				for ( name in object ) {
    					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
    						break;
    					}
    				}
    			} else {
    				for ( ; i < length; ) {
    					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
    						break;
    					}
    				}
    			}
    		}
    
    		return object;
    	},
    
    	// Use native String.trim function wherever possible
    	trim: trim ?
    		function( text ) {
    			return text == null ?
    				"" :
    				trim.call( text );
    		} :
    
    		// Otherwise use our own trimming functionality
    		function( text ) {
    			return text == null ?
    				"" :
    				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
    		},
    
    	// results is for internal usage only
    	makeArray: function( array, results ) {
    		var ret = results || [];
    
    		if ( array != null ) {
    			// The window, strings (and functions) also have 'length'
    			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
    			var type = jQuery.type( array );
    
    			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
    				push.call( ret, array );
    			} else {
    				jQuery.merge( ret, array );
    			}
    		}
    
    		return ret;
    	},
    
    	inArray: function( elem, array, i ) {
    		var len;
    
    		if ( array ) {
    			if ( indexOf ) {
    				return indexOf.call( array, elem, i );
    			}
    
    			len = array.length;
    			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
    
    			for ( ; i < len; i++ ) {
    				// Skip accessing in sparse arrays
    				if ( i in array && array[ i ] === elem ) {
    					return i;
    				}
    			}
    		}
    
    		return -1;
    	},
    
    	merge: function( first, second ) {
    		var i = first.length,
    			j = 0;
    
    		if ( typeof second.length === "number" ) {
    			for ( var l = second.length; j < l; j++ ) {
    				first[ i++ ] = second[ j ];
    			}
    
    		} else {
    			while ( second[j] !== undefined ) {
    				first[ i++ ] = second[ j++ ];
    			}
    		}
    
    		first.length = i;
    
    		return first;
    	},
    
    	grep: function( elems, callback, inv ) {
    		var ret = [], retVal;
    		inv = !!inv;
    
    		// Go through the array, only saving the items
    		// that pass the validator function
    		for ( var i = 0, length = elems.length; i < length; i++ ) {
    			retVal = !!callback( elems[ i ], i );
    			if ( inv !== retVal ) {
    				ret.push( elems[ i ] );
    			}
    		}
    
    		return ret;
    	},
    
    	// arg is for internal usage only
    	map: function( elems, callback, arg ) {
    		var value, key, ret = [],
    			i = 0,
    			length = elems.length,
    			// jquery objects are treated as arrays
    			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
    
    		// Go through the array, translating each of the items to their
    		if ( isArray ) {
    			for ( ; i < length; i++ ) {
    				value = callback( elems[ i ], i, arg );
    
    				if ( value != null ) {
    					ret[ ret.length ] = value;
    				}
    			}
    
    		// Go through every key on the object,
    		} else {
    			for ( key in elems ) {
    				value = callback( elems[ key ], key, arg );
    
    				if ( value != null ) {
    					ret[ ret.length ] = value;
    				}
    			}
    		}
    
    		// Flatten any nested arrays
    		return ret.concat.apply( [], ret );
    	},
    
    	// A global GUID counter for objects
    	guid: 1,
    
    	// Bind a function to a context, optionally partially applying any
    	// arguments.
    	proxy: function( fn, context ) {
    		if ( typeof context === "string" ) {
    			var tmp = fn[ context ];
    			context = fn;
    			fn = tmp;
    		}
    
    		// Quick check to determine if target is callable, in the spec
    		// this throws a TypeError, but we will just return undefined.
    		if ( !jQuery.isFunction( fn ) ) {
    			return undefined;
    		}
    
    		// Simulated bind
    		var args = slice.call( arguments, 2 ),
    			proxy = function() {
    				return fn.apply( context, args.concat( slice.call( arguments ) ) );
    			};
    
    		// Set the guid of unique handler to the same of original handler, so it can be removed
    		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
    
    		return proxy;
    	},
    
    	// Mutifunctional method to get and set values to a collection
    	// The value/s can optionally be executed if it's a function
    	access: function( elems, key, value, exec, fn, pass ) {
    		var length = elems.length;
    
    		// Setting many attributes
    		if ( typeof key === "object" ) {
    			for ( var k in key ) {
    				jQuery.access( elems, k, key[k], exec, fn, value );
    			}
    			return elems;
    		}
    
    		// Setting one attribute
    		if ( value !== undefined ) {
    			// Optionally, function values get executed if exec is true
    			exec = !pass && exec && jQuery.isFunction(value);
    
    			for ( var i = 0; i < length; i++ ) {
    				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
    			}
    
    			return elems;
    		}
    
    		// Getting an attribute
    		return length ? fn( elems[0], key ) : undefined;
    	},
    
    	now: function() {
    		return ( new Date() ).getTime();
    	},
    
    	// Use of jQuery.browser is frowned upon.
    	// More details: http://docs.jquery.com/Utilities/jQuery.browser
    	uaMatch: function( ua ) {
    		ua = ua.toLowerCase();
    
    		var match = rwebkit.exec( ua ) ||
    			ropera.exec( ua ) ||
    			rmsie.exec( ua ) ||
    			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
    			[];
    
    		return { browser: match[1] || "", version: match[2] || "0" };
    	},
    
    	sub: function() {
    		function jQuerySub( selector, context ) {
    			return new jQuerySub.fn.init( selector, context );
    		}
    		jQuery.extend( true, jQuerySub, this );
    		jQuerySub.superclass = this;
    		jQuerySub.fn = jQuerySub.prototype = this();
    		jQuerySub.fn.constructor = jQuerySub;
    		jQuerySub.sub = this.sub;
    		jQuerySub.fn.init = function init( selector, context ) {
    			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
    				context = jQuerySub( context );
    			}
    
    			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
    		};
    		jQuerySub.fn.init.prototype = jQuerySub.fn;
    		var rootjQuerySub = jQuerySub(document);
    		return jQuerySub;
    	},
    
    	browser: {}
    });
    
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
    	class2type[ "[object " + name + "]" ] = name.toLowerCase();
    });
    
    browserMatch = jQuery.uaMatch( userAgent );
    if ( browserMatch.browser ) {
    	jQuery.browser[ browserMatch.browser ] = true;
    	jQuery.browser.version = browserMatch.version;
    }
    
    // Deprecated, use jQuery.browser.webkit instead
    if ( jQuery.browser.webkit ) {
    	jQuery.browser.safari = true;
    }
    
    // IE doesn't match non-breaking spaces with \s
    if ( rnotwhite.test( "\xA0" ) ) {
    	trimLeft = /^[\s\xA0]+/;
    	trimRight = /[\s\xA0]+$/;
    }
    
    // All jQuery objects should point back to these
    rootjQuery = jQuery(document);
    
    // Cleanup functions for the document ready method
    if ( document.addEventListener ) {
    	DOMContentLoaded = function() {
    		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
    		jQuery.ready();
    	};
    
    } else if ( document.attachEvent ) {
    	DOMContentLoaded = function() {
    		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
    		if ( document.readyState === "complete" ) {
    			document.detachEvent( "onreadystatechange", DOMContentLoaded );
    			jQuery.ready();
    		}
    	};
    }
    
    // The DOM ready check for Internet Explorer
    function doScrollCheck() {
    	if ( jQuery.isReady ) {
    		return;
    	}
    
    	try {
    		// If IE is used, use the trick by Diego Perini
    		// http://javascript.nwbox.com/IEContentLoaded/
    		document.documentElement.doScroll("left");
    	} catch(e) {
    		setTimeout( doScrollCheck, 1 );
    		return;
    	}
    
    	// and execute any waiting functions
    	jQuery.ready();
    }
    
    return jQuery;
    
    })();
    
    
    // String to Object flags format cache
    var flagsCache = {};
    
    // Convert String-formatted flags into Object-formatted ones and store in cache
    function createFlags( flags ) {
    	var object = flagsCache[ flags ] = {},
    		i, length;
    	flags = flags.split( /\s+/ );
    	for ( i = 0, length = flags.length; i < length; i++ ) {
    		object[ flags[i] ] = true;
    	}
    	return object;
    }
    
    /*
     * Create a callback list using the following parameters:
     *
     *	flags:	an optional list of space-separated flags that will change how
     *			the callback list behaves
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible flags:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function( flags ) {
    
    	// Convert flags from String-formatted to Object-formatted
    	// (we check in cache first)
    	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};
    
    	var // Actual callback list
    		list = [],
    		// Stack of fire calls for repeatable lists
    		stack = [],
    		// Last fire value (for non-forgettable lists)
    		memory,
    		// Flag to know if list is currently firing
    		firing,
    		// First callback to fire (used internally by add and fireWith)
    		firingStart,
    		// End of the loop when firing
    		firingLength,
    		// Index of currently firing callback (modified by remove if needed)
    		firingIndex,
    		// Add one or several callbacks to the list
    		add = function( args ) {
    			var i,
    				length,
    				elem,
    				type,
    				actual;
    			for ( i = 0, length = args.length; i < length; i++ ) {
    				elem = args[ i ];
    				type = jQuery.type( elem );
    				if ( type === "array" ) {
    					// Inspect recursively
    					add( elem );
    				} else if ( type === "function" ) {
    					// Add if not in unique mode and callback is not in
    					if ( !flags.unique || !self.has( elem ) ) {
    						list.push( elem );
    					}
    				}
    			}
    		},
    		// Fire callbacks
    		fire = function( context, args ) {
    			args = args || [];
    			memory = !flags.memory || [ context, args ];
    			firing = true;
    			firingIndex = firingStart || 0;
    			firingStart = 0;
    			firingLength = list.length;
    			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
    				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
    					memory = true; // Mark as halted
    					break;
    				}
    			}
    			firing = false;
    			if ( list ) {
    				if ( !flags.once ) {
    					if ( stack && stack.length ) {
    						memory = stack.shift();
    						self.fireWith( memory[ 0 ], memory[ 1 ] );
    					}
    				} else if ( memory === true ) {
    					self.disable();
    				} else {
    					list = [];
    				}
    			}
    		},
    		// Actual Callbacks object
    		self = {
    			// Add a callback or a collection of callbacks to the list
    			add: function() {
    				if ( list ) {
    					var length = list.length;
    					add( arguments );
    					// Do we need to add the callbacks to the
    					// current firing batch?
    					if ( firing ) {
    						firingLength = list.length;
    					// With memory, if we're not firing then
    					// we should call right away, unless previous
    					// firing was halted (stopOnFalse)
    					} else if ( memory && memory !== true ) {
    						firingStart = length;
    						fire( memory[ 0 ], memory[ 1 ] );
    					}
    				}
    				return this;
    			},
    			// Remove a callback from the list
    			remove: function() {
    				if ( list ) {
    					var args = arguments,
    						argIndex = 0,
    						argLength = args.length;
    					for ( ; argIndex < argLength ; argIndex++ ) {
    						for ( var i = 0; i < list.length; i++ ) {
    							if ( args[ argIndex ] === list[ i ] ) {
    								// Handle firingIndex and firingLength
    								if ( firing ) {
    									if ( i <= firingLength ) {
    										firingLength--;
    										if ( i <= firingIndex ) {
    											firingIndex--;
    										}
    									}
    								}
    								// Remove the element
    								list.splice( i--, 1 );
    								// If we have some unicity property then
    								// we only need to do this once
    								if ( flags.unique ) {
    									break;
    								}
    							}
    						}
    					}
    				}
    				return this;
    			},
    			// Control if a given callback is in the list
    			has: function( fn ) {
    				if ( list ) {
    					var i = 0,
    						length = list.length;
    					for ( ; i < length; i++ ) {
    						if ( fn === list[ i ] ) {
    							return true;
    						}
    					}
    				}
    				return false;
    			},
    			// Remove all callbacks from the list
    			empty: function() {
    				list = [];
    				return this;
    			},
    			// Have the list do nothing anymore
    			disable: function() {
    				list = stack = memory = undefined;
    				return this;
    			},
    			// Is it disabled?
    			disabled: function() {
    				return !list;
    			},
    			// Lock the list in its current state
    			lock: function() {
    				stack = undefined;
    				if ( !memory || memory === true ) {
    					self.disable();
    				}
    				return this;
    			},
    			// Is it locked?
    			locked: function() {
    				return !stack;
    			},
    			// Call all callbacks with the given context and arguments
    			fireWith: function( context, args ) {
    				if ( stack ) {
    					if ( firing ) {
    						if ( !flags.once ) {
    							stack.push( [ context, args ] );
    						}
    					} else if ( !( flags.once && memory ) ) {
    						fire( context, args );
    					}
    				}
    				return this;
    			},
    			// Call all the callbacks with the given arguments
    			fire: function() {
    				self.fireWith( this, arguments );
    				return this;
    			},
    			// To know if the callbacks have already been called at least once
    			fired: function() {
    				return !!memory;
    			}
    		};
    
    	return self;
    };
    
    
    
    
    var // Static reference to slice
    	sliceDeferred = [].slice;
    
    jQuery.extend({
    
    	Deferred: function( func ) {
    		var doneList = jQuery.Callbacks( "once memory" ),
    			failList = jQuery.Callbacks( "once memory" ),
    			progressList = jQuery.Callbacks( "memory" ),
    			state = "pending",
    			lists = {
    				resolve: doneList,
    				reject: failList,
    				notify: progressList
    			},
    			promise = {
    				done: doneList.add,
    				fail: failList.add,
    				progress: progressList.add,
    
    				state: function() {
    					return state;
    				},
    
    				// Deprecated
    				isResolved: doneList.fired,
    				isRejected: failList.fired,
    
    				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
    					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
    					return this;
    				},
    				always: function() {
    					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
    					return this;
    				},
    				pipe: function( fnDone, fnFail, fnProgress ) {
    					return jQuery.Deferred(function( newDefer ) {
    						jQuery.each( {
    							done: [ fnDone, "resolve" ],
    							fail: [ fnFail, "reject" ],
    							progress: [ fnProgress, "notify" ]
    						}, function( handler, data ) {
    							var fn = data[ 0 ],
    								action = data[ 1 ],
    								returned;
    							if ( jQuery.isFunction( fn ) ) {
    								deferred[ handler ](function() {
    									returned = fn.apply( this, arguments );
    									if ( returned && jQuery.isFunction( returned.promise ) ) {
    										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
    									} else {
    										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
    									}
    								});
    							} else {
    								deferred[ handler ]( newDefer[ action ] );
    							}
    						});
    					}).promise();
    				},
    				// Get a promise for this deferred
    				// If obj is provided, the promise aspect is added to the object
    				promise: function( obj ) {
    					if ( obj == null ) {
    						obj = promise;
    					} else {
    						for ( var key in promise ) {
    							obj[ key ] = promise[ key ];
    						}
    					}
    					return obj;
    				}
    			},
    			deferred = promise.promise({}),
    			key;
    
    		for ( key in lists ) {
    			deferred[ key ] = lists[ key ].fire;
    			deferred[ key + "With" ] = lists[ key ].fireWith;
    		}
    
    		// Handle state
    		deferred.done( function() {
    			state = "resolved";
    		}, failList.disable, progressList.lock ).fail( function() {
    			state = "rejected";
    		}, doneList.disable, progressList.lock );
    
    		// Call given func if any
    		if ( func ) {
    			func.call( deferred, deferred );
    		}
    
    		// All done!
    		return deferred;
    	},
    
    	// Deferred helper
    	when: function( firstParam ) {
    		var args = sliceDeferred.call( arguments, 0 ),
    			i = 0,
    			length = args.length,
    			pValues = new Array( length ),
    			count = length,
    			pCount = length,
    			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
    				firstParam :
    				jQuery.Deferred(),
    			promise = deferred.promise();
    		function resolveFunc( i ) {
    			return function( value ) {
    				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
    				if ( !( --count ) ) {
    					deferred.resolveWith( deferred, args );
    				}
    			};
    		}
    		function progressFunc( i ) {
    			return function( value ) {
    				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
    				deferred.notifyWith( promise, pValues );
    			};
    		}
    		if ( length > 1 ) {
    			for ( ; i < length; i++ ) {
    				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
    					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
    				} else {
    					--count;
    				}
    			}
    			if ( !count ) {
    				deferred.resolveWith( deferred, args );
    			}
    		} else if ( deferred !== firstParam ) {
    			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
    		}
    		return promise;
    	}
    });
    
    
    
    
    jQuery.support = (function() {
    
    	var support,
    		all,
    		a,
    		select,
    		opt,
    		input,
    		marginDiv,
    		fragment,
    		tds,
    		events,
    		eventName,
    		i,
    		isSupported,
    		div = document.createElement( "div" ),
    		documentElement = document.documentElement;
    
    	// Preliminary tests
    	div.setAttribute("className", "t");
    	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
    
    	all = div.getElementsByTagName( "*" );
    	a = div.getElementsByTagName( "a" )[ 0 ];
    
    	// Can't get basic test support
    	if ( !all || !all.length || !a ) {
    		return {};
    	}
    
    	// First batch of supports tests
    	select = document.createElement( "select" );
    	opt = select.appendChild( document.createElement("option") );
    	input = div.getElementsByTagName( "input" )[ 0 ];
    
    	support = {
    		// IE strips leading whitespace when .innerHTML is used
    		leadingWhitespace: ( div.firstChild.nodeType === 3 ),
    
    		// Make sure that tbody elements aren't automatically inserted
    		// IE will insert them into empty tables
    		tbody: !div.getElementsByTagName("tbody").length,
    
    		// Make sure that link elements get serialized correctly by innerHTML
    		// This requires a wrapper element in IE
    		htmlSerialize: !!div.getElementsByTagName("link").length,
    
    		// Get the style information from getAttribute
    		// (IE uses .cssText instead)
    		style: /top/.test( a.getAttribute("style") ),
    
    		// Make sure that URLs aren't manipulated
    		// (IE normalizes it by default)
    		hrefNormalized: ( a.getAttribute("href") === "/a" ),
    
    		// Make sure that element opacity exists
    		// (IE uses filter instead)
    		// Use a regex to work around a WebKit issue. See #5145
    		opacity: /^0.55/.test( a.style.opacity ),
    
    		// Verify style float existence
    		// (IE uses styleFloat instead of cssFloat)
    		cssFloat: !!a.style.cssFloat,
    
    		// Make sure that if no value is specified for a checkbox
    		// that it defaults to "on".
    		// (WebKit defaults to "" instead)
    		checkOn: ( input.value === "on" ),
    
    		// Make sure that a selected-by-default option has a working selected property.
    		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    		optSelected: opt.selected,
    
    		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    		getSetAttribute: div.className !== "t",
    
    		// Tests for enctype support on a form(#6743)
    		enctype: !!document.createElement("form").enctype,
    
    		// Makes sure cloning an html5 element does not cause problems
    		// Where outerHTML is undefined, this still works
    		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
    
    		// Will be defined later
    		submitBubbles: true,
    		changeBubbles: true,
    		focusinBubbles: false,
    		deleteExpando: true,
    		noCloneEvent: true,
    		inlineBlockNeedsLayout: false,
    		shrinkWrapBlocks: false,
    		reliableMarginRight: true
    	};
    
    	// Make sure checked status is properly cloned
    	input.checked = true;
    	support.noCloneChecked = input.cloneNode( true ).checked;
    
    	// Make sure that the options inside disabled selects aren't marked as disabled
    	// (WebKit marks them as disabled)
    	select.disabled = true;
    	support.optDisabled = !opt.disabled;
    
    	// Test to see if it's possible to delete an expando from an element
    	// Fails in Internet Explorer
    	try {
    		delete div.test;
    	} catch( e ) {
    		support.deleteExpando = false;
    	}
    
    	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
    		div.attachEvent( "onclick", function() {
    			// Cloning a node shouldn't copy over any
    			// bound event handlers (IE does this)
    			support.noCloneEvent = false;
    		});
    		div.cloneNode( true ).fireEvent( "onclick" );
    	}
    
    	// Check if a radio maintains its value
    	// after being appended to the DOM
    	input = document.createElement("input");
    	input.value = "t";
    	input.setAttribute("type", "radio");
    	support.radioValue = input.value === "t";
    
    	input.setAttribute("checked", "checked");
    	div.appendChild( input );
    	fragment = document.createDocumentFragment();
    	fragment.appendChild( div.lastChild );
    
    	// WebKit doesn't clone checked state correctly in fragments
    	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
    
    	// Check if a disconnected checkbox will retain its checked
    	// value of true after appended to the DOM (IE6/7)
    	support.appendChecked = input.checked;
    
    	fragment.removeChild( input );
    	fragment.appendChild( div );
    
    	div.innerHTML = "";
    
    	// Check if div with explicit width and no margin-right incorrectly
    	// gets computed margin-right based on width of container. For more
    	// info see bug #3333
    	// Fails in WebKit before Feb 2011 nightlies
    	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
    	if ( window.getComputedStyle ) {
    		marginDiv = document.createElement( "div" );
    		marginDiv.style.width = "0";
    		marginDiv.style.marginRight = "0";
    		div.style.width = "2px";
    		div.appendChild( marginDiv );
    		support.reliableMarginRight =
    			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
    	}
    
    	// Technique from Juriy Zaytsev
    	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
    	// We only care about the case where non-standard event systems
    	// are used, namely in IE. Short-circuiting here helps us to
    	// avoid an eval call (in setAttribute) which can cause CSP
    	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
    	if ( div.attachEvent ) {
    		for( i in {
    			submit: 1,
    			change: 1,
    			focusin: 1
    		}) {
    			eventName = "on" + i;
    			isSupported = ( eventName in div );
    			if ( !isSupported ) {
    				div.setAttribute( eventName, "return;" );
    				isSupported = ( typeof div[ eventName ] === "function" );
    			}
    			support[ i + "Bubbles" ] = isSupported;
    		}
    	}
    
    	fragment.removeChild( div );
    
    	// Null elements to avoid leaks in IE
    	fragment = select = opt = marginDiv = div = input = null;
    
    	// Run tests that need a body at doc ready
    	jQuery(function() {
    		var container, outer, inner, table, td, offsetSupport,
    			conMarginTop, ptlm, vb, style, html,
    			body = document.getElementsByTagName("body")[0];
    
    		if ( !body ) {
    			// Return for frameset docs that don't have a body
    			return;
    		}
    
    		conMarginTop = 1;
    		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
    		vb = "visibility:hidden;border:0;";
    		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
    		html = "<div " + style + "><div></div></div>" +
    			"<table " + style + " cellpadding='0' cellspacing='0'>" +
    			"<tr><td></td></tr></table>";
    
    		container = document.createElement("div");
    		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
    		body.insertBefore( container, body.firstChild );
    
    		// Construct the test element
    		div = document.createElement("div");
    		container.appendChild( div );
    
    		// Check if table cells still have offsetWidth/Height when they are set
    		// to display:none and there are still other visible table cells in a
    		// table row; if so, offsetWidth/Height are not reliable for use when
    		// determining if an element has been hidden directly using
    		// display:none (it is still safe to use offsets if a parent element is
    		// hidden; don safety goggles and see bug #4512 for more information).
    		// (only IE 8 fails this test)
    		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
    		tds = div.getElementsByTagName( "td" );
    		isSupported = ( tds[ 0 ].offsetHeight === 0 );
    
    		tds[ 0 ].style.display = "";
    		tds[ 1 ].style.display = "none";
    
    		// Check if empty table cells still have offsetWidth/Height
    		// (IE <= 8 fail this test)
    		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
    
    		// Figure out if the W3C box model works as expected
    		div.innerHTML = "";
    		div.style.width = div.style.paddingLeft = "1px";
    		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;
    
    		if ( typeof div.style.zoom !== "undefined" ) {
    			// Check if natively block-level elements act like inline-block
    			// elements when setting their display to 'inline' and giving
    			// them layout
    			// (IE < 8 does this)
    			div.style.display = "inline";
    			div.style.zoom = 1;
    			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );
    
    			// Check if elements with layout shrink-wrap their children
    			// (IE 6 does this)
    			div.style.display = "";
    			div.innerHTML = "<div style='width:4px;'></div>";
    			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
    		}
    
    		div.style.cssText = ptlm + vb;
    		div.innerHTML = html;
    
    		outer = div.firstChild;
    		inner = outer.firstChild;
    		td = outer.nextSibling.firstChild.firstChild;
    
    		offsetSupport = {
    			doesNotAddBorder: ( inner.offsetTop !== 5 ),
    			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
    		};
    
    		inner.style.position = "fixed";
    		inner.style.top = "20px";
    
    		// safari subtracts parent border width here which is 5px
    		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
    		inner.style.position = inner.style.top = "";
    
    		outer.style.overflow = "hidden";
    		outer.style.position = "relative";
    
    		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
    		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );
    
    		body.removeChild( container );
    		div  = container = null;
    
    		jQuery.extend( support, offsetSupport );
    	});
    
    	return support;
    })();
    
    
    
    
    var rbrace = /^(?:\{.*\}|\[.*\])$/,
    	rmultiDash = /([A-Z])/g;
    
    jQuery.extend({
    	cache: {},
    
    	// Please use with caution
    	uuid: 0,
    
    	// Unique for each copy of jQuery on the page
    	// Non-digits removed to match rinlinejQuery
    	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
    
    	// The following elements throw uncatchable exceptions if you
    	// attempt to add expando properties to them.
    	noData: {
    		"embed": true,
    		// Ban all objects except for Flash (which handle expandos)
    		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
    		"applet": true
    	},
    
    	hasData: function( elem ) {
    		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
    		return !!elem && !isEmptyDataObject( elem );
    	},
    
    	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
    		if ( !jQuery.acceptData( elem ) ) {
    			return;
    		}
    
    		var privateCache, thisCache, ret,
    			internalKey = jQuery.expando,
    			getByName = typeof name === "string",
    
    			// We have to handle DOM nodes and JS objects differently because IE6-7
    			// can't GC object references properly across the DOM-JS boundary
    			isNode = elem.nodeType,
    
    			// Only DOM nodes need the global jQuery cache; JS object data is
    			// attached directly to the object so GC can occur automatically
    			cache = isNode ? jQuery.cache : elem,
    
    			// Only defining an ID for JS objects if its cache already exists allows
    			// the code to shortcut on the same path as a DOM node with no cache
    			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
    			isEvents = name === "events";
    
    		// Avoid doing any more work than we need to when trying to get data on an
    		// object that has no data at all
    		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
    			return;
    		}
    
    		if ( !id ) {
    			// Only DOM nodes need a new unique ID for each element since their data
    			// ends up in the global cache
    			if ( isNode ) {
    				elem[ internalKey ] = id = ++jQuery.uuid;
    			} else {
    				id = internalKey;
    			}
    		}
    
    		if ( !cache[ id ] ) {
    			cache[ id ] = {};
    
    			// Avoids exposing jQuery metadata on plain JS objects when the object
    			// is serialized using JSON.stringify
    			if ( !isNode ) {
    				cache[ id ].toJSON = jQuery.noop;
    			}
    		}
    
    		// An object can be passed to jQuery.data instead of a key/value pair; this gets
    		// shallow copied over onto the existing cache
    		if ( typeof name === "object" || typeof name === "function" ) {
    			if ( pvt ) {
    				cache[ id ] = jQuery.extend( cache[ id ], name );
    			} else {
    				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
    			}
    		}
    
    		privateCache = thisCache = cache[ id ];
    
    		// jQuery data() is stored in a separate object inside the object's internal data
    		// cache in order to avoid key collisions between internal data and user-defined
    		// data.
    		if ( !pvt ) {
    			if ( !thisCache.data ) {
    				thisCache.data = {};
    			}
    
    			thisCache = thisCache.data;
    		}
    
    		if ( data !== undefined ) {
    			thisCache[ jQuery.camelCase( name ) ] = data;
    		}
    
    		// Users should not attempt to inspect the internal events object using jQuery.data,
    		// it is undocumented and subject to change. But does anyone listen? No.
    		if ( isEvents && !thisCache[ name ] ) {
    			return privateCache.events;
    		}
    
    		// Check for both converted-to-camel and non-converted data property names
    		// If a data property was specified
    		if ( getByName ) {
    
    			// First Try to find as-is property data
    			ret = thisCache[ name ];
    
    			// Test for null|undefined property data
    			if ( ret == null ) {
    
    				// Try to find the camelCased property
    				ret = thisCache[ jQuery.camelCase( name ) ];
    			}
    		} else {
    			ret = thisCache;
    		}
    
    		return ret;
    	},
    
    	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
    		if ( !jQuery.acceptData( elem ) ) {
    			return;
    		}
    
    		var thisCache, i, l,
    
    			// Reference to internal data cache key
    			internalKey = jQuery.expando,
    
    			isNode = elem.nodeType,
    
    			// See jQuery.data for more information
    			cache = isNode ? jQuery.cache : elem,
    
    			// See jQuery.data for more information
    			id = isNode ? elem[ internalKey ] : internalKey;
    
    		// If there is already no cache entry for this object, there is no
    		// purpose in continuing
    		if ( !cache[ id ] ) {
    			return;
    		}
    
    		if ( name ) {
    
    			thisCache = pvt ? cache[ id ] : cache[ id ].data;
    
    			if ( thisCache ) {
    
    				// Support array or space separated string names for data keys
    				if ( !jQuery.isArray( name ) ) {
    
    					// try the string as a key before any manipulation
    					if ( name in thisCache ) {
    						name = [ name ];
    					} else {
    
    						// split the camel cased version by spaces unless a key with the spaces exists
    						name = jQuery.camelCase( name );
    						if ( name in thisCache ) {
    							name = [ name ];
    						} else {
    							name = name.split( " " );
    						}
    					}
    				}
    
    				for ( i = 0, l = name.length; i < l; i++ ) {
    					delete thisCache[ name[i] ];
    				}
    
    				// If there is no data left in the cache, we want to continue
    				// and let the cache object itself get destroyed
    				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
    					return;
    				}
    			}
    		}
    
    		// See jQuery.data for more information
    		if ( !pvt ) {
    			delete cache[ id ].data;
    
    			// Don't destroy the parent cache unless the internal data object
    			// had been the only thing left in it
    			if ( !isEmptyDataObject(cache[ id ]) ) {
    				return;
    			}
    		}
    
    		// Browsers that fail expando deletion also refuse to delete expandos on
    		// the window, but it will allow it on all other JS objects; other browsers
    		// don't care
    		// Ensure that `cache` is not a window object #10080
    		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
    			delete cache[ id ];
    		} else {
    			cache[ id ] = null;
    		}
    
    		// We destroyed the cache and need to eliminate the expando on the node to avoid
    		// false lookups in the cache for entries that no longer exist
    		if ( isNode ) {
    			// IE does not allow us to delete expando properties from nodes,
    			// nor does it have a removeAttribute function on Document nodes;
    			// we must handle all of these cases
    			if ( jQuery.support.deleteExpando ) {
    				delete elem[ internalKey ];
    			} else if ( elem.removeAttribute ) {
    				elem.removeAttribute( internalKey );
    			} else {
    				elem[ internalKey ] = null;
    			}
    		}
    	},
    
    	// For internal use only.
    	_data: function( elem, name, data ) {
    		return jQuery.data( elem, name, data, true );
    	},
    
    	// A method for determining if a DOM node can handle the data expando
    	acceptData: function( elem ) {
    		if ( elem.nodeName ) {
    			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];
    
    			if ( match ) {
    				return !(match === true || elem.getAttribute("classid") !== match);
    			}
    		}
    
    		return true;
    	}
    });
    
    jQuery.fn.extend({
    	data: function( key, value ) {
    		var parts, attr, name,
    			data = null;
    
    		if ( typeof key === "undefined" ) {
    			if ( this.length ) {
    				data = jQuery.data( this[0] );
    
    				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
    					attr = this[0].attributes;
    					for ( var i = 0, l = attr.length; i < l; i++ ) {
    						name = attr[i].name;
    
    						if ( name.indexOf( "data-" ) === 0 ) {
    							name = jQuery.camelCase( name.substring(5) );
    
    							dataAttr( this[0], name, data[ name ] );
    						}
    					}
    					jQuery._data( this[0], "parsedAttrs", true );
    				}
    			}
    
    			return data;
    
    		} else if ( typeof key === "object" ) {
    			return this.each(function() {
    				jQuery.data( this, key );
    			});
    		}
    
    		parts = key.split(".");
    		parts[1] = parts[1] ? "." + parts[1] : "";
    
    		if ( value === undefined ) {
    			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);
    
    			// Try to fetch any internally stored data first
    			if ( data === undefined && this.length ) {
    				data = jQuery.data( this[0], key );
    				data = dataAttr( this[0], key, data );
    			}
    
    			return data === undefined && parts[1] ?
    				this.data( parts[0] ) :
    				data;
    
    		} else {
    			return this.each(function() {
    				var self = jQuery( this ),
    					args = [ parts[0], value ];
    
    				self.triggerHandler( "setData" + parts[1] + "!", args );
    				jQuery.data( this, key, value );
    				self.triggerHandler( "changeData" + parts[1] + "!", args );
    			});
    		}
    	},
    
    	removeData: function( key ) {
    		return this.each(function() {
    			jQuery.removeData( this, key );
    		});
    	}
    });
    
    function dataAttr( elem, key, data ) {
    	// If nothing was found internally, try to fetch any
    	// data from the HTML5 data-* attribute
    	if ( data === undefined && elem.nodeType === 1 ) {
    
    		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
    
    		data = elem.getAttribute( name );
    
    		if ( typeof data === "string" ) {
    			try {
    				data = data === "true" ? true :
    				data === "false" ? false :
    				data === "null" ? null :
    				jQuery.isNumeric( data ) ? parseFloat( data ) :
    					rbrace.test( data ) ? jQuery.parseJSON( data ) :
    					data;
    			} catch( e ) {}
    
    			// Make sure we set the data so it isn't changed later
    			jQuery.data( elem, key, data );
    
    		} else {
    			data = undefined;
    		}
    	}
    
    	return data;
    }
    
    // checks a cache object for emptiness
    function isEmptyDataObject( obj ) {
    	for ( var name in obj ) {
    
    		// if the public data object is empty, the private is still empty
    		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
    			continue;
    		}
    		if ( name !== "toJSON" ) {
    			return false;
    		}
    	}
    
    	return true;
    }
    
    
    
    
    function handleQueueMarkDefer( elem, type, src ) {
    	var deferDataKey = type + "defer",
    		queueDataKey = type + "queue",
    		markDataKey = type + "mark",
    		defer = jQuery._data( elem, deferDataKey );
    	if ( defer &&
    		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
    		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
    		// Give room for hard-coded callbacks to fire first
    		// and eventually mark/queue something else on the element
    		setTimeout( function() {
    			if ( !jQuery._data( elem, queueDataKey ) &&
    				!jQuery._data( elem, markDataKey ) ) {
    				jQuery.removeData( elem, deferDataKey, true );
    				defer.fire();
    			}
    		}, 0 );
    	}
    }
    
    jQuery.extend({
    
    	_mark: function( elem, type ) {
    		if ( elem ) {
    			type = ( type || "fx" ) + "mark";
    			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
    		}
    	},
    
    	_unmark: function( force, elem, type ) {
    		if ( force !== true ) {
    			type = elem;
    			elem = force;
    			force = false;
    		}
    		if ( elem ) {
    			type = type || "fx";
    			var key = type + "mark",
    				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
    			if ( count ) {
    				jQuery._data( elem, key, count );
    			} else {
    				jQuery.removeData( elem, key, true );
    				handleQueueMarkDefer( elem, type, "mark" );
    			}
    		}
    	},
    
    	queue: function( elem, type, data ) {
    		var q;
    		if ( elem ) {
    			type = ( type || "fx" ) + "queue";
    			q = jQuery._data( elem, type );
    
    			// Speed up dequeue by getting out quickly if this is just a lookup
    			if ( data ) {
    				if ( !q || jQuery.isArray(data) ) {
    					q = jQuery._data( elem, type, jQuery.makeArray(data) );
    				} else {
    					q.push( data );
    				}
    			}
    			return q || [];
    		}
    	},
    
    	dequeue: function( elem, type ) {
    		type = type || "fx";
    
    		var queue = jQuery.queue( elem, type ),
    			fn = queue.shift(),
    			hooks = {};
    
    		// If the fx queue is dequeued, always remove the progress sentinel
    		if ( fn === "inprogress" ) {
    			fn = queue.shift();
    		}
    
    		if ( fn ) {
    			// Add a progress sentinel to prevent the fx queue from being
    			// automatically dequeued
    			if ( type === "fx" ) {
    				queue.unshift( "inprogress" );
    			}
    
    			jQuery._data( elem, type + ".run", hooks );
    			fn.call( elem, function() {
    				jQuery.dequeue( elem, type );
    			}, hooks );
    		}
    
    		if ( !queue.length ) {
    			jQuery.removeData( elem, type + "queue " + type + ".run", true );
    			handleQueueMarkDefer( elem, type, "queue" );
    		}
    	}
    });
    
    jQuery.fn.extend({
    	queue: function( type, data ) {
    		if ( typeof type !== "string" ) {
    			data = type;
    			type = "fx";
    		}
    
    		if ( data === undefined ) {
    			return jQuery.queue( this[0], type );
    		}
    		return this.each(function() {
    			var queue = jQuery.queue( this, type, data );
    
    			if ( type === "fx" && queue[0] !== "inprogress" ) {
    				jQuery.dequeue( this, type );
    			}
    		});
    	},
    	dequeue: function( type ) {
    		return this.each(function() {
    			jQuery.dequeue( this, type );
    		});
    	},
    	// Based off of the plugin by Clint Helfers, with permission.
    	// http://blindsignals.com/index.php/2009/07/jquery-delay/
    	delay: function( time, type ) {
    		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    		type = type || "fx";
    
    		return this.queue( type, function( next, hooks ) {
    			var timeout = setTimeout( next, time );
    			hooks.stop = function() {
    				clearTimeout( timeout );
    			};
    		});
    	},
    	clearQueue: function( type ) {
    		return this.queue( type || "fx", [] );
    	},
    	// Get a promise resolved when queues of a certain type
    	// are emptied (fx is the type by default)
    	promise: function( type, object ) {
    		if ( typeof type !== "string" ) {
    			object = type;
    			type = undefined;
    		}
    		type = type || "fx";
    		var defer = jQuery.Deferred(),
    			elements = this,
    			i = elements.length,
    			count = 1,
    			deferDataKey = type + "defer",
    			queueDataKey = type + "queue",
    			markDataKey = type + "mark",
    			tmp;
    		function resolve() {
    			if ( !( --count ) ) {
    				defer.resolveWith( elements, [ elements ] );
    			}
    		}
    		while( i-- ) {
    			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
    					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
    						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
    					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
    				count++;
    				tmp.add( resolve );
    			}
    		}
    		resolve();
    		return defer.promise();
    	}
    });
    
    
    
    
    var rclass = /[\n\t\r]/g,
    	rspace = /\s+/,
    	rreturn = /\r/g,
    	rtype = /^(?:button|input)$/i,
    	rfocusable = /^(?:button|input|object|select|textarea)$/i,
    	rclickable = /^a(?:rea)?$/i,
    	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
    	getSetAttribute = jQuery.support.getSetAttribute,
    	nodeHook, boolHook, fixSpecified;
    
    jQuery.fn.extend({
    	attr: function( name, value ) {
    		return jQuery.access( this, name, value, true, jQuery.attr );
    	},
    
    	removeAttr: function( name ) {
    		return this.each(function() {
    			jQuery.removeAttr( this, name );
    		});
    	},
    
    	prop: function( name, value ) {
    		return jQuery.access( this, name, value, true, jQuery.prop );
    	},
    
    	removeProp: function( name ) {
    		name = jQuery.propFix[ name ] || name;
    		return this.each(function() {
    			// try/catch handles cases where IE balks (such as removing a property on window)
    			try {
    				this[ name ] = undefined;
    				delete this[ name ];
    			} catch( e ) {}
    		});
    	},
    
    	addClass: function( value ) {
    		var classNames, i, l, elem,
    			setClass, c, cl;
    
    		if ( jQuery.isFunction( value ) ) {
    			return this.each(function( j ) {
    				jQuery( this ).addClass( value.call(this, j, this.className) );
    			});
    		}
    
    		if ( value && typeof value === "string" ) {
    			classNames = value.split( rspace );
    
    			for ( i = 0, l = this.length; i < l; i++ ) {
    				elem = this[ i ];
    
    				if ( elem.nodeType === 1 ) {
    					if ( !elem.className && classNames.length === 1 ) {
    						elem.className = value;
    
    					} else {
    						setClass = " " + elem.className + " ";
    
    						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
    							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
    								setClass += classNames[ c ] + " ";
    							}
    						}
    						elem.className = jQuery.trim( setClass );
    					}
    				}
    			}
    		}
    
    		return this;
    	},
    
    	removeClass: function( value ) {
    		var classNames, i, l, elem, className, c, cl;
    
    		if ( jQuery.isFunction( value ) ) {
    			return this.each(function( j ) {
    				jQuery( this ).removeClass( value.call(this, j, this.className) );
    			});
    		}
    
    		if ( (value && typeof value === "string") || value === undefined ) {
    			classNames = ( value || "" ).split( rspace );
    
    			for ( i = 0, l = this.length; i < l; i++ ) {
    				elem = this[ i ];
    
    				if ( elem.nodeType === 1 && elem.className ) {
    					if ( value ) {
    						className = (" " + elem.className + " ").replace( rclass, " " );
    						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
    							className = className.replace(" " + classNames[ c ] + " ", " ");
    						}
    						elem.className = jQuery.trim( className );
    
    					} else {
    						elem.className = "";
    					}
    				}
    			}
    		}
    
    		return this;
    	},
    
    	toggleClass: function( value, stateVal ) {
    		var type = typeof value,
    			isBool = typeof stateVal === "boolean";
    
    		if ( jQuery.isFunction( value ) ) {
    			return this.each(function( i ) {
    				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
    			});
    		}
    
    		return this.each(function() {
    			if ( type === "string" ) {
    				// toggle individual class names
    				var className,
    					i = 0,
    					self = jQuery( this ),
    					state = stateVal,
    					classNames = value.split( rspace );
    
    				while ( (className = classNames[ i++ ]) ) {
    					// check each className given, space seperated list
    					state = isBool ? state : !self.hasClass( className );
    					self[ state ? "addClass" : "removeClass" ]( className );
    				}
    
    			} else if ( type === "undefined" || type === "boolean" ) {
    				if ( this.className ) {
    					// store className if set
    					jQuery._data( this, "__className__", this.className );
    				}
    
    				// toggle whole className
    				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
    			}
    		});
    	},
    
    	hasClass: function( selector ) {
    		var className = " " + selector + " ",
    			i = 0,
    			l = this.length;
    		for ( ; i < l; i++ ) {
    			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
    				return true;
    			}
    		}
    
    		return false;
    	},
    
    	val: function( value ) {
    		var hooks, ret, isFunction,
    			elem = this[0];
    
    		if ( !arguments.length ) {
    			if ( elem ) {
    				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];
    
    				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
    					return ret;
    				}
    
    				ret = elem.value;
    
    				return typeof ret === "string" ?
    					// handle most common string cases
    					ret.replace(rreturn, "") :
    					// handle cases where value is null/undef or number
    					ret == null ? "" : ret;
    			}
    
    			return;
    		}
    
    		isFunction = jQuery.isFunction( value );
    
    		return this.each(function( i ) {
    			var self = jQuery(this), val;
    
    			if ( this.nodeType !== 1 ) {
    				return;
    			}
    
    			if ( isFunction ) {
    				val = value.call( this, i, self.val() );
    			} else {
    				val = value;
    			}
    
    			// Treat null/undefined as ""; convert numbers to string
    			if ( val == null ) {
    				val = "";
    			} else if ( typeof val === "number" ) {
    				val += "";
    			} else if ( jQuery.isArray( val ) ) {
    				val = jQuery.map(val, function ( value ) {
    					return value == null ? "" : value + "";
    				});
    			}
    
    			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];
    
    			// If set returns undefined, fall back to normal setting
    			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
    				this.value = val;
    			}
    		});
    	}
    });
    
    jQuery.extend({
    	valHooks: {
    		option: {
    			get: function( elem ) {
    				// attributes.value is undefined in Blackberry 4.7 but
    				// uses .value. See #6932
    				var val = elem.attributes.value;
    				return !val || val.specified ? elem.value : elem.text;
    			}
    		},
    		select: {
    			get: function( elem ) {
    				var value, i, max, option,
    					index = elem.selectedIndex,
    					values = [],
    					options = elem.options,
    					one = elem.type === "select-one";
    
    				// Nothing was selected
    				if ( index < 0 ) {
    					return null;
    				}
    
    				// Loop through all the selected options
    				i = one ? index : 0;
    				max = one ? index + 1 : options.length;
    				for ( ; i < max; i++ ) {
    					option = options[ i ];
    
    					// Don't return options that are disabled or in a disabled optgroup
    					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
    							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {
    
    						// Get the specific value for the option
    						value = jQuery( option ).val();
    
    						// We don't need an array for one selects
    						if ( one ) {
    							return value;
    						}
    
    						// Multi-Selects return an array
    						values.push( value );
    					}
    				}
    
    				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
    				if ( one && !values.length && options.length ) {
    					return jQuery( options[ index ] ).val();
    				}
    
    				return values;
    			},
    
    			set: function( elem, value ) {
    				var values = jQuery.makeArray( value );
    
    				jQuery(elem).find("option").each(function() {
    					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
    				});
    
    				if ( !values.length ) {
    					elem.selectedIndex = -1;
    				}
    				return values;
    			}
    		}
    	},
    
    	attrFn: {
    		val: true,
    		css: true,
    		html: true,
    		text: true,
    		data: true,
    		width: true,
    		height: true,
    		offset: true
    	},
    
    	attr: function( elem, name, value, pass ) {
    		var ret, hooks, notxml,
    			nType = elem.nodeType;
    
    		// don't get/set attributes on text, comment and attribute nodes
    		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
    			return;
    		}
    
    		if ( pass && name in jQuery.attrFn ) {
    			return jQuery( elem )[ name ]( value );
    		}
    
    		// Fallback to prop when attributes are not supported
    		if ( typeof elem.getAttribute === "undefined" ) {
    			return jQuery.prop( elem, name, value );
    		}
    
    		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
    
    		// All attributes are lowercase
    		// Grab necessary hook if one is defined
    		if ( notxml ) {
    			name = name.toLowerCase();
    			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
    		}
    
    		if ( value !== undefined ) {
    
    			if ( value === null ) {
    				jQuery.removeAttr( elem, name );
    				return;
    
    			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
    				return ret;
    
    			} else {
    				elem.setAttribute( name, "" + value );
    				return value;
    			}
    
    		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
    			return ret;
    
    		} else {
    
    			ret = elem.getAttribute( name );
    
    			// Non-existent attributes return null, we normalize to undefined
    			return ret === null ?
    				undefined :
    				ret;
    		}
    	},
    
    	removeAttr: function( elem, value ) {
    		var propName, attrNames, name, l,
    			i = 0;
    
    		if ( value && elem.nodeType === 1 ) {
    			attrNames = value.toLowerCase().split( rspace );
    			l = attrNames.length;
    
    			for ( ; i < l; i++ ) {
    				name = attrNames[ i ];
    
    				if ( name ) {
    					propName = jQuery.propFix[ name ] || name;
    
    					// See #9699 for explanation of this approach (setting first, then removal)
    					jQuery.attr( elem, name, "" );
    					elem.removeAttribute( getSetAttribute ? name : propName );
    
    					// Set corresponding property to false for boolean attributes
    					if ( rboolean.test( name ) && propName in elem ) {
    						elem[ propName ] = false;
    					}
    				}
    			}
    		}
    	},
    
    	attrHooks: {
    		type: {
    			set: function( elem, value ) {
    				// We can't allow the type property to be changed (since it causes problems in IE)
    				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
    					jQuery.error( "type property can't be changed" );
    				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
    					// Setting the type on a radio button after the value resets the value in IE6-9
    					// Reset value to it's default in case type is set after value
    					// This is for element creation
    					var val = elem.value;
    					elem.setAttribute( "type", value );
    					if ( val ) {
    						elem.value = val;
    					}
    					return value;
    				}
    			}
    		},
    		// Use the value property for back compat
    		// Use the nodeHook for button elements in IE6/7 (#1954)
    		value: {
    			get: function( elem, name ) {
    				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
    					return nodeHook.get( elem, name );
    				}
    				return name in elem ?
    					elem.value :
    					null;
    			},
    			set: function( elem, value, name ) {
    				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
    					return nodeHook.set( elem, value, name );
    				}
    				// Does not return so that setAttribute is also used
    				elem.value = value;
    			}
    		}
    	},
    
    	propFix: {
    		tabindex: "tabIndex",
    		readonly: "readOnly",
    		"for": "htmlFor",
    		"class": "className",
    		maxlength: "maxLength",
    		cellspacing: "cellSpacing",
    		cellpadding: "cellPadding",
    		rowspan: "rowSpan",
    		colspan: "colSpan",
    		usemap: "useMap",
    		frameborder: "frameBorder",
    		contenteditable: "contentEditable"
    	},
    
    	prop: function( elem, name, value ) {
    		var ret, hooks, notxml,
    			nType = elem.nodeType;
    
    		// don't get/set properties on text, comment and attribute nodes
    		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
    			return;
    		}
    
    		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
    
    		if ( notxml ) {
    			// Fix name and attach hooks
    			name = jQuery.propFix[ name ] || name;
    			hooks = jQuery.propHooks[ name ];
    		}
    
    		if ( value !== undefined ) {
    			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
    				return ret;
    
    			} else {
    				return ( elem[ name ] = value );
    			}
    
    		} else {
    			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
    				return ret;
    
    			} else {
    				return elem[ name ];
    			}
    		}
    	},
    
    	propHooks: {
    		tabIndex: {
    			get: function( elem ) {
    				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
    				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
    				var attributeNode = elem.getAttributeNode("tabindex");
    
    				return attributeNode && attributeNode.specified ?
    					parseInt( attributeNode.value, 10 ) :
    					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
    						0 :
    						undefined;
    			}
    		}
    	}
    });
    
    // Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
    jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;
    
    // Hook for boolean attributes
    boolHook = {
    	get: function( elem, name ) {
    		// Align boolean attributes with corresponding properties
    		// Fall back to attribute presence where some booleans are not supported
    		var attrNode,
    			property = jQuery.prop( elem, name );
    		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
    			name.toLowerCase() :
    			undefined;
    	},
    	set: function( elem, value, name ) {
    		var propName;
    		if ( value === false ) {
    			// Remove boolean attributes when set to false
    			jQuery.removeAttr( elem, name );
    		} else {
    			// value is true since we know at this point it's type boolean and not false
    			// Set boolean attributes to the same name and set the DOM property
    			propName = jQuery.propFix[ name ] || name;
    			if ( propName in elem ) {
    				// Only set the IDL specifically if it already exists on the element
    				elem[ propName ] = true;
    			}
    
    			elem.setAttribute( name, name.toLowerCase() );
    		}
    		return name;
    	}
    };
    
    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if ( !getSetAttribute ) {
    
    	fixSpecified = {
    		name: true,
    		id: true
    	};
    
    	// Use this for any attribute in IE6/7
    	// This fixes almost every IE6/7 issue
    	nodeHook = jQuery.valHooks.button = {
    		get: function( elem, name ) {
    			var ret;
    			ret = elem.getAttributeNode( name );
    			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
    				ret.nodeValue :
    				undefined;
    		},
    		set: function( elem, value, name ) {
    			// Set the existing or create a new attribute node
    			var ret = elem.getAttributeNode( name );
    			if ( !ret ) {
    				ret = document.createAttribute( name );
    				elem.setAttributeNode( ret );
    			}
    			return ( ret.nodeValue = value + "" );
    		}
    	};
    
    	// Apply the nodeHook to tabindex
    	jQuery.attrHooks.tabindex.set = nodeHook.set;
    
    	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
    	// This is for removals
    	jQuery.each([ "width", "height" ], function( i, name ) {
    		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
    			set: function( elem, value ) {
    				if ( value === "" ) {
    					elem.setAttribute( name, "auto" );
    					return value;
    				}
    			}
    		});
    	});
    
    	// Set contenteditable to false on removals(#10429)
    	// Setting to empty string throws an error as an invalid value
    	jQuery.attrHooks.contenteditable = {
    		get: nodeHook.get,
    		set: function( elem, value, name ) {
    			if ( value === "" ) {
    				value = "false";
    			}
    			nodeHook.set( elem, value, name );
    		}
    	};
    }
    
    
    // Some attributes require a special call on IE
    if ( !jQuery.support.hrefNormalized ) {
    	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
    		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
    			get: function( elem ) {
    				var ret = elem.getAttribute( name, 2 );
    				return ret === null ? undefined : ret;
    			}
    		});
    	});
    }
    
    if ( !jQuery.support.style ) {
    	jQuery.attrHooks.style = {
    		get: function( elem ) {
    			// Return undefined in the case of empty string
    			// Normalize to lowercase since IE uppercases css property names
    			return elem.style.cssText.toLowerCase() || undefined;
    		},
    		set: function( elem, value ) {
    			return ( elem.style.cssText = "" + value );
    		}
    	};
    }
    
    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if ( !jQuery.support.optSelected ) {
    	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
    		get: function( elem ) {
    			var parent = elem.parentNode;
    
    			if ( parent ) {
    				parent.selectedIndex;
    
    				// Make sure that it also works with optgroups, see #5701
    				if ( parent.parentNode ) {
    					parent.parentNode.selectedIndex;
    				}
    			}
    			return null;
    		}
    	});
    }
    
    // IE6/7 call enctype encoding
    if ( !jQuery.support.enctype ) {
    	jQuery.propFix.enctype = "encoding";
    }
    
    // Radios and checkboxes getter/setter
    if ( !jQuery.support.checkOn ) {
    	jQuery.each([ "radio", "checkbox" ], function() {
    		jQuery.valHooks[ this ] = {
    			get: function( elem ) {
    				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
    				return elem.getAttribute("value") === null ? "on" : elem.value;
    			}
    		};
    	});
    }
    jQuery.each([ "radio", "checkbox" ], function() {
    	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
    		set: function( elem, value ) {
    			if ( jQuery.isArray( value ) ) {
    				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
    			}
    		}
    	});
    });
    
    
    
    
    var rformElems = /^(?:textarea|input|select)$/i,
    	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
    	rhoverHack = /\bhover(\.\S+)?\b/,
    	rkeyEvent = /^key/,
    	rmouseEvent = /^(?:mouse|contextmenu)|click/,
    	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
    	quickParse = function( selector ) {
    		var quick = rquickIs.exec( selector );
    		if ( quick ) {
    			//   0  1    2   3
    			// [ _, tag, id, class ]
    			quick[1] = ( quick[1] || "" ).toLowerCase();
    			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
    		}
    		return quick;
    	},
    	quickIs = function( elem, m ) {
    		var attrs = elem.attributes || {};
    		return (
    			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
    			(!m[2] || (attrs.id || {}).value === m[2]) &&
    			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
    		);
    	},
    	hoverHack = function( events ) {
    		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
    	};
    
    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {
    
    	add: function( elem, types, handler, data, selector ) {
    
    		var elemData, eventHandle, events,
    			t, tns, type, namespaces, handleObj,
    			handleObjIn, quick, handlers, special;
    
    		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
    		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
    			return;
    		}
    
    		// Caller can pass in an object of custom data in lieu of the handler
    		if ( handler.handler ) {
    			handleObjIn = handler;
    			handler = handleObjIn.handler;
    		}
    
    		// Make sure that the handler has a unique ID, used to find/remove it later
    		if ( !handler.guid ) {
    			handler.guid = jQuery.guid++;
    		}
    
    		// Init the element's event structure and main handler, if this is the first
    		events = elemData.events;
    		if ( !events ) {
    			elemData.events = events = {};
    		}
    		eventHandle = elemData.handle;
    		if ( !eventHandle ) {
    			elemData.handle = eventHandle = function( e ) {
    				// Discard the second event of a jQuery.event.trigger() and
    				// when an event is called after a page has unloaded
    				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
    					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
    					undefined;
    			};
    			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
    			eventHandle.elem = elem;
    		}
    
    		// Handle multiple events separated by a space
    		// jQuery(...).bind("mouseover mouseout", fn);
    		types = jQuery.trim( hoverHack(types) ).split( " " );
    		for ( t = 0; t < types.length; t++ ) {
    
    			tns = rtypenamespace.exec( types[t] ) || [];
    			type = tns[1];
    			namespaces = ( tns[2] || "" ).split( "." ).sort();
    
    			// If event changes its type, use the special event handlers for the changed type
    			special = jQuery.event.special[ type ] || {};
    
    			// If selector defined, determine special event api type, otherwise given type
    			type = ( selector ? special.delegateType : special.bindType ) || type;
    
    			// Update special based on newly reset type
    			special = jQuery.event.special[ type ] || {};
    
    			// handleObj is passed to all event handlers
    			handleObj = jQuery.extend({
    				type: type,
    				origType: tns[1],
    				data: data,
    				handler: handler,
    				guid: handler.guid,
    				selector: selector,
    				quick: quickParse( selector ),
    				namespace: namespaces.join(".")
    			}, handleObjIn );
    
    			// Init the event handler queue if we're the first
    			handlers = events[ type ];
    			if ( !handlers ) {
    				handlers = events[ type ] = [];
    				handlers.delegateCount = 0;
    
    				// Only use addEventListener/attachEvent if the special events handler returns false
    				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
    					// Bind the global event handler to the element
    					if ( elem.addEventListener ) {
    						elem.addEventListener( type, eventHandle, false );
    
    					} else if ( elem.attachEvent ) {
    						elem.attachEvent( "on" + type, eventHandle );
    					}
    				}
    			}
    
    			if ( special.add ) {
    				special.add.call( elem, handleObj );
    
    				if ( !handleObj.handler.guid ) {
    					handleObj.handler.guid = handler.guid;
    				}
    			}
    
    			// Add to the element's handler list, delegates in front
    			if ( selector ) {
    				handlers.splice( handlers.delegateCount++, 0, handleObj );
    			} else {
    				handlers.push( handleObj );
    			}
    
    			// Keep track of which events have ever been used, for event optimization
    			jQuery.event.global[ type ] = true;
    		}
    
    		// Nullify elem to prevent memory leaks in IE
    		elem = null;
    	},
    
    	global: {},
    
    	// Detach an event or set of events from an element
    	remove: function( elem, types, handler, selector, mappedTypes ) {
    
    		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
    			t, tns, type, origType, namespaces, origCount,
    			j, events, special, handle, eventType, handleObj;
    
    		if ( !elemData || !(events = elemData.events) ) {
    			return;
    		}
    
    		// Once for each type.namespace in types; type may be omitted
    		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
    		for ( t = 0; t < types.length; t++ ) {
    			tns = rtypenamespace.exec( types[t] ) || [];
    			type = origType = tns[1];
    			namespaces = tns[2];
    
    			// Unbind all events (on this namespace, if provided) for the element
    			if ( !type ) {
    				for ( type in events ) {
    					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
    				}
    				continue;
    			}
    
    			special = jQuery.event.special[ type ] || {};
    			type = ( selector? special.delegateType : special.bindType ) || type;
    			eventType = events[ type ] || [];
    			origCount = eventType.length;
    			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
    
    			// Remove matching events
    			for ( j = 0; j < eventType.length; j++ ) {
    				handleObj = eventType[ j ];
    
    				if ( ( mappedTypes || origType === handleObj.origType ) &&
    					 ( !handler || handler.guid === handleObj.guid ) &&
    					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
    					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
    					eventType.splice( j--, 1 );
    
    					if ( handleObj.selector ) {
    						eventType.delegateCount--;
    					}
    					if ( special.remove ) {
    						special.remove.call( elem, handleObj );
    					}
    				}
    			}
    
    			// Remove generic event handler if we removed something and no more handlers exist
    			// (avoids potential for endless recursion during removal of special event handlers)
    			if ( eventType.length === 0 && origCount !== eventType.length ) {
    				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
    					jQuery.removeEvent( elem, type, elemData.handle );
    				}
    
    				delete events[ type ];
    			}
    		}
    
    		// Remove the expando if it's no longer used
    		if ( jQuery.isEmptyObject( events ) ) {
    			handle = elemData.handle;
    			if ( handle ) {
    				handle.elem = null;
    			}
    
    			// removeData also checks for emptiness and clears the expando if empty
    			// so use it instead of delete
    			jQuery.removeData( elem, [ "events", "handle" ], true );
    		}
    	},
    
    	// Events that are safe to short-circuit if no handlers are attached.
    	// Native DOM events should not be added, they may have inline handlers.
    	customEvent: {
    		"getData": true,
    		"setData": true,
    		"changeData": true
    	},
    
    	trigger: function( event, data, elem, onlyHandlers ) {
    		// Don't do events on text and comment nodes
    		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
    			return;
    		}
    
    		// Event object or event type
    		var type = event.type || event,
    			namespaces = [],
    			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;
    
    		// focus/blur morphs to focusin/out; ensure we're not firing them right now
    		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    			return;
    		}
    
    		if ( type.indexOf( "!" ) >= 0 ) {
    			// Exclusive events trigger only for the exact event (no namespaces)
    			type = type.slice(0, -1);
    			exclusive = true;
    		}
    
    		if ( type.indexOf( "." ) >= 0 ) {
    			// Namespaced trigger; create a regexp to match event type in handle()
    			namespaces = type.split(".");
    			type = namespaces.shift();
    			namespaces.sort();
    		}
    
    		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
    			// No jQuery handlers for this event type, and it can't have inline handlers
    			return;
    		}
    
    		// Caller can pass in an Event, Object, or just an event type string
    		event = typeof event === "object" ?
    			// jQuery.Event object
    			event[ jQuery.expando ] ? event :
    			// Object literal
    			new jQuery.Event( type, event ) :
    			// Just the event type (string)
    			new jQuery.Event( type );
    
    		event.type = type;
    		event.isTrigger = true;
    		event.exclusive = exclusive;
    		event.namespace = namespaces.join( "." );
    		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
    		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";
    
    		// Handle a global trigger
    		if ( !elem ) {
    
    			// TODO: Stop taunting the data cache; remove global events and always attach to document
    			cache = jQuery.cache;
    			for ( i in cache ) {
    				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
    					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
    				}
    			}
    			return;
    		}
    
    		// Clean up the event in case it is being reused
    		event.result = undefined;
    		if ( !event.target ) {
    			event.target = elem;
    		}
    
    		// Clone any incoming data and prepend the event, creating the handler arg list
    		data = data != null ? jQuery.makeArray( data ) : [];
    		data.unshift( event );
    
    		// Allow special events to draw outside the lines
    		special = jQuery.event.special[ type ] || {};
    		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
    			return;
    		}
    
    		// Determine event propagation path in advance, per W3C events spec (#9951)
    		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    		eventPath = [[ elem, special.bindType || type ]];
    		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
    
    			bubbleType = special.delegateType || type;
    			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
    			old = null;
    			for ( ; cur; cur = cur.parentNode ) {
    				eventPath.push([ cur, bubbleType ]);
    				old = cur;
    			}
    
    			// Only add window if we got to document (e.g., not plain obj or detached DOM)
    			if ( old && old === elem.ownerDocument ) {
    				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
    			}
    		}
    
    		// Fire handlers on the event path
    		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {
    
    			cur = eventPath[i][0];
    			event.type = eventPath[i][1];
    
    			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
    			if ( handle ) {
    				handle.apply( cur, data );
    			}
    			// Note that this is a bare JS function and not a jQuery handler
    			handle = ontype && cur[ ontype ];
    			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
    				event.preventDefault();
    			}
    		}
    		event.type = type;
    
    		// If nobody prevented the default action, do it now
    		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
    
    			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
    				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
    
    				// Call a native DOM method on the target with the same name name as the event.
    				// Can't use an .isFunction() check here because IE6/7 fails that test.
    				// Don't do default actions on window, that's where global variables be (#6170)
    				// IE<9 dies on focus/blur to hidden element (#1486)
    				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {
    
    					// Don't re-trigger an onFOO event when we call its FOO() method
    					old = elem[ ontype ];
    
    					if ( old ) {
    						elem[ ontype ] = null;
    					}
    
    					// Prevent re-triggering of the same event, since we already bubbled it above
    					jQuery.event.triggered = type;
    					elem[ type ]();
    					jQuery.event.triggered = undefined;
    
    					if ( old ) {
    						elem[ ontype ] = old;
    					}
    				}
    			}
    		}
    
    		return event.result;
    	},
    
    	dispatch: function( event ) {
    
    		// Make a writable jQuery.Event from the native event object
    		event = jQuery.event.fix( event || window.event );
    
    		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
    			delegateCount = handlers.delegateCount,
    			args = [].slice.call( arguments, 0 ),
    			run_all = !event.exclusive && !event.namespace,
    			handlerQueue = [],
    			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;
    
    		// Use the fix-ed jQuery.Event rather than the (read-only) native event
    		args[0] = event;
    		event.delegateTarget = this;
    
    		// Determine handlers that should run if there are delegated events
    		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
    		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {
    
    			// Pregenerate a single jQuery object for reuse with .is()
    			jqcur = jQuery(this);
    			jqcur.context = this.ownerDocument || this;
    
    			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
    				selMatch = {};
    				matches = [];
    				jqcur[0] = cur;
    				for ( i = 0; i < delegateCount; i++ ) {
    					handleObj = handlers[ i ];
    					sel = handleObj.selector;
    
    					if ( selMatch[ sel ] === undefined ) {
    						selMatch[ sel ] = (
    							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
    						);
    					}
    					if ( selMatch[ sel ] ) {
    						matches.push( handleObj );
    					}
    				}
    				if ( matches.length ) {
    					handlerQueue.push({ elem: cur, matches: matches });
    				}
    			}
    		}
    
    		// Add the remaining (directly-bound) handlers
    		if ( handlers.length > delegateCount ) {
    			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
    		}
    
    		// Run delegates first; they may want to stop propagation beneath us
    		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
    			matched = handlerQueue[ i ];
    			event.currentTarget = matched.elem;
    
    			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
    				handleObj = matched.matches[ j ];
    
    				// Triggered event must either 1) be non-exclusive and have no namespace, or
    				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
    				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {
    
    					event.data = handleObj.data;
    					event.handleObj = handleObj;
    
    					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
    							.apply( matched.elem, args );
    
    					if ( ret !== undefined ) {
    						event.result = ret;
    						if ( ret === false ) {
    							event.preventDefault();
    							event.stopPropagation();
    						}
    					}
    				}
    			}
    		}
    
    		return event.result;
    	},
    
    	// Includes some event props shared by KeyEvent and MouseEvent
    	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
    	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    
    	fixHooks: {},
    
    	keyHooks: {
    		props: "char charCode key keyCode".split(" "),
    		filter: function( event, original ) {
    
    			// Add which for key events
    			if ( event.which == null ) {
    				event.which = original.charCode != null ? original.charCode : original.keyCode;
    			}
    
    			return event;
    		}
    	},
    
    	mouseHooks: {
    		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    		filter: function( event, original ) {
    			var eventDoc, doc, body,
    				button = original.button,
    				fromElement = original.fromElement;
    
    			// Calculate pageX/Y if missing and clientX/Y available
    			if ( event.pageX == null && original.clientX != null ) {
    				eventDoc = event.target.ownerDocument || document;
    				doc = eventDoc.documentElement;
    				body = eventDoc.body;
    
    				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
    				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
    			}
    
    			// Add relatedTarget, if necessary
    			if ( !event.relatedTarget && fromElement ) {
    				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
    			}
    
    			// Add which for click: 1 === left; 2 === middle; 3 === right
    			// Note: button is not normalized, so don't use it
    			if ( !event.which && button !== undefined ) {
    				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
    			}
    
    			return event;
    		}
    	},
    
    	fix: function( event ) {
    		if ( event[ jQuery.expando ] ) {
    			return event;
    		}
    
    		// Create a writable copy of the event object and normalize some properties
    		var i, prop,
    			originalEvent = event,
    			fixHook = jQuery.event.fixHooks[ event.type ] || {},
    			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
    
    		event = jQuery.Event( originalEvent );
    
    		for ( i = copy.length; i; ) {
    			prop = copy[ --i ];
    			event[ prop ] = originalEvent[ prop ];
    		}
    
    		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
    		if ( !event.target ) {
    			event.target = originalEvent.srcElement || document;
    		}
    
    		// Target should not be a text node (#504, Safari)
    		if ( event.target.nodeType === 3 ) {
    			event.target = event.target.parentNode;
    		}
    
    		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
    		if ( event.metaKey === undefined ) {
    			event.metaKey = event.ctrlKey;
    		}
    
    		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
    	},
    
    	special: {
    		ready: {
    			// Make sure the ready event is setup
    			setup: jQuery.bindReady
    		},
    
    		load: {
    			// Prevent triggered image.load events from bubbling to window.load
    			noBubble: true
    		},
    
    		focus: {
    			delegateType: "focusin"
    		},
    		blur: {
    			delegateType: "focusout"
    		},
    
    		beforeunload: {
    			setup: function( data, namespaces, eventHandle ) {
    				// We only want to do this special case on windows
    				if ( jQuery.isWindow( this ) ) {
    					this.onbeforeunload = eventHandle;
    				}
    			},
    
    			teardown: function( namespaces, eventHandle ) {
    				if ( this.onbeforeunload === eventHandle ) {
    					this.onbeforeunload = null;
    				}
    			}
    		}
    	},
    
    	simulate: function( type, elem, event, bubble ) {
    		// Piggyback on a donor event to simulate a different one.
    		// Fake originalEvent to avoid donor's stopPropagation, but if the
    		// simulated event prevents default then we do the same on the donor.
    		var e = jQuery.extend(
    			new jQuery.Event(),
    			event,
    			{ type: type,
    				isSimulated: true,
    				originalEvent: {}
    			}
    		);
    		if ( bubble ) {
    			jQuery.event.trigger( e, null, elem );
    		} else {
    			jQuery.event.dispatch.call( elem, e );
    		}
    		if ( e.isDefaultPrevented() ) {
    			event.preventDefault();
    		}
    	}
    };
    
    // Some plugins are using, but it's undocumented/deprecated and will be removed.
    // The 1.7 special event interface should provide all the hooks needed now.
    jQuery.event.handle = jQuery.event.dispatch;
    
    jQuery.removeEvent = document.removeEventListener ?
    	function( elem, type, handle ) {
    		if ( elem.removeEventListener ) {
    			elem.removeEventListener( type, handle, false );
    		}
    	} :
    	function( elem, type, handle ) {
    		if ( elem.detachEvent ) {
    			elem.detachEvent( "on" + type, handle );
    		}
    	};
    
    jQuery.Event = function( src, props ) {
    	// Allow instantiation without the 'new' keyword
    	if ( !(this instanceof jQuery.Event) ) {
    		return new jQuery.Event( src, props );
    	}
    
    	// Event object
    	if ( src && src.type ) {
    		this.originalEvent = src;
    		this.type = src.type;
    
    		// Events bubbling up the document may have been marked as prevented
    		// by a handler lower down the tree; reflect the correct value.
    		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
    			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
    
    	// Event type
    	} else {
    		this.type = src;
    	}
    
    	// Put explicitly provided properties onto the event object
    	if ( props ) {
    		jQuery.extend( this, props );
    	}
    
    	// Create a timestamp if incoming event doesn't have one
    	this.timeStamp = src && src.timeStamp || jQuery.now();
    
    	// Mark it as fixed
    	this[ jQuery.expando ] = true;
    };
    
    function returnFalse() {
    	return false;
    }
    function returnTrue() {
    	return true;
    }
    
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
    	preventDefault: function() {
    		this.isDefaultPrevented = returnTrue;
    
    		var e = this.originalEvent;
    		if ( !e ) {
    			return;
    		}
    
    		// if preventDefault exists run it on the original event
    		if ( e.preventDefault ) {
    			e.preventDefault();
    
    		// otherwise set the returnValue property of the original event to false (IE)
    		} else {
    			e.returnValue = false;
    		}
    	},
    	stopPropagation: function() {
    		this.isPropagationStopped = returnTrue;
    
    		var e = this.originalEvent;
    		if ( !e ) {
    			return;
    		}
    		// if stopPropagation exists run it on the original event
    		if ( e.stopPropagation ) {
    			e.stopPropagation();
    		}
    		// otherwise set the cancelBubble property of the original event to true (IE)
    		e.cancelBubble = true;
    	},
    	stopImmediatePropagation: function() {
    		this.isImmediatePropagationStopped = returnTrue;
    		this.stopPropagation();
    	},
    	isDefaultPrevented: returnFalse,
    	isPropagationStopped: returnFalse,
    	isImmediatePropagationStopped: returnFalse
    };
    
    // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
    	mouseenter: "mouseover",
    	mouseleave: "mouseout"
    }, function( orig, fix ) {
    	jQuery.event.special[ orig ] = {
    		delegateType: fix,
    		bindType: fix,
    
    		handle: function( event ) {
    			var target = this,
    				related = event.relatedTarget,
    				handleObj = event.handleObj,
    				selector = handleObj.selector,
    				ret;
    
    			// For mousenter/leave call the handler if related is outside the target.
    			// NB: No relatedTarget if the mouse left/entered the browser window
    			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
    				event.type = handleObj.origType;
    				ret = handleObj.handler.apply( this, arguments );
    				event.type = fix;
    			}
    			return ret;
    		}
    	};
    });
    
    // IE submit delegation
    if ( !jQuery.support.submitBubbles ) {
    
    	jQuery.event.special.submit = {
    		setup: function() {
    			// Only need this for delegated form submit events
    			if ( jQuery.nodeName( this, "form" ) ) {
    				return false;
    			}
    
    			// Lazy-add a submit handler when a descendant form may potentially be submitted
    			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
    				// Node name check avoids a VML-related crash in IE (#9807)
    				var elem = e.target,
    					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
    				if ( form && !form._submit_attached ) {
    					jQuery.event.add( form, "submit._submit", function( event ) {
    						// If form was submitted by the user, bubble the event up the tree
    						if ( this.parentNode && !event.isTrigger ) {
    							jQuery.event.simulate( "submit", this.parentNode, event, true );
    						}
    					});
    					form._submit_attached = true;
    				}
    			});
    			// return undefined since we don't need an event listener
    		},
    
    		teardown: function() {
    			// Only need this for delegated form submit events
    			if ( jQuery.nodeName( this, "form" ) ) {
    				return false;
    			}
    
    			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
    			jQuery.event.remove( this, "._submit" );
    		}
    	};
    }
    
    // IE change delegation and checkbox/radio fix
    if ( !jQuery.support.changeBubbles ) {
    
    	jQuery.event.special.change = {
    
    		setup: function() {
    
    			if ( rformElems.test( this.nodeName ) ) {
    				// IE doesn't fire change on a check/radio until blur; trigger it on click
    				// after a propertychange. Eat the blur-change in special.change.handle.
    				// This still fires onchange a second time for check/radio after blur.
    				if ( this.type === "checkbox" || this.type === "radio" ) {
    					jQuery.event.add( this, "propertychange._change", function( event ) {
    						if ( event.originalEvent.propertyName === "checked" ) {
    							this._just_changed = true;
    						}
    					});
    					jQuery.event.add( this, "click._change", function( event ) {
    						if ( this._just_changed && !event.isTrigger ) {
    							this._just_changed = false;
    							jQuery.event.simulate( "change", this, event, true );
    						}
    					});
    				}
    				return false;
    			}
    			// Delegated event; lazy-add a change handler on descendant inputs
    			jQuery.event.add( this, "beforeactivate._change", function( e ) {
    				var elem = e.target;
    
    				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
    					jQuery.event.add( elem, "change._change", function( event ) {
    						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
    							jQuery.event.simulate( "change", this.parentNode, event, true );
    						}
    					});
    					elem._change_attached = true;
    				}
    			});
    		},
    
    		handle: function( event ) {
    			var elem = event.target;
    
    			// Swallow native change events from checkbox/radio, we already triggered them above
    			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
    				return event.handleObj.handler.apply( this, arguments );
    			}
    		},
    
    		teardown: function() {
    			jQuery.event.remove( this, "._change" );
    
    			return rformElems.test( this.nodeName );
    		}
    	};
    }
    
    // Create "bubbling" focus and blur events
    if ( !jQuery.support.focusinBubbles ) {
    	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
    
    		// Attach a single capturing handler while someone wants focusin/focusout
    		var attaches = 0,
    			handler = function( event ) {
    				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
    			};
    
    		jQuery.event.special[ fix ] = {
    			setup: function() {
    				if ( attaches++ === 0 ) {
    					document.addEventListener( orig, handler, true );
    				}
    			},
    			teardown: function() {
    				if ( --attaches === 0 ) {
    					document.removeEventListener( orig, handler, true );
    				}
    			}
    		};
    	});
    }
    
    jQuery.fn.extend({
    
    	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
    		var origFn, type;
    
    		// Types can be a map of types/handlers
    		if ( typeof types === "object" ) {
    			// ( types-Object, selector, data )
    			if ( typeof selector !== "string" ) {
    				// ( types-Object, data )
    				data = selector;
    				selector = undefined;
    			}
    			for ( type in types ) {
    				this.on( type, selector, data, types[ type ], one );
    			}
    			return this;
    		}
    
    		if ( data == null && fn == null ) {
    			// ( types, fn )
    			fn = selector;
    			data = selector = undefined;
    		} else if ( fn == null ) {
    			if ( typeof selector === "string" ) {
    				// ( types, selector, fn )
    				fn = data;
    				data = undefined;
    			} else {
    				// ( types, data, fn )
    				fn = data;
    				data = selector;
    				selector = undefined;
    			}
    		}
    		if ( fn === false ) {
    			fn = returnFalse;
    		} else if ( !fn ) {
    			return this;
    		}
    
    		if ( one === 1 ) {
    			origFn = fn;
    			fn = function( event ) {
    				// Can use an empty set, since event contains the info
    				jQuery().off( event );
    				return origFn.apply( this, arguments );
    			};
    			// Use same guid so caller can remove using origFn
    			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    		}
    		return this.each( function() {
    			jQuery.event.add( this, types, fn, data, selector );
    		});
    	},
    	one: function( types, selector, data, fn ) {
    		return this.on.call( this, types, selector, data, fn, 1 );
    	},
    	off: function( types, selector, fn ) {
    		if ( types && types.preventDefault && types.handleObj ) {
    			// ( event )  dispatched jQuery.Event
    			var handleObj = types.handleObj;
    			jQuery( types.delegateTarget ).off(
    				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
    				handleObj.selector,
    				handleObj.handler
    			);
    			return this;
    		}
    		if ( typeof types === "object" ) {
    			// ( types-object [, selector] )
    			for ( var type in types ) {
    				this.off( type, selector, types[ type ] );
    			}
    			return this;
    		}
    		if ( selector === false || typeof selector === "function" ) {
    			// ( types [, fn] )
    			fn = selector;
    			selector = undefined;
    		}
    		if ( fn === false ) {
    			fn = returnFalse;
    		}
    		return this.each(function() {
    			jQuery.event.remove( this, types, fn, selector );
    		});
    	},
    
    	bind: function( types, data, fn ) {
    		return this.on( types, null, data, fn );
    	},
    	unbind: function( types, fn ) {
    		return this.off( types, null, fn );
    	},
    
    	live: function( types, data, fn ) {
    		jQuery( this.context ).on( types, this.selector, data, fn );
    		return this;
    	},
    	die: function( types, fn ) {
    		jQuery( this.context ).off( types, this.selector || "**", fn );
    		return this;
    	},
    
    	delegate: function( selector, types, data, fn ) {
    		return this.on( types, selector, data, fn );
    	},
    	undelegate: function( selector, types, fn ) {
    		// ( namespace ) or ( selector, types [, fn] )
    		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
    	},
    
    	trigger: function( type, data ) {
    		return this.each(function() {
    			jQuery.event.trigger( type, data, this );
    		});
    	},
    	triggerHandler: function( type, data ) {
    		if ( this[0] ) {
    			return jQuery.event.trigger( type, data, this[0], true );
    		}
    	},
    
    	toggle: function( fn ) {
    		// Save reference to arguments for access in closure
    		var args = arguments,
    			guid = fn.guid || jQuery.guid++,
    			i = 0,
    			toggler = function( event ) {
    				// Figure out which function to execute
    				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
    				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
    
    				// Make sure that clicks stop
    				event.preventDefault();
    
    				// and execute the function
    				return args[ lastToggle ].apply( this, arguments ) || false;
    			};
    
    		// link all the functions, so any of them can unbind this click handler
    		toggler.guid = guid;
    		while ( i < args.length ) {
    			args[ i++ ].guid = guid;
    		}
    
    		return this.click( toggler );
    	},
    
    	hover: function( fnOver, fnOut ) {
    		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    	}
    });
    
    jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
    	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
    
    	// Handle event binding
    	jQuery.fn[ name ] = function( data, fn ) {
    		if ( fn == null ) {
    			fn = data;
    			data = null;
    		}
    
    		return arguments.length > 0 ?
    			this.on( name, null, data, fn ) :
    			this.trigger( name );
    	};
    
    	if ( jQuery.attrFn ) {
    		jQuery.attrFn[ name ] = true;
    	}
    
    	if ( rkeyEvent.test( name ) ) {
    		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
    	}
    
    	if ( rmouseEvent.test( name ) ) {
    		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
    	}
    });
    
    
    
    /*!
     * Sizzle CSS Selector Engine
     *  Copyright 2011, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
    (function(){
    
    var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
    	expando = "sizcache" + (Math.random() + '').replace('.', ''),
    	done = 0,
    	toString = Object.prototype.toString,
    	hasDuplicate = false,
    	baseHasDuplicate = true,
    	rBackslash = /\\/g,
    	rReturn = /\r\n/g,
    	rNonWord = /\W/;
    
    // Here we check if the JavaScript engine is using some sort of
    // optimization where it does not always call our comparision
    // function. If that is the case, discard the hasDuplicate value.
    //   Thus far that includes Google Chrome.
    [0, 0].sort(function() {
    	baseHasDuplicate = false;
    	return 0;
    });
    
    var Sizzle = function( selector, context, results, seed ) {
    	results = results || [];
    	context = context || document;
    
    	var origContext = context;
    
    	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
    		return [];
    	}
    	
    	if ( !selector || typeof selector !== "string" ) {
    		return results;
    	}
    
    	var m, set, checkSet, extra, ret, cur, pop, i,
    		prune = true,
    		contextXML = Sizzle.isXML( context ),
    		parts = [],
    		soFar = selector;
    	
    	// Reset the position of the chunker regexp (start from head)
    	do {
    		chunker.exec( "" );
    		m = chunker.exec( soFar );
    
    		if ( m ) {
    			soFar = m[3];
    		
    			parts.push( m[1] );
    		
    			if ( m[2] ) {
    				extra = m[3];
    				break;
    			}
    		}
    	} while ( m );
    
    	if ( parts.length > 1 && origPOS.exec( selector ) ) {
    
    		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
    			set = posProcess( parts[0] + parts[1], context, seed );
    
    		} else {
    			set = Expr.relative[ parts[0] ] ?
    				[ context ] :
    				Sizzle( parts.shift(), context );
    
    			while ( parts.length ) {
    				selector = parts.shift();
    
    				if ( Expr.relative[ selector ] ) {
    					selector += parts.shift();
    				}
    				
    				set = posProcess( selector, set, seed );
    			}
    		}
    
    	} else {
    		// Take a shortcut and set the context if the root selector is an ID
    		// (but not if it'll be faster if the inner selector is an ID)
    		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
    				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
    
    			ret = Sizzle.find( parts.shift(), context, contextXML );
    			context = ret.expr ?
    				Sizzle.filter( ret.expr, ret.set )[0] :
    				ret.set[0];
    		}
    
    		if ( context ) {
    			ret = seed ?
    				{ expr: parts.pop(), set: makeArray(seed) } :
    				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
    
    			set = ret.expr ?
    				Sizzle.filter( ret.expr, ret.set ) :
    				ret.set;
    
    			if ( parts.length > 0 ) {
    				checkSet = makeArray( set );
    
    			} else {
    				prune = false;
    			}
    
    			while ( parts.length ) {
    				cur = parts.pop();
    				pop = cur;
    
    				if ( !Expr.relative[ cur ] ) {
    					cur = "";
    				} else {
    					pop = parts.pop();
    				}
    
    				if ( pop == null ) {
    					pop = context;
    				}
    
    				Expr.relative[ cur ]( checkSet, pop, contextXML );
    			}
    
    		} else {
    			checkSet = parts = [];
    		}
    	}
    
    	if ( !checkSet ) {
    		checkSet = set;
    	}
    
    	if ( !checkSet ) {
    		Sizzle.error( cur || selector );
    	}
    
    	if ( toString.call(checkSet) === "[object Array]" ) {
    		if ( !prune ) {
    			results.push.apply( results, checkSet );
    
    		} else if ( context && context.nodeType === 1 ) {
    			for ( i = 0; checkSet[i] != null; i++ ) {
    				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
    					results.push( set[i] );
    				}
    			}
    
    		} else {
    			for ( i = 0; checkSet[i] != null; i++ ) {
    				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
    					results.push( set[i] );
    				}
    			}
    		}
    
    	} else {
    		makeArray( checkSet, results );
    	}
    
    	if ( extra ) {
    		Sizzle( extra, origContext, results, seed );
    		Sizzle.uniqueSort( results );
    	}
    
    	return results;
    };
    
    Sizzle.uniqueSort = function( results ) {
    	if ( sortOrder ) {
    		hasDuplicate = baseHasDuplicate;
    		results.sort( sortOrder );
    
    		if ( hasDuplicate ) {
    			for ( var i = 1; i < results.length; i++ ) {
    				if ( results[i] === results[ i - 1 ] ) {
    					results.splice( i--, 1 );
    				}
    			}
    		}
    	}
    
    	return results;
    };
    
    Sizzle.matches = function( expr, set ) {
    	return Sizzle( expr, null, null, set );
    };
    
    Sizzle.matchesSelector = function( node, expr ) {
    	return Sizzle( expr, null, null, [node] ).length > 0;
    };
    
    Sizzle.find = function( expr, context, isXML ) {
    	var set, i, len, match, type, left;
    
    	if ( !expr ) {
    		return [];
    	}
    
    	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
    		type = Expr.order[i];
    		
    		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
    			left = match[1];
    			match.splice( 1, 1 );
    
    			if ( left.substr( left.length - 1 ) !== "\\" ) {
    				match[1] = (match[1] || "").replace( rBackslash, "" );
    				set = Expr.find[ type ]( match, context, isXML );
    
    				if ( set != null ) {
    					expr = expr.replace( Expr.match[ type ], "" );
    					break;
    				}
    			}
    		}
    	}
    
    	if ( !set ) {
    		set = typeof context.getElementsByTagName !== "undefined" ?
    			context.getElementsByTagName( "*" ) :
    			[];
    	}
    
    	return { set: set, expr: expr };
    };
    
    Sizzle.filter = function( expr, set, inplace, not ) {
    	var match, anyFound,
    		type, found, item, filter, left,
    		i, pass,
    		old = expr,
    		result = [],
    		curLoop = set,
    		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );
    
    	while ( expr && set.length ) {
    		for ( type in Expr.filter ) {
    			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
    				filter = Expr.filter[ type ];
    				left = match[1];
    
    				anyFound = false;
    
    				match.splice(1,1);
    
    				if ( left.substr( left.length - 1 ) === "\\" ) {
    					continue;
    				}
    
    				if ( curLoop === result ) {
    					result = [];
    				}
    
    				if ( Expr.preFilter[ type ] ) {
    					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
    
    					if ( !match ) {
    						anyFound = found = true;
    
    					} else if ( match === true ) {
    						continue;
    					}
    				}
    
    				if ( match ) {
    					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
    						if ( item ) {
    							found = filter( item, match, i, curLoop );
    							pass = not ^ found;
    
    							if ( inplace && found != null ) {
    								if ( pass ) {
    									anyFound = true;
    
    								} else {
    									curLoop[i] = false;
    								}
    
    							} else if ( pass ) {
    								result.push( item );
    								anyFound = true;
    							}
    						}
    					}
    				}
    
    				if ( found !== undefined ) {
    					if ( !inplace ) {
    						curLoop = result;
    					}
    
    					expr = expr.replace( Expr.match[ type ], "" );
    
    					if ( !anyFound ) {
    						return [];
    					}
    
    					break;
    				}
    			}
    		}
    
    		// Improper expression
    		if ( expr === old ) {
    			if ( anyFound == null ) {
    				Sizzle.error( expr );
    
    			} else {
    				break;
    			}
    		}
    
    		old = expr;
    	}
    
    	return curLoop;
    };
    
    Sizzle.error = function( msg ) {
    	throw new Error( "Syntax error, unrecognized expression: " + msg );
    };
    
    /**
     * Utility function for retreiving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    var getText = Sizzle.getText = function( elem ) {
        var i, node,
    		nodeType = elem.nodeType,
    		ret = "";
    
    	if ( nodeType ) {
    		if ( nodeType === 1 || nodeType === 9 ) {
    			// Use textContent || innerText for elements
    			if ( typeof elem.textContent === 'string' ) {
    				return elem.textContent;
    			} else if ( typeof elem.innerText === 'string' ) {
    				// Replace IE's carriage returns
    				return elem.innerText.replace( rReturn, '' );
    			} else {
    				// Traverse it's children
    				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
    					ret += getText( elem );
    				}
    			}
    		} else if ( nodeType === 3 || nodeType === 4 ) {
    			return elem.nodeValue;
    		}
    	} else {
    
    		// If no nodeType, this is expected to be an array
    		for ( i = 0; (node = elem[i]); i++ ) {
    			// Do not traverse comment nodes
    			if ( node.nodeType !== 8 ) {
    				ret += getText( node );
    			}
    		}
    	}
    	return ret;
    };
    
    var Expr = Sizzle.selectors = {
    	order: [ "ID", "NAME", "TAG" ],
    
    	match: {
    		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
    		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
    		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
    		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
    		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
    		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
    		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
    		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
    	},
    
    	leftMatch: {},
    
    	attrMap: {
    		"class": "className",
    		"for": "htmlFor"
    	},
    
    	attrHandle: {
    		href: function( elem ) {
    			return elem.getAttribute( "href" );
    		},
    		type: function( elem ) {
    			return elem.getAttribute( "type" );
    		}
    	},
    
    	relative: {
    		"+": function(checkSet, part){
    			var isPartStr = typeof part === "string",
    				isTag = isPartStr && !rNonWord.test( part ),
    				isPartStrNotTag = isPartStr && !isTag;
    
    			if ( isTag ) {
    				part = part.toLowerCase();
    			}
    
    			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
    				if ( (elem = checkSet[i]) ) {
    					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
    
    					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
    						elem || false :
    						elem === part;
    				}
    			}
    
    			if ( isPartStrNotTag ) {
    				Sizzle.filter( part, checkSet, true );
    			}
    		},
    
    		">": function( checkSet, part ) {
    			var elem,
    				isPartStr = typeof part === "string",
    				i = 0,
    				l = checkSet.length;
    
    			if ( isPartStr && !rNonWord.test( part ) ) {
    				part = part.toLowerCase();
    
    				for ( ; i < l; i++ ) {
    					elem = checkSet[i];
    
    					if ( elem ) {
    						var parent = elem.parentNode;
    						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
    					}
    				}
    
    			} else {
    				for ( ; i < l; i++ ) {
    					elem = checkSet[i];
    
    					if ( elem ) {
    						checkSet[i] = isPartStr ?
    							elem.parentNode :
    							elem.parentNode === part;
    					}
    				}
    
    				if ( isPartStr ) {
    					Sizzle.filter( part, checkSet, true );
    				}
    			}
    		},
    
    		"": function(checkSet, part, isXML){
    			var nodeCheck,
    				doneName = done++,
    				checkFn = dirCheck;
    
    			if ( typeof part === "string" && !rNonWord.test( part ) ) {
    				part = part.toLowerCase();
    				nodeCheck = part;
    				checkFn = dirNodeCheck;
    			}
    
    			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
    		},
    
    		"~": function( checkSet, part, isXML ) {
    			var nodeCheck,
    				doneName = done++,
    				checkFn = dirCheck;
    
    			if ( typeof part === "string" && !rNonWord.test( part ) ) {
    				part = part.toLowerCase();
    				nodeCheck = part;
    				checkFn = dirNodeCheck;
    			}
    
    			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
    		}
    	},
    
    	find: {
    		ID: function( match, context, isXML ) {
    			if ( typeof context.getElementById !== "undefined" && !isXML ) {
    				var m = context.getElementById(match[1]);
    				// Check parentNode to catch when Blackberry 4.6 returns
    				// nodes that are no longer in the document #6963
    				return m && m.parentNode ? [m] : [];
    			}
    		},
    
    		NAME: function( match, context ) {
    			if ( typeof context.getElementsByName !== "undefined" ) {
    				var ret = [],
    					results = context.getElementsByName( match[1] );
    
    				for ( var i = 0, l = results.length; i < l; i++ ) {
    					if ( results[i].getAttribute("name") === match[1] ) {
    						ret.push( results[i] );
    					}
    				}
    
    				return ret.length === 0 ? null : ret;
    			}
    		},
    
    		TAG: function( match, context ) {
    			if ( typeof context.getElementsByTagName !== "undefined" ) {
    				return context.getElementsByTagName( match[1] );
    			}
    		}
    	},
    	preFilter: {
    		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
    			match = " " + match[1].replace( rBackslash, "" ) + " ";
    
    			if ( isXML ) {
    				return match;
    			}
    
    			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
    				if ( elem ) {
    					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
    						if ( !inplace ) {
    							result.push( elem );
    						}
    
    					} else if ( inplace ) {
    						curLoop[i] = false;
    					}
    				}
    			}
    
    			return false;
    		},
    
    		ID: function( match ) {
    			return match[1].replace( rBackslash, "" );
    		},
    
    		TAG: function( match, curLoop ) {
    			return match[1].replace( rBackslash, "" ).toLowerCase();
    		},
    
    		CHILD: function( match ) {
    			if ( match[1] === "nth" ) {
    				if ( !match[2] ) {
    					Sizzle.error( match[0] );
    				}
    
    				match[2] = match[2].replace(/^\+|\s*/g, '');
    
    				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
    				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
    					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
    					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
    
    				// calculate the numbers (first)n+(last) including if they are negative
    				match[2] = (test[1] + (test[2] || 1)) - 0;
    				match[3] = test[3] - 0;
    			}
    			else if ( match[2] ) {
    				Sizzle.error( match[0] );
    			}
    
    			// TODO: Move to normal caching system
    			match[0] = done++;
    
    			return match;
    		},
    
    		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
    			var name = match[1] = match[1].replace( rBackslash, "" );
    			
    			if ( !isXML && Expr.attrMap[name] ) {
    				match[1] = Expr.attrMap[name];
    			}
    
    			// Handle if an un-quoted value was used
    			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );
    
    			if ( match[2] === "~=" ) {
    				match[4] = " " + match[4] + " ";
    			}
    
    			return match;
    		},
    
    		PSEUDO: function( match, curLoop, inplace, result, not ) {
    			if ( match[1] === "not" ) {
    				// If we're dealing with a complex expression, or a simple one
    				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
    					match[3] = Sizzle(match[3], null, null, curLoop);
    
    				} else {
    					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
    
    					if ( !inplace ) {
    						result.push.apply( result, ret );
    					}
    
    					return false;
    				}
    
    			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
    				return true;
    			}
    			
    			return match;
    		},
    
    		POS: function( match ) {
    			match.unshift( true );
    
    			return match;
    		}
    	},
    	
    	filters: {
    		enabled: function( elem ) {
    			return elem.disabled === false && elem.type !== "hidden";
    		},
    
    		disabled: function( elem ) {
    			return elem.disabled === true;
    		},
    
    		checked: function( elem ) {
    			return elem.checked === true;
    		},
    		
    		selected: function( elem ) {
    			// Accessing this property makes selected-by-default
    			// options in Safari work properly
    			if ( elem.parentNode ) {
    				elem.parentNode.selectedIndex;
    			}
    			
    			return elem.selected === true;
    		},
    
    		parent: function( elem ) {
    			return !!elem.firstChild;
    		},
    
    		empty: function( elem ) {
    			return !elem.firstChild;
    		},
    
    		has: function( elem, i, match ) {
    			return !!Sizzle( match[3], elem ).length;
    		},
    
    		header: function( elem ) {
    			return (/h\d/i).test( elem.nodeName );
    		},
    
    		text: function( elem ) {
    			var attr = elem.getAttribute( "type" ), type = elem.type;
    			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
    			// use getAttribute instead to test this case
    			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
    		},
    
    		radio: function( elem ) {
    			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
    		},
    
    		checkbox: function( elem ) {
    			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
    		},
    
    		file: function( elem ) {
    			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
    		},
    
    		password: function( elem ) {
    			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
    		},
    
    		submit: function( elem ) {
    			var name = elem.nodeName.toLowerCase();
    			return (name === "input" || name === "button") && "submit" === elem.type;
    		},
    
    		image: function( elem ) {
    			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
    		},
    
    		reset: function( elem ) {
    			var name = elem.nodeName.toLowerCase();
    			return (name === "input" || name === "button") && "reset" === elem.type;
    		},
    
    		button: function( elem ) {
    			var name = elem.nodeName.toLowerCase();
    			return name === "input" && "button" === elem.type || name === "button";
    		},
    
    		input: function( elem ) {
    			return (/input|select|textarea|button/i).test( elem.nodeName );
    		},
    
    		focus: function( elem ) {
    			return elem === elem.ownerDocument.activeElement;
    		}
    	},
    	setFilters: {
    		first: function( elem, i ) {
    			return i === 0;
    		},
    
    		last: function( elem, i, match, array ) {
    			return i === array.length - 1;
    		},
    
    		even: function( elem, i ) {
    			return i % 2 === 0;
    		},
    
    		odd: function( elem, i ) {
    			return i % 2 === 1;
    		},
    
    		lt: function( elem, i, match ) {
    			return i < match[3] - 0;
    		},
    
    		gt: function( elem, i, match ) {
    			return i > match[3] - 0;
    		},
    
    		nth: function( elem, i, match ) {
    			return match[3] - 0 === i;
    		},
    
    		eq: function( elem, i, match ) {
    			return match[3] - 0 === i;
    		}
    	},
    	filter: {
    		PSEUDO: function( elem, match, i, array ) {
    			var name = match[1],
    				filter = Expr.filters[ name ];
    
    			if ( filter ) {
    				return filter( elem, i, match, array );
    
    			} else if ( name === "contains" ) {
    				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;
    
    			} else if ( name === "not" ) {
    				var not = match[3];
    
    				for ( var j = 0, l = not.length; j < l; j++ ) {
    					if ( not[j] === elem ) {
    						return false;
    					}
    				}
    
    				return true;
    
    			} else {
    				Sizzle.error( name );
    			}
    		},
    
    		CHILD: function( elem, match ) {
    			var first, last,
    				doneName, parent, cache,
    				count, diff,
    				type = match[1],
    				node = elem;
    
    			switch ( type ) {
    				case "only":
    				case "first":
    					while ( (node = node.previousSibling) )	 {
    						if ( node.nodeType === 1 ) { 
    							return false; 
    						}
    					}
    
    					if ( type === "first" ) { 
    						return true; 
    					}
    
    					node = elem;
    
    				case "last":
    					while ( (node = node.nextSibling) )	 {
    						if ( node.nodeType === 1 ) { 
    							return false; 
    						}
    					}
    
    					return true;
    
    				case "nth":
    					first = match[2];
    					last = match[3];
    
    					if ( first === 1 && last === 0 ) {
    						return true;
    					}
    					
    					doneName = match[0];
    					parent = elem.parentNode;
    	
    					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
    						count = 0;
    						
    						for ( node = parent.firstChild; node; node = node.nextSibling ) {
    							if ( node.nodeType === 1 ) {
    								node.nodeIndex = ++count;
    							}
    						} 
    
    						parent[ expando ] = doneName;
    					}
    					
    					diff = elem.nodeIndex - last;
    
    					if ( first === 0 ) {
    						return diff === 0;
    
    					} else {
    						return ( diff % first === 0 && diff / first >= 0 );
    					}
    			}
    		},
    
    		ID: function( elem, match ) {
    			return elem.nodeType === 1 && elem.getAttribute("id") === match;
    		},
    
    		TAG: function( elem, match ) {
    			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
    		},
    		
    		CLASS: function( elem, match ) {
    			return (" " + (elem.className || elem.getAttribute("class")) + " ")
    				.indexOf( match ) > -1;
    		},
    
    		ATTR: function( elem, match ) {
    			var name = match[1],
    				result = Sizzle.attr ?
    					Sizzle.attr( elem, name ) :
    					Expr.attrHandle[ name ] ?
    					Expr.attrHandle[ name ]( elem ) :
    					elem[ name ] != null ?
    						elem[ name ] :
    						elem.getAttribute( name ),
    				value = result + "",
    				type = match[2],
    				check = match[4];
    
    			return result == null ?
    				type === "!=" :
    				!type && Sizzle.attr ?
    				result != null :
    				type === "=" ?
    				value === check :
    				type === "*=" ?
    				value.indexOf(check) >= 0 :
    				type === "~=" ?
    				(" " + value + " ").indexOf(check) >= 0 :
    				!check ?
    				value && result !== false :
    				type === "!=" ?
    				value !== check :
    				type === "^=" ?
    				value.indexOf(check) === 0 :
    				type === "$=" ?
    				value.substr(value.length - check.length) === check :
    				type === "|=" ?
    				value === check || value.substr(0, check.length + 1) === check + "-" :
    				false;
    		},
    
    		POS: function( elem, match, i, array ) {
    			var name = match[2],
    				filter = Expr.setFilters[ name ];
    
    			if ( filter ) {
    				return filter( elem, i, match, array );
    			}
    		}
    	}
    };
    
    var origPOS = Expr.match.POS,
    	fescape = function(all, num){
    		return "\\" + (num - 0 + 1);
    	};
    
    for ( var type in Expr.match ) {
    	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
    	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
    }
    
    var makeArray = function( array, results ) {
    	array = Array.prototype.slice.call( array, 0 );
    
    	if ( results ) {
    		results.push.apply( results, array );
    		return results;
    	}
    	
    	return array;
    };
    
    // Perform a simple check to determine if the browser is capable of
    // converting a NodeList to an array using builtin methods.
    // Also verifies that the returned array holds DOM nodes
    // (which is not the case in the Blackberry browser)
    try {
    	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
    
    // Provide a fallback method if it does not work
    } catch( e ) {
    	makeArray = function( array, results ) {
    		var i = 0,
    			ret = results || [];
    
    		if ( toString.call(array) === "[object Array]" ) {
    			Array.prototype.push.apply( ret, array );
    
    		} else {
    			if ( typeof array.length === "number" ) {
    				for ( var l = array.length; i < l; i++ ) {
    					ret.push( array[i] );
    				}
    
    			} else {
    				for ( ; array[i]; i++ ) {
    					ret.push( array[i] );
    				}
    			}
    		}
    
    		return ret;
    	};
    }
    
    var sortOrder, siblingCheck;
    
    if ( document.documentElement.compareDocumentPosition ) {
    	sortOrder = function( a, b ) {
    		if ( a === b ) {
    			hasDuplicate = true;
    			return 0;
    		}
    
    		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
    			return a.compareDocumentPosition ? -1 : 1;
    		}
    
    		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
    	};
    
    } else {
    	sortOrder = function( a, b ) {
    		// The nodes are identical, we can exit early
    		if ( a === b ) {
    			hasDuplicate = true;
    			return 0;
    
    		// Fallback to using sourceIndex (in IE) if it's available on both nodes
    		} else if ( a.sourceIndex && b.sourceIndex ) {
    			return a.sourceIndex - b.sourceIndex;
    		}
    
    		var al, bl,
    			ap = [],
    			bp = [],
    			aup = a.parentNode,
    			bup = b.parentNode,
    			cur = aup;
    
    		// If the nodes are siblings (or identical) we can do a quick check
    		if ( aup === bup ) {
    			return siblingCheck( a, b );
    
    		// If no parents were found then the nodes are disconnected
    		} else if ( !aup ) {
    			return -1;
    
    		} else if ( !bup ) {
    			return 1;
    		}
    
    		// Otherwise they're somewhere else in the tree so we need
    		// to build up a full list of the parentNodes for comparison
    		while ( cur ) {
    			ap.unshift( cur );
    			cur = cur.parentNode;
    		}
    
    		cur = bup;
    
    		while ( cur ) {
    			bp.unshift( cur );
    			cur = cur.parentNode;
    		}
    
    		al = ap.length;
    		bl = bp.length;
    
    		// Start walking down the tree looking for a discrepancy
    		for ( var i = 0; i < al && i < bl; i++ ) {
    			if ( ap[i] !== bp[i] ) {
    				return siblingCheck( ap[i], bp[i] );
    			}
    		}
    
    		// We ended someplace up the tree so do a sibling check
    		return i === al ?
    			siblingCheck( a, bp[i], -1 ) :
    			siblingCheck( ap[i], b, 1 );
    	};
    
    	siblingCheck = function( a, b, ret ) {
    		if ( a === b ) {
    			return ret;
    		}
    
    		var cur = a.nextSibling;
    
    		while ( cur ) {
    			if ( cur === b ) {
    				return -1;
    			}
    
    			cur = cur.nextSibling;
    		}
    
    		return 1;
    	};
    }
    
    // Check to see if the browser returns elements by name when
    // querying by getElementById (and provide a workaround)
    (function(){
    	// We're going to inject a fake input element with a specified name
    	var form = document.createElement("div"),
    		id = "script" + (new Date()).getTime(),
    		root = document.documentElement;
    
    	form.innerHTML = "<a name='" + id + "'/>";
    
    	// Inject it into the root element, check its status, and remove it quickly
    	root.insertBefore( form, root.firstChild );
    
    	// The workaround has to do additional checks after a getElementById
    	// Which slows things down for other browsers (hence the branching)
    	if ( document.getElementById( id ) ) {
    		Expr.find.ID = function( match, context, isXML ) {
    			if ( typeof context.getElementById !== "undefined" && !isXML ) {
    				var m = context.getElementById(match[1]);
    
    				return m ?
    					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
    						[m] :
    						undefined :
    					[];
    			}
    		};
    
    		Expr.filter.ID = function( elem, match ) {
    			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
    
    			return elem.nodeType === 1 && node && node.nodeValue === match;
    		};
    	}
    
    	root.removeChild( form );
    
    	// release memory in IE
    	root = form = null;
    })();
    
    (function(){
    	// Check to see if the browser returns only elements
    	// when doing getElementsByTagName("*")
    
    	// Create a fake element
    	var div = document.createElement("div");
    	div.appendChild( document.createComment("") );
    
    	// Make sure no comments are found
    	if ( div.getElementsByTagName("*").length > 0 ) {
    		Expr.find.TAG = function( match, context ) {
    			var results = context.getElementsByTagName( match[1] );
    
    			// Filter out possible comments
    			if ( match[1] === "*" ) {
    				var tmp = [];
    
    				for ( var i = 0; results[i]; i++ ) {
    					if ( results[i].nodeType === 1 ) {
    						tmp.push( results[i] );
    					}
    				}
    
    				results = tmp;
    			}
    
    			return results;
    		};
    	}
    
    	// Check to see if an attribute returns normalized href attributes
    	div.innerHTML = "<a href='#'></a>";
    
    	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
    			div.firstChild.getAttribute("href") !== "#" ) {
    
    		Expr.attrHandle.href = function( elem ) {
    			return elem.getAttribute( "href", 2 );
    		};
    	}
    
    	// release memory in IE
    	div = null;
    })();
    
    if ( document.querySelectorAll ) {
    	(function(){
    		var oldSizzle = Sizzle,
    			div = document.createElement("div"),
    			id = "__sizzle__";
    
    		div.innerHTML = "<p class='TEST'></p>";
    
    		// Safari can't handle uppercase or unicode characters when
    		// in quirks mode.
    		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
    			return;
    		}
    	
    		Sizzle = function( query, context, extra, seed ) {
    			context = context || document;
    
    			// Only use querySelectorAll on non-XML documents
    			// (ID selectors don't work in non-HTML documents)
    			if ( !seed && !Sizzle.isXML(context) ) {
    				// See if we find a selector to speed up
    				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
    				
    				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
    					// Speed-up: Sizzle("TAG")
    					if ( match[1] ) {
    						return makeArray( context.getElementsByTagName( query ), extra );
    					
    					// Speed-up: Sizzle(".CLASS")
    					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
    						return makeArray( context.getElementsByClassName( match[2] ), extra );
    					}
    				}
    				
    				if ( context.nodeType === 9 ) {
    					// Speed-up: Sizzle("body")
    					// The body element only exists once, optimize finding it
    					if ( query === "body" && context.body ) {
    						return makeArray( [ context.body ], extra );
    						
    					// Speed-up: Sizzle("#ID")
    					} else if ( match && match[3] ) {
    						var elem = context.getElementById( match[3] );
    
    						// Check parentNode to catch when Blackberry 4.6 returns
    						// nodes that are no longer in the document #6963
    						if ( elem && elem.parentNode ) {
    							// Handle the case where IE and Opera return items
    							// by name instead of ID
    							if ( elem.id === match[3] ) {
    								return makeArray( [ elem ], extra );
    							}
    							
    						} else {
    							return makeArray( [], extra );
    						}
    					}
    					
    					try {
    						return makeArray( context.querySelectorAll(query), extra );
    					} catch(qsaError) {}
    
    				// qSA works strangely on Element-rooted queries
    				// We can work around this by specifying an extra ID on the root
    				// and working up from there (Thanks to Andrew Dupont for the technique)
    				// IE 8 doesn't work on object elements
    				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
    					var oldContext = context,
    						old = context.getAttribute( "id" ),
    						nid = old || id,
    						hasParent = context.parentNode,
    						relativeHierarchySelector = /^\s*[+~]/.test( query );
    
    					if ( !old ) {
    						context.setAttribute( "id", nid );
    					} else {
    						nid = nid.replace( /'/g, "\\$&" );
    					}
    					if ( relativeHierarchySelector && hasParent ) {
    						context = context.parentNode;
    					}
    
    					try {
    						if ( !relativeHierarchySelector || hasParent ) {
    							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
    						}
    
    					} catch(pseudoError) {
    					} finally {
    						if ( !old ) {
    							oldContext.removeAttribute( "id" );
    						}
    					}
    				}
    			}
    		
    			return oldSizzle(query, context, extra, seed);
    		};
    
    		for ( var prop in oldSizzle ) {
    			Sizzle[ prop ] = oldSizzle[ prop ];
    		}
    
    		// release memory in IE
    		div = null;
    	})();
    }
    
    (function(){
    	var html = document.documentElement,
    		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
    
    	if ( matches ) {
    		// Check to see if it's possible to do matchesSelector
    		// on a disconnected node (IE 9 fails this)
    		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
    			pseudoWorks = false;
    
    		try {
    			// This should fail with an exception
    			// Gecko does not error, returns false instead
    			matches.call( document.documentElement, "[test!='']:sizzle" );
    	
    		} catch( pseudoError ) {
    			pseudoWorks = true;
    		}
    
    		Sizzle.matchesSelector = function( node, expr ) {
    			// Make sure that attribute selectors are quoted
    			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
    
    			if ( !Sizzle.isXML( node ) ) {
    				try { 
    					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
    						var ret = matches.call( node, expr );
    
    						// IE 9's matchesSelector returns false on disconnected nodes
    						if ( ret || !disconnectedMatch ||
    								// As well, disconnected nodes are said to be in a document
    								// fragment in IE 9, so check for that
    								node.document && node.document.nodeType !== 11 ) {
    							return ret;
    						}
    					}
    				} catch(e) {}
    			}
    
    			return Sizzle(expr, null, null, [node]).length > 0;
    		};
    	}
    })();
    
    (function(){
    	var div = document.createElement("div");
    
    	div.innerHTML = "<div class='test e'></div><div class='test'></div>";
    
    	// Opera can't find a second classname (in 9.6)
    	// Also, make sure that getElementsByClassName actually exists
    	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
    		return;
    	}
    
    	// Safari caches class attributes, doesn't catch changes (in 3.2)
    	div.lastChild.className = "e";
    
    	if ( div.getElementsByClassName("e").length === 1 ) {
    		return;
    	}
    	
    	Expr.order.splice(1, 0, "CLASS");
    	Expr.find.CLASS = function( match, context, isXML ) {
    		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
    			return context.getElementsByClassName(match[1]);
    		}
    	};
    
    	// release memory in IE
    	div = null;
    })();
    
    function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
    	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
    		var elem = checkSet[i];
    
    		if ( elem ) {
    			var match = false;
    
    			elem = elem[dir];
    
    			while ( elem ) {
    				if ( elem[ expando ] === doneName ) {
    					match = checkSet[elem.sizset];
    					break;
    				}
    
    				if ( elem.nodeType === 1 && !isXML ){
    					elem[ expando ] = doneName;
    					elem.sizset = i;
    				}
    
    				if ( elem.nodeName.toLowerCase() === cur ) {
    					match = elem;
    					break;
    				}
    
    				elem = elem[dir];
    			}
    
    			checkSet[i] = match;
    		}
    	}
    }
    
    function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
    	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
    		var elem = checkSet[i];
    
    		if ( elem ) {
    			var match = false;
    			
    			elem = elem[dir];
    
    			while ( elem ) {
    				if ( elem[ expando ] === doneName ) {
    					match = checkSet[elem.sizset];
    					break;
    				}
    
    				if ( elem.nodeType === 1 ) {
    					if ( !isXML ) {
    						elem[ expando ] = doneName;
    						elem.sizset = i;
    					}
    
    					if ( typeof cur !== "string" ) {
    						if ( elem === cur ) {
    							match = true;
    							break;
    						}
    
    					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
    						match = elem;
    						break;
    					}
    				}
    
    				elem = elem[dir];
    			}
    
    			checkSet[i] = match;
    		}
    	}
    }
    
    if ( document.documentElement.contains ) {
    	Sizzle.contains = function( a, b ) {
    		return a !== b && (a.contains ? a.contains(b) : true);
    	};
    
    } else if ( document.documentElement.compareDocumentPosition ) {
    	Sizzle.contains = function( a, b ) {
    		return !!(a.compareDocumentPosition(b) & 16);
    	};
    
    } else {
    	Sizzle.contains = function() {
    		return false;
    	};
    }
    
    Sizzle.isXML = function( elem ) {
    	// documentElement is verified for cases where it doesn't yet exist
    	// (such as loading iframes in IE - #4833) 
    	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
    
    	return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    
    var posProcess = function( selector, context, seed ) {
    	var match,
    		tmpSet = [],
    		later = "",
    		root = context.nodeType ? [context] : context;
    
    	// Position selectors must be done after the filter
    	// And so must :not(positional) so we move all PSEUDOs to the end
    	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
    		later += match[0];
    		selector = selector.replace( Expr.match.PSEUDO, "" );
    	}
    
    	selector = Expr.relative[selector] ? selector + "*" : selector;
    
    	for ( var i = 0, l = root.length; i < l; i++ ) {
    		Sizzle( selector, root[i], tmpSet, seed );
    	}
    
    	return Sizzle.filter( later, tmpSet );
    };
    
    // EXPOSE
    // Override sizzle attribute retrieval
    Sizzle.attr = jQuery.attr;
    Sizzle.selectors.attrMap = {};
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.filters;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    
    
    })();
    
    
    var runtil = /Until$/,
    	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
    	// Note: This RegExp should be improved, or likely pulled from Sizzle
    	rmultiselector = /,/,
    	isSimple = /^.[^:#\[\.,]*$/,
    	slice = Array.prototype.slice,
    	POS = jQuery.expr.match.POS,
    	// methods guaranteed to produce a unique set when starting from a unique set
    	guaranteedUnique = {
    		children: true,
    		contents: true,
    		next: true,
    		prev: true
    	};
    
    jQuery.fn.extend({
    	find: function( selector ) {
    		var self = this,
    			i, l;
    
    		if ( typeof selector !== "string" ) {
    			return jQuery( selector ).filter(function() {
    				for ( i = 0, l = self.length; i < l; i++ ) {
    					if ( jQuery.contains( self[ i ], this ) ) {
    						return true;
    					}
    				}
    			});
    		}
    
    		var ret = this.pushStack( "", "find", selector ),
    			length, n, r;
    
    		for ( i = 0, l = this.length; i < l; i++ ) {
    			length = ret.length;
    			jQuery.find( selector, this[i], ret );
    
    			if ( i > 0 ) {
    				// Make sure that the results are unique
    				for ( n = length; n < ret.length; n++ ) {
    					for ( r = 0; r < length; r++ ) {
    						if ( ret[r] === ret[n] ) {
    							ret.splice(n--, 1);
    							break;
    						}
    					}
    				}
    			}
    		}
    
    		return ret;
    	},
    
    	has: function( target ) {
    		var targets = jQuery( target );
    		return this.filter(function() {
    			for ( var i = 0, l = targets.length; i < l; i++ ) {
    				if ( jQuery.contains( this, targets[i] ) ) {
    					return true;
    				}
    			}
    		});
    	},
    
    	not: function( selector ) {
    		return this.pushStack( winnow(this, selector, false), "not", selector);
    	},
    
    	filter: function( selector ) {
    		return this.pushStack( winnow(this, selector, true), "filter", selector );
    	},
    
    	is: function( selector ) {
    		return !!selector && ( 
    			typeof selector === "string" ?
    				// If this is a positional selector, check membership in the returned set
    				// so $("p:first").is("p:last") won't return true for a doc with two "p".
    				POS.test( selector ) ? 
    					jQuery( selector, this.context ).index( this[0] ) >= 0 :
    					jQuery.filter( selector, this ).length > 0 :
    				this.filter( selector ).length > 0 );
    	},
    
    	closest: function( selectors, context ) {
    		var ret = [], i, l, cur = this[0];
    		
    		// Array (deprecated as of jQuery 1.7)
    		if ( jQuery.isArray( selectors ) ) {
    			var level = 1;
    
    			while ( cur && cur.ownerDocument && cur !== context ) {
    				for ( i = 0; i < selectors.length; i++ ) {
    
    					if ( jQuery( cur ).is( selectors[ i ] ) ) {
    						ret.push({ selector: selectors[ i ], elem: cur, level: level });
    					}
    				}
    
    				cur = cur.parentNode;
    				level++;
    			}
    
    			return ret;
    		}
    
    		// String
    		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
    				jQuery( selectors, context || this.context ) :
    				0;
    
    		for ( i = 0, l = this.length; i < l; i++ ) {
    			cur = this[i];
    
    			while ( cur ) {
    				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
    					ret.push( cur );
    					break;
    
    				} else {
    					cur = cur.parentNode;
    					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
    						break;
    					}
    				}
    			}
    		}
    
    		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;
    
    		return this.pushStack( ret, "closest", selectors );
    	},
    
    	// Determine the position of an element within
    	// the matched set of elements
    	index: function( elem ) {
    
    		// No argument, return index in parent
    		if ( !elem ) {
    			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
    		}
    
    		// index in selector
    		if ( typeof elem === "string" ) {
    			return jQuery.inArray( this[0], jQuery( elem ) );
    		}
    
    		// Locate the position of the desired element
    		return jQuery.inArray(
    			// If it receives a jQuery object, the first element is used
    			elem.jquery ? elem[0] : elem, this );
    	},
    
    	add: function( selector, context ) {
    		var set = typeof selector === "string" ?
    				jQuery( selector, context ) :
    				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
    			all = jQuery.merge( this.get(), set );
    
    		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
    			all :
    			jQuery.unique( all ) );
    	},
    
    	andSelf: function() {
    		return this.add( this.prevObject );
    	}
    });
    
    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected( node ) {
    	return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }
    
    jQuery.each({
    	parent: function( elem ) {
    		var parent = elem.parentNode;
    		return parent && parent.nodeType !== 11 ? parent : null;
    	},
    	parents: function( elem ) {
    		return jQuery.dir( elem, "parentNode" );
    	},
    	parentsUntil: function( elem, i, until ) {
    		return jQuery.dir( elem, "parentNode", until );
    	},
    	next: function( elem ) {
    		return jQuery.nth( elem, 2, "nextSibling" );
    	},
    	prev: function( elem ) {
    		return jQuery.nth( elem, 2, "previousSibling" );
    	},
    	nextAll: function( elem ) {
    		return jQuery.dir( elem, "nextSibling" );
    	},
    	prevAll: function( elem ) {
    		return jQuery.dir( elem, "previousSibling" );
    	},
    	nextUntil: function( elem, i, until ) {
    		return jQuery.dir( elem, "nextSibling", until );
    	},
    	prevUntil: function( elem, i, until ) {
    		return jQuery.dir( elem, "previousSibling", until );
    	},
    	siblings: function( elem ) {
    		return jQuery.sibling( elem.parentNode.firstChild, elem );
    	},
    	children: function( elem ) {
    		return jQuery.sibling( elem.firstChild );
    	},
    	contents: function( elem ) {
    		return jQuery.nodeName( elem, "iframe" ) ?
    			elem.contentDocument || elem.contentWindow.document :
    			jQuery.makeArray( elem.childNodes );
    	}
    }, function( name, fn ) {
    	jQuery.fn[ name ] = function( until, selector ) {
    		var ret = jQuery.map( this, fn, until );
    
    		if ( !runtil.test( name ) ) {
    			selector = until;
    		}
    
    		if ( selector && typeof selector === "string" ) {
    			ret = jQuery.filter( selector, ret );
    		}
    
    		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
    
    		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
    			ret = ret.reverse();
    		}
    
    		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
    	};
    });
    
    jQuery.extend({
    	filter: function( expr, elems, not ) {
    		if ( not ) {
    			expr = ":not(" + expr + ")";
    		}
    
    		return elems.length === 1 ?
    			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
    			jQuery.find.matches(expr, elems);
    	},
    
    	dir: function( elem, dir, until ) {
    		var matched = [],
    			cur = elem[ dir ];
    
    		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
    			if ( cur.nodeType === 1 ) {
    				matched.push( cur );
    			}
    			cur = cur[dir];
    		}
    		return matched;
    	},
    
    	nth: function( cur, result, dir, elem ) {
    		result = result || 1;
    		var num = 0;
    
    		for ( ; cur; cur = cur[dir] ) {
    			if ( cur.nodeType === 1 && ++num === result ) {
    				break;
    			}
    		}
    
    		return cur;
    	},
    
    	sibling: function( n, elem ) {
    		var r = [];
    
    		for ( ; n; n = n.nextSibling ) {
    			if ( n.nodeType === 1 && n !== elem ) {
    				r.push( n );
    			}
    		}
    
    		return r;
    	}
    });
    
    // Implement the identical functionality for filter and not
    function winnow( elements, qualifier, keep ) {
    
    	// Can't pass null or undefined to indexOf in Firefox 4
    	// Set to 0 to skip string check
    	qualifier = qualifier || 0;
    
    	if ( jQuery.isFunction( qualifier ) ) {
    		return jQuery.grep(elements, function( elem, i ) {
    			var retVal = !!qualifier.call( elem, i, elem );
    			return retVal === keep;
    		});
    
    	} else if ( qualifier.nodeType ) {
    		return jQuery.grep(elements, function( elem, i ) {
    			return ( elem === qualifier ) === keep;
    		});
    
    	} else if ( typeof qualifier === "string" ) {
    		var filtered = jQuery.grep(elements, function( elem ) {
    			return elem.nodeType === 1;
    		});
    
    		if ( isSimple.test( qualifier ) ) {
    			return jQuery.filter(qualifier, filtered, !keep);
    		} else {
    			qualifier = jQuery.filter( qualifier, filtered );
    		}
    	}
    
    	return jQuery.grep(elements, function( elem, i ) {
    		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
    	});
    }
    
    
    
    
    function createSafeFragment( document ) {
    	var list = nodeNames.split( "|" ),
    	safeFrag = document.createDocumentFragment();
    
    	if ( safeFrag.createElement ) {
    		while ( list.length ) {
    			safeFrag.createElement(
    				list.pop()
    			);
    		}
    	}
    	return safeFrag;
    }
    
    var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
    		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
    	rleadingWhitespace = /^\s+/,
    	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
    	rtagName = /<([\w:]+)/,
    	rtbody = /<tbody/i,
    	rhtml = /<|&#?\w+;/,
    	rnoInnerhtml = /<(?:script|style)/i,
    	rnocache = /<(?:script|object|embed|option|style)/i,
    	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
    	// checked="checked" or checked
    	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    	rscriptType = /\/(java|ecma)script/i,
    	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
    	wrapMap = {
    		option: [ 1, "<select multiple='multiple'>", "</select>" ],
    		legend: [ 1, "<fieldset>", "</fieldset>" ],
    		thead: [ 1, "<table>", "</table>" ],
    		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
    		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
    		area: [ 1, "<map>", "</map>" ],
    		_default: [ 0, "", "" ]
    	},
    	safeFragment = createSafeFragment( document );
    
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    
    // IE can't serialize <link> and <script> tags normally
    if ( !jQuery.support.htmlSerialize ) {
    	wrapMap._default = [ 1, "div<div>", "</div>" ];
    }
    
    jQuery.fn.extend({
    	text: function( text ) {
    		if ( jQuery.isFunction(text) ) {
    			return this.each(function(i) {
    				var self = jQuery( this );
    
    				self.text( text.call(this, i, self.text()) );
    			});
    		}
    
    		if ( typeof text !== "object" && text !== undefined ) {
    			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
    		}
    
    		return jQuery.text( this );
    	},
    
    	wrapAll: function( html ) {
    		if ( jQuery.isFunction( html ) ) {
    			return this.each(function(i) {
    				jQuery(this).wrapAll( html.call(this, i) );
    			});
    		}
    
    		if ( this[0] ) {
    			// The elements to wrap the target around
    			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
    
    			if ( this[0].parentNode ) {
    				wrap.insertBefore( this[0] );
    			}
    
    			wrap.map(function() {
    				var elem = this;
    
    				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
    					elem = elem.firstChild;
    				}
    
    				return elem;
    			}).append( this );
    		}
    
    		return this;
    	},
    
    	wrapInner: function( html ) {
    		if ( jQuery.isFunction( html ) ) {
    			return this.each(function(i) {
    				jQuery(this).wrapInner( html.call(this, i) );
    			});
    		}
    
    		return this.each(function() {
    			var self = jQuery( this ),
    				contents = self.contents();
    
    			if ( contents.length ) {
    				contents.wrapAll( html );
    
    			} else {
    				self.append( html );
    			}
    		});
    	},
    
    	wrap: function( html ) {
    		var isFunction = jQuery.isFunction( html );
    
    		return this.each(function(i) {
    			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
    		});
    	},
    
    	unwrap: function() {
    		return this.parent().each(function() {
    			if ( !jQuery.nodeName( this, "body" ) ) {
    				jQuery( this ).replaceWith( this.childNodes );
    			}
    		}).end();
    	},
    
    	append: function() {
    		return this.domManip(arguments, true, function( elem ) {
    			if ( this.nodeType === 1 ) {
    				this.appendChild( elem );
    			}
    		});
    	},
    
    	prepend: function() {
    		return this.domManip(arguments, true, function( elem ) {
    			if ( this.nodeType === 1 ) {
    				this.insertBefore( elem, this.firstChild );
    			}
    		});
    	},
    
    	before: function() {
    		if ( this[0] && this[0].parentNode ) {
    			return this.domManip(arguments, false, function( elem ) {
    				this.parentNode.insertBefore( elem, this );
    			});
    		} else if ( arguments.length ) {
    			var set = jQuery.clean( arguments );
    			set.push.apply( set, this.toArray() );
    			return this.pushStack( set, "before", arguments );
    		}
    	},
    
    	after: function() {
    		if ( this[0] && this[0].parentNode ) {
    			return this.domManip(arguments, false, function( elem ) {
    				this.parentNode.insertBefore( elem, this.nextSibling );
    			});
    		} else if ( arguments.length ) {
    			var set = this.pushStack( this, "after", arguments );
    			set.push.apply( set, jQuery.clean(arguments) );
    			return set;
    		}
    	},
    
    	// keepData is for internal use only--do not document
    	remove: function( selector, keepData ) {
    		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
    			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
    				if ( !keepData && elem.nodeType === 1 ) {
    					jQuery.cleanData( elem.getElementsByTagName("*") );
    					jQuery.cleanData( [ elem ] );
    				}
    
    				if ( elem.parentNode ) {
    					elem.parentNode.removeChild( elem );
    				}
    			}
    		}
    
    		return this;
    	},
    
    	empty: function() {
    		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
    			// Remove element nodes and prevent memory leaks
    			if ( elem.nodeType === 1 ) {
    				jQuery.cleanData( elem.getElementsByTagName("*") );
    			}
    
    			// Remove any remaining nodes
    			while ( elem.firstChild ) {
    				elem.removeChild( elem.firstChild );
    			}
    		}
    
    		return this;
    	},
    
    	clone: function( dataAndEvents, deepDataAndEvents ) {
    		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
    
    		return this.map( function () {
    			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    		});
    	},
    
    	html: function( value ) {
    		if ( value === undefined ) {
    			return this[0] && this[0].nodeType === 1 ?
    				this[0].innerHTML.replace(rinlinejQuery, "") :
    				null;
    
    		// See if we can take a shortcut and just use innerHTML
    		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
    			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
    			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {
    
    			value = value.replace(rxhtmlTag, "<$1></$2>");
    
    			try {
    				for ( var i = 0, l = this.length; i < l; i++ ) {
    					// Remove element nodes and prevent memory leaks
    					if ( this[i].nodeType === 1 ) {
    						jQuery.cleanData( this[i].getElementsByTagName("*") );
    						this[i].innerHTML = value;
    					}
    				}
    
    			// If using innerHTML throws an exception, use the fallback method
    			} catch(e) {
    				this.empty().append( value );
    			}
    
    		} else if ( jQuery.isFunction( value ) ) {
    			this.each(function(i){
    				var self = jQuery( this );
    
    				self.html( value.call(this, i, self.html()) );
    			});
    
    		} else {
    			this.empty().append( value );
    		}
    
    		return this;
    	},
    
    	replaceWith: function( value ) {
    		if ( this[0] && this[0].parentNode ) {
    			// Make sure that the elements are removed from the DOM before they are inserted
    			// this can help fix replacing a parent with child elements
    			if ( jQuery.isFunction( value ) ) {
    				return this.each(function(i) {
    					var self = jQuery(this), old = self.html();
    					self.replaceWith( value.call( this, i, old ) );
    				});
    			}
    
    			if ( typeof value !== "string" ) {
    				value = jQuery( value ).detach();
    			}
    
    			return this.each(function() {
    				var next = this.nextSibling,
    					parent = this.parentNode;
    
    				jQuery( this ).remove();
    
    				if ( next ) {
    					jQuery(next).before( value );
    				} else {
    					jQuery(parent).append( value );
    				}
    			});
    		} else {
    			return this.length ?
    				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
    				this;
    		}
    	},
    
    	detach: function( selector ) {
    		return this.remove( selector, true );
    	},
    
    	domManip: function( args, table, callback ) {
    		var results, first, fragment, parent,
    			value = args[0],
    			scripts = [];
    
    		// We can't cloneNode fragments that contain checked, in WebKit
    		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
    			return this.each(function() {
    				jQuery(this).domManip( args, table, callback, true );
    			});
    		}
    
    		if ( jQuery.isFunction(value) ) {
    			return this.each(function(i) {
    				var self = jQuery(this);
    				args[0] = value.call(this, i, table ? self.html() : undefined);
    				self.domManip( args, table, callback );
    			});
    		}
    
    		if ( this[0] ) {
    			parent = value && value.parentNode;
    
    			// If we're in a fragment, just use that instead of building a new one
    			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
    				results = { fragment: parent };
    
    			} else {
    				results = jQuery.buildFragment( args, this, scripts );
    			}
    
    			fragment = results.fragment;
    
    			if ( fragment.childNodes.length === 1 ) {
    				first = fragment = fragment.firstChild;
    			} else {
    				first = fragment.firstChild;
    			}
    
    			if ( first ) {
    				table = table && jQuery.nodeName( first, "tr" );
    
    				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
    					callback.call(
    						table ?
    							root(this[i], first) :
    							this[i],
    						// Make sure that we do not leak memory by inadvertently discarding
    						// the original fragment (which might have attached data) instead of
    						// using it; in addition, use the original fragment object for the last
    						// item instead of first because it can end up being emptied incorrectly
    						// in certain situations (Bug #8070).
    						// Fragments from the fragment cache must always be cloned and never used
    						// in place.
    						results.cacheable || ( l > 1 && i < lastIndex ) ?
    							jQuery.clone( fragment, true, true ) :
    							fragment
    					);
    				}
    			}
    
    			if ( scripts.length ) {
    				jQuery.each( scripts, evalScript );
    			}
    		}
    
    		return this;
    	}
    });
    
    function root( elem, cur ) {
    	return jQuery.nodeName(elem, "table") ?
    		(elem.getElementsByTagName("tbody")[0] ||
    		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
    		elem;
    }
    
    function cloneCopyEvent( src, dest ) {
    
    	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
    		return;
    	}
    
    	var type, i, l,
    		oldData = jQuery._data( src ),
    		curData = jQuery._data( dest, oldData ),
    		events = oldData.events;
    
    	if ( events ) {
    		delete curData.handle;
    		curData.events = {};
    
    		for ( type in events ) {
    			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
    				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
    			}
    		}
    	}
    
    	// make the cloned public data object a copy from the original
    	if ( curData.data ) {
    		curData.data = jQuery.extend( {}, curData.data );
    	}
    }
    
    function cloneFixAttributes( src, dest ) {
    	var nodeName;
    
    	// We do not need to do anything for non-Elements
    	if ( dest.nodeType !== 1 ) {
    		return;
    	}
    
    	// clearAttributes removes the attributes, which we don't want,
    	// but also removes the attachEvent events, which we *do* want
    	if ( dest.clearAttributes ) {
    		dest.clearAttributes();
    	}
    
    	// mergeAttributes, in contrast, only merges back on the
    	// original attributes, not the events
    	if ( dest.mergeAttributes ) {
    		dest.mergeAttributes( src );
    	}
    
    	nodeName = dest.nodeName.toLowerCase();
    
    	// IE6-8 fail to clone children inside object elements that use
    	// the proprietary classid attribute value (rather than the type
    	// attribute) to identify the type of content to display
    	if ( nodeName === "object" ) {
    		dest.outerHTML = src.outerHTML;
    
    	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
    		// IE6-8 fails to persist the checked state of a cloned checkbox
    		// or radio button. Worse, IE6-7 fail to give the cloned element
    		// a checked appearance if the defaultChecked value isn't also set
    		if ( src.checked ) {
    			dest.defaultChecked = dest.checked = src.checked;
    		}
    
    		// IE6-7 get confused and end up setting the value of a cloned
    		// checkbox/radio button to an empty string instead of "on"
    		if ( dest.value !== src.value ) {
    			dest.value = src.value;
    		}
    
    	// IE6-8 fails to return the selected option to the default selected
    	// state when cloning options
    	} else if ( nodeName === "option" ) {
    		dest.selected = src.defaultSelected;
    
    	// IE6-8 fails to set the defaultValue to the correct value when
    	// cloning other types of input fields
    	} else if ( nodeName === "input" || nodeName === "textarea" ) {
    		dest.defaultValue = src.defaultValue;
    	}
    
    	// Event data gets referenced instead of copied if the expando
    	// gets copied too
    	dest.removeAttribute( jQuery.expando );
    }
    
    jQuery.buildFragment = function( args, nodes, scripts ) {
    	var fragment, cacheable, cacheresults, doc,
    	first = args[ 0 ];
    
    	// nodes may contain either an explicit document object,
    	// a jQuery collection or context object.
    	// If nodes[0] contains a valid object to assign to doc
    	if ( nodes && nodes[0] ) {
    		doc = nodes[0].ownerDocument || nodes[0];
    	}
    
    	// Ensure that an attr object doesn't incorrectly stand in as a document object
    	// Chrome and Firefox seem to allow this to occur and will throw exception
    	// Fixes #8950
    	if ( !doc.createDocumentFragment ) {
    		doc = document;
    	}
    
    	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
    	// Cloning options loses the selected state, so don't cache them
    	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
    	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
    	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
    	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
    		first.charAt(0) === "<" && !rnocache.test( first ) &&
    		(jQuery.support.checkClone || !rchecked.test( first )) &&
    		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {
    
    		cacheable = true;
    
    		cacheresults = jQuery.fragments[ first ];
    		if ( cacheresults && cacheresults !== 1 ) {
    			fragment = cacheresults;
    		}
    	}
    
    	if ( !fragment ) {
    		fragment = doc.createDocumentFragment();
    		jQuery.clean( args, doc, fragment, scripts );
    	}
    
    	if ( cacheable ) {
    		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
    	}
    
    	return { fragment: fragment, cacheable: cacheable };
    };
    
    jQuery.fragments = {};
    
    jQuery.each({
    	appendTo: "append",
    	prependTo: "prepend",
    	insertBefore: "before",
    	insertAfter: "after",
    	replaceAll: "replaceWith"
    }, function( name, original ) {
    	jQuery.fn[ name ] = function( selector ) {
    		var ret = [],
    			insert = jQuery( selector ),
    			parent = this.length === 1 && this[0].parentNode;
    
    		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
    			insert[ original ]( this[0] );
    			return this;
    
    		} else {
    			for ( var i = 0, l = insert.length; i < l; i++ ) {
    				var elems = ( i > 0 ? this.clone(true) : this ).get();
    				jQuery( insert[i] )[ original ]( elems );
    				ret = ret.concat( elems );
    			}
    
    			return this.pushStack( ret, name, insert.selector );
    		}
    	};
    });
    
    function getAll( elem ) {
    	if ( typeof elem.getElementsByTagName !== "undefined" ) {
    		return elem.getElementsByTagName( "*" );
    
    	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
    		return elem.querySelectorAll( "*" );
    
    	} else {
    		return [];
    	}
    }
    
    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked( elem ) {
    	if ( elem.type === "checkbox" || elem.type === "radio" ) {
    		elem.defaultChecked = elem.checked;
    	}
    }
    // Finds all inputs and passes them to fixDefaultChecked
    function findInputs( elem ) {
    	var nodeName = ( elem.nodeName || "" ).toLowerCase();
    	if ( nodeName === "input" ) {
    		fixDefaultChecked( elem );
    	// Skip scripts, get other children
    	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
    		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
    	}
    }
    
    // Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
    function shimCloneNode( elem ) {
    	var div = document.createElement( "div" );
    	safeFragment.appendChild( div );
    
    	div.innerHTML = elem.outerHTML;
    	return div.firstChild;
    }
    
    jQuery.extend({
    	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    		var srcElements,
    			destElements,
    			i,
    			// IE<=8 does not properly clone detached, unknown element nodes
    			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
    				elem.cloneNode( true ) :
    				shimCloneNode( elem );
    
    		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
    				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
    			// IE copies events bound via attachEvent when using cloneNode.
    			// Calling detachEvent on the clone will also remove the events
    			// from the original. In order to get around this, we use some
    			// proprietary methods to clear the events. Thanks to MooTools
    			// guys for this hotness.
    
    			cloneFixAttributes( elem, clone );
    
    			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
    			srcElements = getAll( elem );
    			destElements = getAll( clone );
    
    			// Weird iteration because IE will replace the length property
    			// with an element if you are cloning the body and one of the
    			// elements on the page has a name or id of "length"
    			for ( i = 0; srcElements[i]; ++i ) {
    				// Ensure that the destination node is not null; Fixes #9587
    				if ( destElements[i] ) {
    					cloneFixAttributes( srcElements[i], destElements[i] );
    				}
    			}
    		}
    
    		// Copy the events from the original to the clone
    		if ( dataAndEvents ) {
    			cloneCopyEvent( elem, clone );
    
    			if ( deepDataAndEvents ) {
    				srcElements = getAll( elem );
    				destElements = getAll( clone );
    
    				for ( i = 0; srcElements[i]; ++i ) {
    					cloneCopyEvent( srcElements[i], destElements[i] );
    				}
    			}
    		}
    
    		srcElements = destElements = null;
    
    		// Return the cloned set
    		return clone;
    	},
    
    	clean: function( elems, context, fragment, scripts ) {
    		var checkScriptType;
    
    		context = context || document;
    
    		// !context.createElement fails in IE with an error but returns typeof 'object'
    		if ( typeof context.createElement === "undefined" ) {
    			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
    		}
    
    		var ret = [], j;
    
    		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
    			if ( typeof elem === "number" ) {
    				elem += "";
    			}
    
    			if ( !elem ) {
    				continue;
    			}
    
    			// Convert html string into DOM nodes
    			if ( typeof elem === "string" ) {
    				if ( !rhtml.test( elem ) ) {
    					elem = context.createTextNode( elem );
    				} else {
    					// Fix "XHTML"-style tags in all browsers
    					elem = elem.replace(rxhtmlTag, "<$1></$2>");
    
    					// Trim whitespace, otherwise indexOf won't work as expected
    					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
    						wrap = wrapMap[ tag ] || wrapMap._default,
    						depth = wrap[0],
    						div = context.createElement("div");
    
    					// Append wrapper element to unknown element safe doc fragment
    					if ( context === document ) {
    						// Use the fragment we've already created for this document
    						safeFragment.appendChild( div );
    					} else {
    						// Use a fragment created with the owner document
    						createSafeFragment( context ).appendChild( div );
    					}
    
    					// Go to html and back, then peel off extra wrappers
    					div.innerHTML = wrap[1] + elem + wrap[2];
    
    					// Move to the right depth
    					while ( depth-- ) {
    						div = div.lastChild;
    					}
    
    					// Remove IE's autoinserted <tbody> from table fragments
    					if ( !jQuery.support.tbody ) {
    
    						// String was a <table>, *may* have spurious <tbody>
    						var hasBody = rtbody.test(elem),
    							tbody = tag === "table" && !hasBody ?
    								div.firstChild && div.firstChild.childNodes :
    
    								// String was a bare <thead> or <tfoot>
    								wrap[1] === "<table>" && !hasBody ?
    									div.childNodes :
    									[];
    
    						for ( j = tbody.length - 1; j >= 0 ; --j ) {
    							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
    								tbody[ j ].parentNode.removeChild( tbody[ j ] );
    							}
    						}
    					}
    
    					// IE completely kills leading whitespace when innerHTML is used
    					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
    						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
    					}
    
    					elem = div.childNodes;
    				}
    			}
    
    			// Resets defaultChecked for any radios and checkboxes
    			// about to be appended to the DOM in IE 6/7 (#8060)
    			var len;
    			if ( !jQuery.support.appendChecked ) {
    				if ( elem[0] && typeof (len = elem.length) === "number" ) {
    					for ( j = 0; j < len; j++ ) {
    						findInputs( elem[j] );
    					}
    				} else {
    					findInputs( elem );
    				}
    			}
    
    			if ( elem.nodeType ) {
    				ret.push( elem );
    			} else {
    				ret = jQuery.merge( ret, elem );
    			}
    		}
    
    		if ( fragment ) {
    			checkScriptType = function( elem ) {
    				return !elem.type || rscriptType.test( elem.type );
    			};
    			for ( i = 0; ret[i]; i++ ) {
    				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
    					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
    
    				} else {
    					if ( ret[i].nodeType === 1 ) {
    						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );
    
    						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
    					}
    					fragment.appendChild( ret[i] );
    				}
    			}
    		}
    
    		return ret;
    	},
    
    	cleanData: function( elems ) {
    		var data, id,
    			cache = jQuery.cache,
    			special = jQuery.event.special,
    			deleteExpando = jQuery.support.deleteExpando;
    
    		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
    			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
    				continue;
    			}
    
    			id = elem[ jQuery.expando ];
    
    			if ( id ) {
    				data = cache[ id ];
    
    				if ( data && data.events ) {
    					for ( var type in data.events ) {
    						if ( special[ type ] ) {
    							jQuery.event.remove( elem, type );
    
    						// This is a shortcut to avoid jQuery.event.remove's overhead
    						} else {
    							jQuery.removeEvent( elem, type, data.handle );
    						}
    					}
    
    					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
    					if ( data.handle ) {
    						data.handle.elem = null;
    					}
    				}
    
    				if ( deleteExpando ) {
    					delete elem[ jQuery.expando ];
    
    				} else if ( elem.removeAttribute ) {
    					elem.removeAttribute( jQuery.expando );
    				}
    
    				delete cache[ id ];
    			}
    		}
    	}
    });
    
    function evalScript( i, elem ) {
    	if ( elem.src ) {
    		jQuery.ajax({
    			url: elem.src,
    			async: false,
    			dataType: "script"
    		});
    	} else {
    		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
    	}
    
    	if ( elem.parentNode ) {
    		elem.parentNode.removeChild( elem );
    	}
    }
    
    
    
    
    var ralpha = /alpha\([^)]*\)/i,
    	ropacity = /opacity=([^)]*)/,
    	// fixed for IE9, see #8346
    	rupper = /([A-Z]|^ms)/g,
    	rnumpx = /^-?\d+(?:px)?$/i,
    	rnum = /^-?\d/,
    	rrelNum = /^([\-+])=([\-+.\de]+)/,
    
    	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    	cssWidth = [ "Left", "Right" ],
    	cssHeight = [ "Top", "Bottom" ],
    	curCSS,
    
    	getComputedStyle,
    	currentStyle;
    
    jQuery.fn.css = function( name, value ) {
    	// Setting 'undefined' is a no-op
    	if ( arguments.length === 2 && value === undefined ) {
    		return this;
    	}
    
    	return jQuery.access( this, name, value, true, function( elem, name, value ) {
    		return value !== undefined ?
    			jQuery.style( elem, name, value ) :
    			jQuery.css( elem, name );
    	});
    };
    
    jQuery.extend({
    	// Add in style property hooks for overriding the default
    	// behavior of getting and setting a style property
    	cssHooks: {
    		opacity: {
    			get: function( elem, computed ) {
    				if ( computed ) {
    					// We should always get a number back from opacity
    					var ret = curCSS( elem, "opacity", "opacity" );
    					return ret === "" ? "1" : ret;
    
    				} else {
    					return elem.style.opacity;
    				}
    			}
    		}
    	},
    
    	// Exclude the following css properties to add px
    	cssNumber: {
    		"fillOpacity": true,
    		"fontWeight": true,
    		"lineHeight": true,
    		"opacity": true,
    		"orphans": true,
    		"widows": true,
    		"zIndex": true,
    		"zoom": true
    	},
    
    	// Add in properties whose names you wish to fix before
    	// setting or getting the value
    	cssProps: {
    		// normalize float css property
    		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
    	},
    
    	// Get and set the style property on a DOM Node
    	style: function( elem, name, value, extra ) {
    		// Don't set styles on text and comment nodes
    		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
    			return;
    		}
    
    		// Make sure that we're working with the right name
    		var ret, type, origName = jQuery.camelCase( name ),
    			style = elem.style, hooks = jQuery.cssHooks[ origName ];
    
    		name = jQuery.cssProps[ origName ] || origName;
    
    		// Check if we're setting a value
    		if ( value !== undefined ) {
    			type = typeof value;
    
    			// convert relative number strings (+= or -=) to relative numbers. #7345
    			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
    				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
    				// Fixes bug #9237
    				type = "number";
    			}
    
    			// Make sure that NaN and null values aren't set. See: #7116
    			if ( value == null || type === "number" && isNaN( value ) ) {
    				return;
    			}
    
    			// If a number was passed in, add 'px' to the (except for certain CSS properties)
    			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
    				value += "px";
    			}
    
    			// If a hook was provided, use that value, otherwise just set the specified value
    			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
    				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
    				// Fixes bug #5509
    				try {
    					style[ name ] = value;
    				} catch(e) {}
    			}
    
    		} else {
    			// If a hook was provided get the non-computed value from there
    			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
    				return ret;
    			}
    
    			// Otherwise just get the value from the style object
    			return style[ name ];
    		}
    	},
    
    	css: function( elem, name, extra ) {
    		var ret, hooks;
    
    		// Make sure that we're working with the right name
    		name = jQuery.camelCase( name );
    		hooks = jQuery.cssHooks[ name ];
    		name = jQuery.cssProps[ name ] || name;
    
    		// cssFloat needs a special treatment
    		if ( name === "cssFloat" ) {
    			name = "float";
    		}
    
    		// If a hook was provided get the computed value from there
    		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
    			return ret;
    
    		// Otherwise, if a way to get the computed value exists, use that
    		} else if ( curCSS ) {
    			return curCSS( elem, name );
    		}
    	},
    
    	// A method for quickly swapping in/out CSS properties to get correct calculations
    	swap: function( elem, options, callback ) {
    		var old = {};
    
    		// Remember the old values, and insert the new ones
    		for ( var name in options ) {
    			old[ name ] = elem.style[ name ];
    			elem.style[ name ] = options[ name ];
    		}
    
    		callback.call( elem );
    
    		// Revert the old values
    		for ( name in options ) {
    			elem.style[ name ] = old[ name ];
    		}
    	}
    });
    
    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;
    
    jQuery.each(["height", "width"], function( i, name ) {
    	jQuery.cssHooks[ name ] = {
    		get: function( elem, computed, extra ) {
    			var val;
    
    			if ( computed ) {
    				if ( elem.offsetWidth !== 0 ) {
    					return getWH( elem, name, extra );
    				} else {
    					jQuery.swap( elem, cssShow, function() {
    						val = getWH( elem, name, extra );
    					});
    				}
    
    				return val;
    			}
    		},
    
    		set: function( elem, value ) {
    			if ( rnumpx.test( value ) ) {
    				// ignore negative width and height values #1599
    				value = parseFloat( value );
    
    				if ( value >= 0 ) {
    					return value + "px";
    				}
    
    			} else {
    				return value;
    			}
    		}
    	};
    });
    
    if ( !jQuery.support.opacity ) {
    	jQuery.cssHooks.opacity = {
    		get: function( elem, computed ) {
    			// IE uses filters for opacity
    			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
    				( parseFloat( RegExp.$1 ) / 100 ) + "" :
    				computed ? "1" : "";
    		},
    
    		set: function( elem, value ) {
    			var style = elem.style,
    				currentStyle = elem.currentStyle,
    				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
    				filter = currentStyle && currentStyle.filter || style.filter || "";
    
    			// IE has trouble with opacity if it does not have layout
    			// Force it by setting the zoom level
    			style.zoom = 1;
    
    			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
    			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {
    
    				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
    				// if "filter:" is present at all, clearType is disabled, we want to avoid this
    				// style.removeAttribute is IE Only, but so apparently is this code path...
    				style.removeAttribute( "filter" );
    
    				// if there there is no filter style applied in a css rule, we are done
    				if ( currentStyle && !currentStyle.filter ) {
    					return;
    				}
    			}
    
    			// otherwise, set new filter values
    			style.filter = ralpha.test( filter ) ?
    				filter.replace( ralpha, opacity ) :
    				filter + " " + opacity;
    		}
    	};
    }
    
    jQuery(function() {
    	// This hook cannot be added until DOM ready because the support test
    	// for it is not run until after DOM ready
    	if ( !jQuery.support.reliableMarginRight ) {
    		jQuery.cssHooks.marginRight = {
    			get: function( elem, computed ) {
    				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
    				// Work around by temporarily setting element display to inline-block
    				var ret;
    				jQuery.swap( elem, { "display": "inline-block" }, function() {
    					if ( computed ) {
    						ret = curCSS( elem, "margin-right", "marginRight" );
    					} else {
    						ret = elem.style.marginRight;
    					}
    				});
    				return ret;
    			}
    		};
    	}
    });
    
    if ( document.defaultView && document.defaultView.getComputedStyle ) {
    	getComputedStyle = function( elem, name ) {
    		var ret, defaultView, computedStyle;
    
    		name = name.replace( rupper, "-$1" ).toLowerCase();
    
    		if ( (defaultView = elem.ownerDocument.defaultView) &&
    				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
    			ret = computedStyle.getPropertyValue( name );
    			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
    				ret = jQuery.style( elem, name );
    			}
    		}
    
    		return ret;
    	};
    }
    
    if ( document.documentElement.currentStyle ) {
    	currentStyle = function( elem, name ) {
    		var left, rsLeft, uncomputed,
    			ret = elem.currentStyle && elem.currentStyle[ name ],
    			style = elem.style;
    
    		// Avoid setting ret to empty string here
    		// so we don't default to auto
    		if ( ret === null && style && (uncomputed = style[ name ]) ) {
    			ret = uncomputed;
    		}
    
    		// From the awesome hack by Dean Edwards
    		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
    
    		// If we're not dealing with a regular pixel number
    		// but a number that has a weird ending, we need to convert it to pixels
    		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
    
    			// Remember the original values
    			left = style.left;
    			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
    
    			// Put in the new values to get a computed value out
    			if ( rsLeft ) {
    				elem.runtimeStyle.left = elem.currentStyle.left;
    			}
    			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
    			ret = style.pixelLeft + "px";
    
    			// Revert the changed values
    			style.left = left;
    			if ( rsLeft ) {
    				elem.runtimeStyle.left = rsLeft;
    			}
    		}
    
    		return ret === "" ? "auto" : ret;
    	};
    }
    
    curCSS = getComputedStyle || currentStyle;
    
    function getWH( elem, name, extra ) {
    
    	// Start with offset property
    	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    		which = name === "width" ? cssWidth : cssHeight,
    		i = 0,
    		len = which.length;
    
    	if ( val > 0 ) {
    		if ( extra !== "border" ) {
    			for ( ; i < len; i++ ) {
    				if ( !extra ) {
    					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
    				}
    				if ( extra === "margin" ) {
    					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
    				} else {
    					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
    				}
    			}
    		}
    
    		return val + "px";
    	}
    
    	// Fall back to computed then uncomputed css if necessary
    	val = curCSS( elem, name, name );
    	if ( val < 0 || val == null ) {
    		val = elem.style[ name ] || 0;
    	}
    	// Normalize "", auto, and prepare for extra
    	val = parseFloat( val ) || 0;
    
    	// Add padding, border, margin
    	if ( extra ) {
    		for ( ; i < len; i++ ) {
    			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
    			if ( extra !== "padding" ) {
    				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
    			}
    			if ( extra === "margin" ) {
    				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
    			}
    		}
    	}
    
    	return val + "px";
    }
    
    if ( jQuery.expr && jQuery.expr.filters ) {
    	jQuery.expr.filters.hidden = function( elem ) {
    		var width = elem.offsetWidth,
    			height = elem.offsetHeight;
    
    		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
    	};
    
    	jQuery.expr.filters.visible = function( elem ) {
    		return !jQuery.expr.filters.hidden( elem );
    	};
    }
    
    
    
    
    var r20 = /%20/g,
    	rbracket = /\[\]$/,
    	rCRLF = /\r?\n/g,
    	rhash = /#.*$/,
    	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
    	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    	// #7653, #8125, #8152: local protocol detection
    	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
    	rnoContent = /^(?:GET|HEAD)$/,
    	rprotocol = /^\/\//,
    	rquery = /\?/,
    	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    	rselectTextarea = /^(?:select|textarea)/i,
    	rspacesAjax = /\s+/,
    	rts = /([?&])_=[^&]*/,
    	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
    
    	// Keep a copy of the old load method
    	_load = jQuery.fn.load,
    
    	/* Prefilters
    	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    	 * 2) These are called:
    	 *    - BEFORE asking for a transport
    	 *    - AFTER param serialization (s.data is a string if s.processData is true)
    	 * 3) key is the dataType
    	 * 4) the catchall symbol "*" can be used
    	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    	 */
    	prefilters = {},
    
    	/* Transports bindings
    	 * 1) key is the dataType
    	 * 2) the catchall symbol "*" can be used
    	 * 3) selection will start with transport dataType and THEN go to "*" if needed
    	 */
    	transports = {},
    
    	// Document location
    	ajaxLocation,
    
    	// Document location segments
    	ajaxLocParts,
    
    	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    	allTypes = ["*/"] + ["*"];
    
    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
    	ajaxLocation = location.href;
    } catch( e ) {
    	// Use the href attribute of an A element
    	// since IE will modify it given document.location
    	ajaxLocation = document.createElement( "a" );
    	ajaxLocation.href = "";
    	ajaxLocation = ajaxLocation.href;
    }
    
    // Segment location into parts
    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
    
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {
    
    	// dataTypeExpression is optional and defaults to "*"
    	return function( dataTypeExpression, func ) {
    
    		if ( typeof dataTypeExpression !== "string" ) {
    			func = dataTypeExpression;
    			dataTypeExpression = "*";
    		}
    
    		if ( jQuery.isFunction( func ) ) {
    			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
    				i = 0,
    				length = dataTypes.length,
    				dataType,
    				list,
    				placeBefore;
    
    			// For each dataType in the dataTypeExpression
    			for ( ; i < length; i++ ) {
    				dataType = dataTypes[ i ];
    				// We control if we're asked to add before
    				// any existing element
    				placeBefore = /^\+/.test( dataType );
    				if ( placeBefore ) {
    					dataType = dataType.substr( 1 ) || "*";
    				}
    				list = structure[ dataType ] = structure[ dataType ] || [];
    				// then we add to the structure accordingly
    				list[ placeBefore ? "unshift" : "push" ]( func );
    			}
    		}
    	};
    }
    
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
    		dataType /* internal */, inspected /* internal */ ) {
    
    	dataType = dataType || options.dataTypes[ 0 ];
    	inspected = inspected || {};
    
    	inspected[ dataType ] = true;
    
    	var list = structure[ dataType ],
    		i = 0,
    		length = list ? list.length : 0,
    		executeOnly = ( structure === prefilters ),
    		selection;
    
    	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
    		selection = list[ i ]( options, originalOptions, jqXHR );
    		// If we got redirected to another dataType
    		// we try there if executing only and not done already
    		if ( typeof selection === "string" ) {
    			if ( !executeOnly || inspected[ selection ] ) {
    				selection = undefined;
    			} else {
    				options.dataTypes.unshift( selection );
    				selection = inspectPrefiltersOrTransports(
    						structure, options, originalOptions, jqXHR, selection, inspected );
    			}
    		}
    	}
    	// If we're only executing or nothing was selected
    	// we try the catchall dataType if not done already
    	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
    		selection = inspectPrefiltersOrTransports(
    				structure, options, originalOptions, jqXHR, "*", inspected );
    	}
    	// unnecessary when only executing (prefilters)
    	// but it'll be ignored by the caller in that case
    	return selection;
    }
    
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend( target, src ) {
    	var key, deep,
    		flatOptions = jQuery.ajaxSettings.flatOptions || {};
    	for ( key in src ) {
    		if ( src[ key ] !== undefined ) {
    			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    		}
    	}
    	if ( deep ) {
    		jQuery.extend( true, target, deep );
    	}
    }
    
    jQuery.fn.extend({
    	load: function( url, params, callback ) {
    		if ( typeof url !== "string" && _load ) {
    			return _load.apply( this, arguments );
    
    		// Don't do a request if no elements are being requested
    		} else if ( !this.length ) {
    			return this;
    		}
    
    		var off = url.indexOf( " " );
    		if ( off >= 0 ) {
    			var selector = url.slice( off, url.length );
    			url = url.slice( 0, off );
    		}
    
    		// Default to a GET request
    		var type = "GET";
    
    		// If the second parameter was provided
    		if ( params ) {
    			// If it's a function
    			if ( jQuery.isFunction( params ) ) {
    				// We assume that it's the callback
    				callback = params;
    				params = undefined;
    
    			// Otherwise, build a param string
    			} else if ( typeof params === "object" ) {
    				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
    				type = "POST";
    			}
    		}
    
    		var self = this;
    
    		// Request the remote document
    		jQuery.ajax({
    			url: url,
    			type: type,
    			dataType: "html",
    			data: params,
    			// Complete callback (responseText is used internally)
    			complete: function( jqXHR, status, responseText ) {
    				// Store the response as specified by the jqXHR object
    				responseText = jqXHR.responseText;
    				// If successful, inject the HTML into all the matched elements
    				if ( jqXHR.isResolved() ) {
    					// #4825: Get the actual response in case
    					// a dataFilter is present in ajaxSettings
    					jqXHR.done(function( r ) {
    						responseText = r;
    					});
    					// See if a selector was specified
    					self.html( selector ?
    						// Create a dummy div to hold the results
    						jQuery("<div>")
    							// inject the contents of the document in, removing the scripts
    							// to avoid any 'Permission Denied' errors in IE
    							.append(responseText.replace(rscript, ""))
    
    							// Locate the specified elements
    							.find(selector) :
    
    						// If not, just inject the full result
    						responseText );
    				}
    
    				if ( callback ) {
    					self.each( callback, [ responseText, status, jqXHR ] );
    				}
    			}
    		});
    
    		return this;
    	},
    
    	serialize: function() {
    		return jQuery.param( this.serializeArray() );
    	},
    
    	serializeArray: function() {
    		return this.map(function(){
    			return this.elements ? jQuery.makeArray( this.elements ) : this;
    		})
    		.filter(function(){
    			return this.name && !this.disabled &&
    				( this.checked || rselectTextarea.test( this.nodeName ) ||
    					rinput.test( this.type ) );
    		})
    		.map(function( i, elem ){
    			var val = jQuery( this ).val();
    
    			return val == null ?
    				null :
    				jQuery.isArray( val ) ?
    					jQuery.map( val, function( val, i ){
    						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    					}) :
    					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    		}).get();
    	}
    });
    
    // Attach a bunch of functions for handling common AJAX events
    jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
    	jQuery.fn[ o ] = function( f ){
    		return this.on( o, f );
    	};
    });
    
    jQuery.each( [ "get", "post" ], function( i, method ) {
    	jQuery[ method ] = function( url, data, callback, type ) {
    		// shift arguments if data argument was omitted
    		if ( jQuery.isFunction( data ) ) {
    			type = type || callback;
    			callback = data;
    			data = undefined;
    		}
    
    		return jQuery.ajax({
    			type: method,
    			url: url,
    			data: data,
    			success: callback,
    			dataType: type
    		});
    	};
    });
    
    jQuery.extend({
    
    	getScript: function( url, callback ) {
    		return jQuery.get( url, undefined, callback, "script" );
    	},
    
    	getJSON: function( url, data, callback ) {
    		return jQuery.get( url, data, callback, "json" );
    	},
    
    	// Creates a full fledged settings object into target
    	// with both ajaxSettings and settings fields.
    	// If target is omitted, writes into ajaxSettings.
    	ajaxSetup: function( target, settings ) {
    		if ( settings ) {
    			// Building a settings object
    			ajaxExtend( target, jQuery.ajaxSettings );
    		} else {
    			// Extending ajaxSettings
    			settings = target;
    			target = jQuery.ajaxSettings;
    		}
    		ajaxExtend( target, settings );
    		return target;
    	},
    
    	ajaxSettings: {
    		url: ajaxLocation,
    		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
    		global: true,
    		type: "GET",
    		contentType: "application/x-www-form-urlencoded",
    		processData: true,
    		async: true,
    		/*
    		timeout: 0,
    		data: null,
    		dataType: null,
    		username: null,
    		password: null,
    		cache: null,
    		traditional: false,
    		headers: {},
    		*/
    
    		accepts: {
    			xml: "application/xml, text/xml",
    			html: "text/html",
    			text: "text/plain",
    			json: "application/json, text/javascript",
    			"*": allTypes
    		},
    
    		contents: {
    			xml: /xml/,
    			html: /html/,
    			json: /json/
    		},
    
    		responseFields: {
    			xml: "responseXML",
    			text: "responseText"
    		},
    
    		// List of data converters
    		// 1) key format is "source_type destination_type" (a single space in-between)
    		// 2) the catchall symbol "*" can be used for source_type
    		converters: {
    
    			// Convert anything to text
    			"* text": window.String,
    
    			// Text to html (true = no transformation)
    			"text html": true,
    
    			// Evaluate text as a json expression
    			"text json": jQuery.parseJSON,
    
    			// Parse text as xml
    			"text xml": jQuery.parseXML
    		},
    
    		// For options that shouldn't be deep extended:
    		// you can add your own custom options here if
    		// and when you create one that shouldn't be
    		// deep extended (see ajaxExtend)
    		flatOptions: {
    			context: true,
    			url: true
    		}
    	},
    
    	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    	ajaxTransport: addToPrefiltersOrTransports( transports ),
    
    	// Main method
    	ajax: function( url, options ) {
    
    		// If url is an object, simulate pre-1.5 signature
    		if ( typeof url === "object" ) {
    			options = url;
    			url = undefined;
    		}
    
    		// Force options to be an object
    		options = options || {};
    
    		var // Create the final options object
    			s = jQuery.ajaxSetup( {}, options ),
    			// Callbacks context
    			callbackContext = s.context || s,
    			// Context for global events
    			// It's the callbackContext if one was provided in the options
    			// and if it's a DOM node or a jQuery collection
    			globalEventContext = callbackContext !== s &&
    				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
    						jQuery( callbackContext ) : jQuery.event,
    			// Deferreds
    			deferred = jQuery.Deferred(),
    			completeDeferred = jQuery.Callbacks( "once memory" ),
    			// Status-dependent callbacks
    			statusCode = s.statusCode || {},
    			// ifModified key
    			ifModifiedKey,
    			// Headers (they are sent all at once)
    			requestHeaders = {},
    			requestHeadersNames = {},
    			// Response headers
    			responseHeadersString,
    			responseHeaders,
    			// transport
    			transport,
    			// timeout handle
    			timeoutTimer,
    			// Cross-domain detection vars
    			parts,
    			// The jqXHR state
    			state = 0,
    			// To know if global events are to be dispatched
    			fireGlobals,
    			// Loop variable
    			i,
    			// Fake xhr
    			jqXHR = {
    
    				readyState: 0,
    
    				// Caches the header
    				setRequestHeader: function( name, value ) {
    					if ( !state ) {
    						var lname = name.toLowerCase();
    						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
    						requestHeaders[ name ] = value;
    					}
    					return this;
    				},
    
    				// Raw string
    				getAllResponseHeaders: function() {
    					return state === 2 ? responseHeadersString : null;
    				},
    
    				// Builds headers hashtable if needed
    				getResponseHeader: function( key ) {
    					var match;
    					if ( state === 2 ) {
    						if ( !responseHeaders ) {
    							responseHeaders = {};
    							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
    								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
    							}
    						}
    						match = responseHeaders[ key.toLowerCase() ];
    					}
    					return match === undefined ? null : match;
    				},
    
    				// Overrides response content-type header
    				overrideMimeType: function( type ) {
    					if ( !state ) {
    						s.mimeType = type;
    					}
    					return this;
    				},
    
    				// Cancel the request
    				abort: function( statusText ) {
    					statusText = statusText || "abort";
    					if ( transport ) {
    						transport.abort( statusText );
    					}
    					done( 0, statusText );
    					return this;
    				}
    			};
    
    		// Callback for when everything is done
    		// It is defined here because jslint complains if it is declared
    		// at the end of the function (which would be more logical and readable)
    		function done( status, nativeStatusText, responses, headers ) {
    
    			// Called once
    			if ( state === 2 ) {
    				return;
    			}
    
    			// State is "done" now
    			state = 2;
    
    			// Clear timeout if it exists
    			if ( timeoutTimer ) {
    				clearTimeout( timeoutTimer );
    			}
    
    			// Dereference transport for early garbage collection
    			// (no matter how long the jqXHR object will be used)
    			transport = undefined;
    
    			// Cache response headers
    			responseHeadersString = headers || "";
    
    			// Set readyState
    			jqXHR.readyState = status > 0 ? 4 : 0;
    
    			var isSuccess,
    				success,
    				error,
    				statusText = nativeStatusText,
    				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
    				lastModified,
    				etag;
    
    			// If successful, handle type chaining
    			if ( status >= 200 && status < 300 || status === 304 ) {
    
    				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    				if ( s.ifModified ) {
    
    					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
    						jQuery.lastModified[ ifModifiedKey ] = lastModified;
    					}
    					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
    						jQuery.etag[ ifModifiedKey ] = etag;
    					}
    				}
    
    				// If not modified
    				if ( status === 304 ) {
    
    					statusText = "notmodified";
    					isSuccess = true;
    
    				// If we have data
    				} else {
    
    					try {
    						success = ajaxConvert( s, response );
    						statusText = "success";
    						isSuccess = true;
    					} catch(e) {
    						// We have a parsererror
    						statusText = "parsererror";
    						error = e;
    					}
    				}
    			} else {
    				// We extract error from statusText
    				// then normalize statusText and status for non-aborts
    				error = statusText;
    				if ( !statusText || status ) {
    					statusText = "error";
    					if ( status < 0 ) {
    						status = 0;
    					}
    				}
    			}
    
    			// Set data for the fake xhr object
    			jqXHR.status = status;
    			jqXHR.statusText = "" + ( nativeStatusText || statusText );
    
    			// Success/Error
    			if ( isSuccess ) {
    				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
    			} else {
    				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
    			}
    
    			// Status-dependent callbacks
    			jqXHR.statusCode( statusCode );
    			statusCode = undefined;
    
    			if ( fireGlobals ) {
    				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
    						[ jqXHR, s, isSuccess ? success : error ] );
    			}
    
    			// Complete
    			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
    
    			if ( fireGlobals ) {
    				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
    				// Handle the global AJAX counter
    				if ( !( --jQuery.active ) ) {
    					jQuery.event.trigger( "ajaxStop" );
    				}
    			}
    		}
    
    		// Attach deferreds
    		deferred.promise( jqXHR );
    		jqXHR.success = jqXHR.done;
    		jqXHR.error = jqXHR.fail;
    		jqXHR.complete = completeDeferred.add;
    
    		// Status-dependent callbacks
    		jqXHR.statusCode = function( map ) {
    			if ( map ) {
    				var tmp;
    				if ( state < 2 ) {
    					for ( tmp in map ) {
    						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
    					}
    				} else {
    					tmp = map[ jqXHR.status ];
    					jqXHR.then( tmp, tmp );
    				}
    			}
    			return this;
    		};
    
    		// Remove hash character (#7531: and string promotion)
    		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
    		// We also use the url parameter if available
    		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
    
    		// Extract dataTypes list
    		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );
    
    		// Determine if a cross-domain request is in order
    		if ( s.crossDomain == null ) {
    			parts = rurl.exec( s.url.toLowerCase() );
    			s.crossDomain = !!( parts &&
    				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
    					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
    						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
    			);
    		}
    
    		// Convert data if not already a string
    		if ( s.data && s.processData && typeof s.data !== "string" ) {
    			s.data = jQuery.param( s.data, s.traditional );
    		}
    
    		// Apply prefilters
    		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
    
    		// If request was aborted inside a prefiler, stop there
    		if ( state === 2 ) {
    			return false;
    		}
    
    		// We can fire global events as of now if asked to
    		fireGlobals = s.global;
    
    		// Uppercase the type
    		s.type = s.type.toUpperCase();
    
    		// Determine if request has content
    		s.hasContent = !rnoContent.test( s.type );
    
    		// Watch for a new set of requests
    		if ( fireGlobals && jQuery.active++ === 0 ) {
    			jQuery.event.trigger( "ajaxStart" );
    		}
    
    		// More options handling for requests with no content
    		if ( !s.hasContent ) {
    
    			// If data is available, append data to url
    			if ( s.data ) {
    				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
    				// #9682: remove data so that it's not used in an eventual retry
    				delete s.data;
    			}
    
    			// Get ifModifiedKey before adding the anti-cache parameter
    			ifModifiedKey = s.url;
    
    			// Add anti-cache in url if needed
    			if ( s.cache === false ) {
    
    				var ts = jQuery.now(),
    					// try replacing _= if it is there
    					ret = s.url.replace( rts, "$1_=" + ts );
    
    				// if nothing was replaced, add timestamp to the end
    				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
    			}
    		}
    
    		// Set the correct header, if data is being sent
    		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
    			jqXHR.setRequestHeader( "Content-Type", s.contentType );
    		}
    
    		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    		if ( s.ifModified ) {
    			ifModifiedKey = ifModifiedKey || s.url;
    			if ( jQuery.lastModified[ ifModifiedKey ] ) {
    				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
    			}
    			if ( jQuery.etag[ ifModifiedKey ] ) {
    				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
    			}
    		}
    
    		// Set the Accepts header for the server, depending on the dataType
    		jqXHR.setRequestHeader(
    			"Accept",
    			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
    				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
    				s.accepts[ "*" ]
    		);
    
    		// Check for headers option
    		for ( i in s.headers ) {
    			jqXHR.setRequestHeader( i, s.headers[ i ] );
    		}
    
    		// Allow custom headers/mimetypes and early abort
    		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
    				// Abort if not done already
    				jqXHR.abort();
    				return false;
    
    		}
    
    		// Install callbacks on deferreds
    		for ( i in { success: 1, error: 1, complete: 1 } ) {
    			jqXHR[ i ]( s[ i ] );
    		}
    
    		// Get transport
    		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
    
    		// If no transport, we auto-abort
    		if ( !transport ) {
    			done( -1, "No Transport" );
    		} else {
    			jqXHR.readyState = 1;
    			// Send global event
    			if ( fireGlobals ) {
    				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
    			}
    			// Timeout
    			if ( s.async && s.timeout > 0 ) {
    				timeoutTimer = setTimeout( function(){
    					jqXHR.abort( "timeout" );
    				}, s.timeout );
    			}
    
    			try {
    				state = 1;
    				transport.send( requestHeaders, done );
    			} catch (e) {
    				// Propagate exception as error if not done
    				if ( state < 2 ) {
    					done( -1, e );
    				// Simply rethrow otherwise
    				} else {
    					throw e;
    				}
    			}
    		}
    
    		return jqXHR;
    	},
    
    	// Serialize an array of form elements or a set of
    	// key/values into a query string
    	param: function( a, traditional ) {
    		var s = [],
    			add = function( key, value ) {
    				// If value is a function, invoke it and return its value
    				value = jQuery.isFunction( value ) ? value() : value;
    				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
    			};
    
    		// Set traditional to true for jQuery <= 1.3.2 behavior.
    		if ( traditional === undefined ) {
    			traditional = jQuery.ajaxSettings.traditional;
    		}
    
    		// If an array was passed in, assume that it is an array of form elements.
    		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
    			// Serialize the form elements
    			jQuery.each( a, function() {
    				add( this.name, this.value );
    			});
    
    		} else {
    			// If traditional, encode the "old" way (the way 1.3.2 or older
    			// did it), otherwise encode params recursively.
    			for ( var prefix in a ) {
    				buildParams( prefix, a[ prefix ], traditional, add );
    			}
    		}
    
    		// Return the resulting serialization
    		return s.join( "&" ).replace( r20, "+" );
    	}
    });
    
    function buildParams( prefix, obj, traditional, add ) {
    	if ( jQuery.isArray( obj ) ) {
    		// Serialize array item.
    		jQuery.each( obj, function( i, v ) {
    			if ( traditional || rbracket.test( prefix ) ) {
    				// Treat each array item as a scalar.
    				add( prefix, v );
    
    			} else {
    				// If array item is non-scalar (array or object), encode its
    				// numeric index to resolve deserialization ambiguity issues.
    				// Note that rack (as of 1.0.0) can't currently deserialize
    				// nested arrays properly, and attempting to do so may cause
    				// a server error. Possible fixes are to modify rack's
    				// deserialization algorithm or to provide an option or flag
    				// to force array serialization to be shallow.
    				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
    			}
    		});
    
    	} else if ( !traditional && obj != null && typeof obj === "object" ) {
    		// Serialize object item.
    		for ( var name in obj ) {
    			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    		}
    
    	} else {
    		// Serialize scalar item.
    		add( prefix, obj );
    	}
    }
    
    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({
    
    	// Counter for holding the number of active queries
    	active: 0,
    
    	// Last-Modified header cache for next request
    	lastModified: {},
    	etag: {}
    
    });
    
    /* Handles responses to an ajax request:
     * - sets all responseXXX fields accordingly
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses( s, jqXHR, responses ) {
    
    	var contents = s.contents,
    		dataTypes = s.dataTypes,
    		responseFields = s.responseFields,
    		ct,
    		type,
    		finalDataType,
    		firstDataType;
    
    	// Fill responseXXX fields
    	for ( type in responseFields ) {
    		if ( type in responses ) {
    			jqXHR[ responseFields[type] ] = responses[ type ];
    		}
    	}
    
    	// Remove auto dataType and get content-type in the process
    	while( dataTypes[ 0 ] === "*" ) {
    		dataTypes.shift();
    		if ( ct === undefined ) {
    			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
    		}
    	}
    
    	// Check if we're dealing with a known content-type
    	if ( ct ) {
    		for ( type in contents ) {
    			if ( contents[ type ] && contents[ type ].test( ct ) ) {
    				dataTypes.unshift( type );
    				break;
    			}
    		}
    	}
    
    	// Check to see if we have a response for the expected dataType
    	if ( dataTypes[ 0 ] in responses ) {
    		finalDataType = dataTypes[ 0 ];
    	} else {
    		// Try convertible dataTypes
    		for ( type in responses ) {
    			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
    				finalDataType = type;
    				break;
    			}
    			if ( !firstDataType ) {
    				firstDataType = type;
    			}
    		}
    		// Or just use first one
    		finalDataType = finalDataType || firstDataType;
    	}
    
    	// If we found a dataType
    	// We add the dataType to the list if needed
    	// and return the corresponding response
    	if ( finalDataType ) {
    		if ( finalDataType !== dataTypes[ 0 ] ) {
    			dataTypes.unshift( finalDataType );
    		}
    		return responses[ finalDataType ];
    	}
    }
    
    // Chain conversions given the request and the original response
    function ajaxConvert( s, response ) {
    
    	// Apply the dataFilter if provided
    	if ( s.dataFilter ) {
    		response = s.dataFilter( response, s.dataType );
    	}
    
    	var dataTypes = s.dataTypes,
    		converters = {},
    		i,
    		key,
    		length = dataTypes.length,
    		tmp,
    		// Current and previous dataTypes
    		current = dataTypes[ 0 ],
    		prev,
    		// Conversion expression
    		conversion,
    		// Conversion function
    		conv,
    		// Conversion functions (transitive conversion)
    		conv1,
    		conv2;
    
    	// For each dataType in the chain
    	for ( i = 1; i < length; i++ ) {
    
    		// Create converters map
    		// with lowercased keys
    		if ( i === 1 ) {
    			for ( key in s.converters ) {
    				if ( typeof key === "string" ) {
    					converters[ key.toLowerCase() ] = s.converters[ key ];
    				}
    			}
    		}
    
    		// Get the dataTypes
    		prev = current;
    		current = dataTypes[ i ];
    
    		// If current is auto dataType, update it to prev
    		if ( current === "*" ) {
    			current = prev;
    		// If no auto and dataTypes are actually different
    		} else if ( prev !== "*" && prev !== current ) {
    
    			// Get the converter
    			conversion = prev + " " + current;
    			conv = converters[ conversion ] || converters[ "* " + current ];
    
    			// If there is no direct converter, search transitively
    			if ( !conv ) {
    				conv2 = undefined;
    				for ( conv1 in converters ) {
    					tmp = conv1.split( " " );
    					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
    						conv2 = converters[ tmp[1] + " " + current ];
    						if ( conv2 ) {
    							conv1 = converters[ conv1 ];
    							if ( conv1 === true ) {
    								conv = conv2;
    							} else if ( conv2 === true ) {
    								conv = conv1;
    							}
    							break;
    						}
    					}
    				}
    			}
    			// If we found no converter, dispatch an error
    			if ( !( conv || conv2 ) ) {
    				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
    			}
    			// If found converter is not an equivalence
    			if ( conv !== true ) {
    				// Convert with 1 or 2 converters accordingly
    				response = conv ? conv( response ) : conv2( conv1(response) );
    			}
    		}
    	}
    	return response;
    }
    
    
    
    
    var jsc = jQuery.now(),
    	jsre = /(\=)\?(&|$)|\?\?/i;
    
    // Default jsonp settings
    jQuery.ajaxSetup({
    	jsonp: "callback",
    	jsonpCallback: function() {
    		return jQuery.expando + "_" + ( jsc++ );
    	}
    });
    
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
    
    	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
    		( typeof s.data === "string" );
    
    	if ( s.dataTypes[ 0 ] === "jsonp" ||
    		s.jsonp !== false && ( jsre.test( s.url ) ||
    				inspectData && jsre.test( s.data ) ) ) {
    
    		var responseContainer,
    			jsonpCallback = s.jsonpCallback =
    				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
    			previous = window[ jsonpCallback ],
    			url = s.url,
    			data = s.data,
    			replace = "$1" + jsonpCallback + "$2";
    
    		if ( s.jsonp !== false ) {
    			url = url.replace( jsre, replace );
    			if ( s.url === url ) {
    				if ( inspectData ) {
    					data = data.replace( jsre, replace );
    				}
    				if ( s.data === data ) {
    					// Add callback manually
    					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
    				}
    			}
    		}
    
    		s.url = url;
    		s.data = data;
    
    		// Install callback
    		window[ jsonpCallback ] = function( response ) {
    			responseContainer = [ response ];
    		};
    
    		// Clean-up function
    		jqXHR.always(function() {
    			// Set callback back to previous value
    			window[ jsonpCallback ] = previous;
    			// Call if it was a function and we have a response
    			if ( responseContainer && jQuery.isFunction( previous ) ) {
    				window[ jsonpCallback ]( responseContainer[ 0 ] );
    			}
    		});
    
    		// Use data converter to retrieve json after script execution
    		s.converters["script json"] = function() {
    			if ( !responseContainer ) {
    				jQuery.error( jsonpCallback + " was not called" );
    			}
    			return responseContainer[ 0 ];
    		};
    
    		// force json dataType
    		s.dataTypes[ 0 ] = "json";
    
    		// Delegate to script
    		return "script";
    	}
    });
    
    
    
    
    // Install script dataType
    jQuery.ajaxSetup({
    	accepts: {
    		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    	},
    	contents: {
    		script: /javascript|ecmascript/
    	},
    	converters: {
    		"text script": function( text ) {
    			jQuery.globalEval( text );
    			return text;
    		}
    	}
    });
    
    // Handle cache's special case and global
    jQuery.ajaxPrefilter( "script", function( s ) {
    	if ( s.cache === undefined ) {
    		s.cache = false;
    	}
    	if ( s.crossDomain ) {
    		s.type = "GET";
    		s.global = false;
    	}
    });
    
    // Bind script tag hack transport
    jQuery.ajaxTransport( "script", function(s) {
    
    	// This transport only deals with cross domain requests
    	if ( s.crossDomain ) {
    
    		var script,
    			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
    
    		return {
    
    			send: function( _, callback ) {
    
    				script = document.createElement( "script" );
    
    				script.async = "async";
    
    				if ( s.scriptCharset ) {
    					script.charset = s.scriptCharset;
    				}
    
    				script.src = s.url;
    
    				// Attach handlers for all browsers
    				script.onload = script.onreadystatechange = function( _, isAbort ) {
    
    					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
    
    						// Handle memory leak in IE
    						script.onload = script.onreadystatechange = null;
    
    						// Remove the script
    						if ( head && script.parentNode ) {
    							head.removeChild( script );
    						}
    
    						// Dereference the script
    						script = undefined;
    
    						// Callback if not abort
    						if ( !isAbort ) {
    							callback( 200, "success" );
    						}
    					}
    				};
    				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
    				// This arises when a base node is used (#2709 and #4378).
    				head.insertBefore( script, head.firstChild );
    			},
    
    			abort: function() {
    				if ( script ) {
    					script.onload( 0, 1 );
    				}
    			}
    		};
    	}
    });
    
    
    
    
    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
    	xhrOnUnloadAbort = window.ActiveXObject ? function() {
    		// Abort all pending requests
    		for ( var key in xhrCallbacks ) {
    			xhrCallbacks[ key ]( 0, 1 );
    		}
    	} : false,
    	xhrId = 0,
    	xhrCallbacks;
    
    // Functions to create xhrs
    function createStandardXHR() {
    	try {
    		return new window.XMLHttpRequest();
    	} catch( e ) {}
    }
    
    function createActiveXHR() {
    	try {
    		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
    	} catch( e ) {}
    }
    
    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    	/* Microsoft failed to properly
    	 * implement the XMLHttpRequest in IE7 (can't request local files),
    	 * so we use the ActiveXObject when it is available
    	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
    	 * we need a fallback.
    	 */
    	function() {
    		return !this.isLocal && createStandardXHR() || createActiveXHR();
    	} :
    	// For all other browsers, use the standard XMLHttpRequest object
    	createStandardXHR;
    
    // Determine support properties
    (function( xhr ) {
    	jQuery.extend( jQuery.support, {
    		ajax: !!xhr,
    		cors: !!xhr && ( "withCredentials" in xhr )
    	});
    })( jQuery.ajaxSettings.xhr() );
    
    // Create transport if the browser can provide an xhr
    if ( jQuery.support.ajax ) {
    
    	jQuery.ajaxTransport(function( s ) {
    		// Cross domain only allowed if supported through XMLHttpRequest
    		if ( !s.crossDomain || jQuery.support.cors ) {
    
    			var callback;
    
    			return {
    				send: function( headers, complete ) {
    
    					// Get a new xhr
    					var xhr = s.xhr(),
    						handle,
    						i;
    
    					// Open the socket
    					// Passing null username, generates a login popup on Opera (#2865)
    					if ( s.username ) {
    						xhr.open( s.type, s.url, s.async, s.username, s.password );
    					} else {
    						xhr.open( s.type, s.url, s.async );
    					}
    
    					// Apply custom fields if provided
    					if ( s.xhrFields ) {
    						for ( i in s.xhrFields ) {
    							xhr[ i ] = s.xhrFields[ i ];
    						}
    					}
    
    					// Override mime type if needed
    					if ( s.mimeType && xhr.overrideMimeType ) {
    						xhr.overrideMimeType( s.mimeType );
    					}
    
    					// X-Requested-With header
    					// For cross-domain requests, seeing as conditions for a preflight are
    					// akin to a jigsaw puzzle, we simply never set it to be sure.
    					// (it can always be set on a per-request basis or even using ajaxSetup)
    					// For same-domain requests, won't change header if already provided.
    					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
    						headers[ "X-Requested-With" ] = "XMLHttpRequest";
    					}
    
    					// Need an extra try/catch for cross domain requests in Firefox 3
    					try {
    						for ( i in headers ) {
    							xhr.setRequestHeader( i, headers[ i ] );
    						}
    					} catch( _ ) {}
    
    					// Do send the request
    					// This may raise an exception which is actually
    					// handled in jQuery.ajax (so no try/catch here)
    					xhr.send( ( s.hasContent && s.data ) || null );
    
    					// Listener
    					callback = function( _, isAbort ) {
    
    						var status,
    							statusText,
    							responseHeaders,
    							responses,
    							xml;
    
    						// Firefox throws exceptions when accessing properties
    						// of an xhr when a network error occured
    						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
    						try {
    
    							// Was never called and is aborted or complete
    							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
    
    								// Only called once
    								callback = undefined;
    
    								// Do not keep as active anymore
    								if ( handle ) {
    									xhr.onreadystatechange = jQuery.noop;
    									if ( xhrOnUnloadAbort ) {
    										delete xhrCallbacks[ handle ];
    									}
    								}
    
    								// If it's an abort
    								if ( isAbort ) {
    									// Abort it manually if needed
    									if ( xhr.readyState !== 4 ) {
    										xhr.abort();
    									}
    								} else {
    									status = xhr.status;
    									responseHeaders = xhr.getAllResponseHeaders();
    									responses = {};
    									xml = xhr.responseXML;
    
    									// Construct response list
    									if ( xml && xml.documentElement /* #4958 */ ) {
    										responses.xml = xml;
    									}
    									responses.text = xhr.responseText;
    
    									// Firefox throws an exception when accessing
    									// statusText for faulty cross-domain requests
    									try {
    										statusText = xhr.statusText;
    									} catch( e ) {
    										// We normalize with Webkit giving an empty statusText
    										statusText = "";
    									}
    
    									// Filter status for non standard behaviors
    
    									// If the request is local and we have data: assume a success
    									// (success with no data won't get notified, that's the best we
    									// can do given current implementations)
    									if ( !status && s.isLocal && !s.crossDomain ) {
    										status = responses.text ? 200 : 404;
    									// IE - #1450: sometimes returns 1223 when it should be 204
    									} else if ( status === 1223 ) {
    										status = 204;
    									}
    								}
    							}
    						} catch( firefoxAccessException ) {
    							if ( !isAbort ) {
    								complete( -1, firefoxAccessException );
    							}
    						}
    
    						// Call complete if needed
    						if ( responses ) {
    							complete( status, statusText, responses, responseHeaders );
    						}
    					};
    
    					// if we're in sync mode or it's in cache
    					// and has been retrieved directly (IE6 & IE7)
    					// we need to manually fire the callback
    					if ( !s.async || xhr.readyState === 4 ) {
    						callback();
    					} else {
    						handle = ++xhrId;
    						if ( xhrOnUnloadAbort ) {
    							// Create the active xhrs callbacks list if needed
    							// and attach the unload handler
    							if ( !xhrCallbacks ) {
    								xhrCallbacks = {};
    								jQuery( window ).unload( xhrOnUnloadAbort );
    							}
    							// Add to list of active xhrs callbacks
    							xhrCallbacks[ handle ] = callback;
    						}
    						xhr.onreadystatechange = callback;
    					}
    				},
    
    				abort: function() {
    					if ( callback ) {
    						callback(0,1);
    					}
    				}
    			};
    		}
    	});
    }
    
    
    
    
    var elemdisplay = {},
    	iframe, iframeDoc,
    	rfxtypes = /^(?:toggle|show|hide)$/,
    	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
    	timerId,
    	fxAttrs = [
    		// height animations
    		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
    		// width animations
    		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
    		// opacity animations
    		[ "opacity" ]
    	],
    	fxNow;
    
    jQuery.fn.extend({
    	show: function( speed, easing, callback ) {
    		var elem, display;
    
    		if ( speed || speed === 0 ) {
    			return this.animate( genFx("show", 3), speed, easing, callback );
    
    		} else {
    			for ( var i = 0, j = this.length; i < j; i++ ) {
    				elem = this[ i ];
    
    				if ( elem.style ) {
    					display = elem.style.display;
    
    					// Reset the inline display of this element to learn if it is
    					// being hidden by cascaded rules or not
    					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
    						display = elem.style.display = "";
    					}
    
    					// Set elements which have been overridden with display: none
    					// in a stylesheet to whatever the default browser style is
    					// for such an element
    					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
    						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
    					}
    				}
    			}
    
    			// Set the display of most of the elements in a second loop
    			// to avoid the constant reflow
    			for ( i = 0; i < j; i++ ) {
    				elem = this[ i ];
    
    				if ( elem.style ) {
    					display = elem.style.display;
    
    					if ( display === "" || display === "none" ) {
    						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
    					}
    				}
    			}
    
    			return this;
    		}
    	},
    
    	hide: function( speed, easing, callback ) {
    		if ( speed || speed === 0 ) {
    			return this.animate( genFx("hide", 3), speed, easing, callback);
    
    		} else {
    			var elem, display,
    				i = 0,
    				j = this.length;
    
    			for ( ; i < j; i++ ) {
    				elem = this[i];
    				if ( elem.style ) {
    					display = jQuery.css( elem, "display" );
    
    					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
    						jQuery._data( elem, "olddisplay", display );
    					}
    				}
    			}
    
    			// Set the display of the elements in a second loop
    			// to avoid the constant reflow
    			for ( i = 0; i < j; i++ ) {
    				if ( this[i].style ) {
    					this[i].style.display = "none";
    				}
    			}
    
    			return this;
    		}
    	},
    
    	// Save the old toggle function
    	_toggle: jQuery.fn.toggle,
    
    	toggle: function( fn, fn2, callback ) {
    		var bool = typeof fn === "boolean";
    
    		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
    			this._toggle.apply( this, arguments );
    
    		} else if ( fn == null || bool ) {
    			this.each(function() {
    				var state = bool ? fn : jQuery(this).is(":hidden");
    				jQuery(this)[ state ? "show" : "hide" ]();
    			});
    
    		} else {
    			this.animate(genFx("toggle", 3), fn, fn2, callback);
    		}
    
    		return this;
    	},
    
    	fadeTo: function( speed, to, easing, callback ) {
    		return this.filter(":hidden").css("opacity", 0).show().end()
    					.animate({opacity: to}, speed, easing, callback);
    	},
    
    	animate: function( prop, speed, easing, callback ) {
    		var optall = jQuery.speed( speed, easing, callback );
    
    		if ( jQuery.isEmptyObject( prop ) ) {
    			return this.each( optall.complete, [ false ] );
    		}
    
    		// Do not change referenced properties as per-property easing will be lost
    		prop = jQuery.extend( {}, prop );
    
    		function doAnimation() {
    			// XXX 'this' does not always have a nodeName when running the
    			// test suite
    
    			if ( optall.queue === false ) {
    				jQuery._mark( this );
    			}
    
    			var opt = jQuery.extend( {}, optall ),
    				isElement = this.nodeType === 1,
    				hidden = isElement && jQuery(this).is(":hidden"),
    				name, val, p, e,
    				parts, start, end, unit,
    				method;
    
    			// will store per property easing and be used to determine when an animation is complete
    			opt.animatedProperties = {};
    
    			for ( p in prop ) {
    
    				// property name normalization
    				name = jQuery.camelCase( p );
    				if ( p !== name ) {
    					prop[ name ] = prop[ p ];
    					delete prop[ p ];
    				}
    
    				val = prop[ name ];
    
    				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
    				if ( jQuery.isArray( val ) ) {
    					opt.animatedProperties[ name ] = val[ 1 ];
    					val = prop[ name ] = val[ 0 ];
    				} else {
    					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
    				}
    
    				if ( val === "hide" && hidden || val === "show" && !hidden ) {
    					return opt.complete.call( this );
    				}
    
    				if ( isElement && ( name === "height" || name === "width" ) ) {
    					// Make sure that nothing sneaks out
    					// Record all 3 overflow attributes because IE does not
    					// change the overflow attribute when overflowX and
    					// overflowY are set to the same value
    					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];
    
    					// Set display property to inline-block for height/width
    					// animations on inline elements that are having width/height animated
    					if ( jQuery.css( this, "display" ) === "inline" &&
    							jQuery.css( this, "float" ) === "none" ) {
    
    						// inline-level elements accept inline-block;
    						// block-level elements need to be inline with layout
    						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
    							this.style.display = "inline-block";
    
    						} else {
    							this.style.zoom = 1;
    						}
    					}
    				}
    			}
    
    			if ( opt.overflow != null ) {
    				this.style.overflow = "hidden";
    			}
    
    			for ( p in prop ) {
    				e = new jQuery.fx( this, opt, p );
    				val = prop[ p ];
    
    				if ( rfxtypes.test( val ) ) {
    
    					// Tracks whether to show or hide based on private
    					// data attached to the element
    					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
    					if ( method ) {
    						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
    						e[ method ]();
    					} else {
    						e[ val ]();
    					}
    
    				} else {
    					parts = rfxnum.exec( val );
    					start = e.cur();
    
    					if ( parts ) {
    						end = parseFloat( parts[2] );
    						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );
    
    						// We need to compute starting value
    						if ( unit !== "px" ) {
    							jQuery.style( this, p, (end || 1) + unit);
    							start = ( (end || 1) / e.cur() ) * start;
    							jQuery.style( this, p, start + unit);
    						}
    
    						// If a +=/-= token was provided, we're doing a relative animation
    						if ( parts[1] ) {
    							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
    						}
    
    						e.custom( start, end, unit );
    
    					} else {
    						e.custom( start, val, "" );
    					}
    				}
    			}
    
    			// For JS strict compliance
    			return true;
    		}
    
    		return optall.queue === false ?
    			this.each( doAnimation ) :
    			this.queue( optall.queue, doAnimation );
    	},
    
    	stop: function( type, clearQueue, gotoEnd ) {
    		if ( typeof type !== "string" ) {
    			gotoEnd = clearQueue;
    			clearQueue = type;
    			type = undefined;
    		}
    		if ( clearQueue && type !== false ) {
    			this.queue( type || "fx", [] );
    		}
    
    		return this.each(function() {
    			var index,
    				hadTimers = false,
    				timers = jQuery.timers,
    				data = jQuery._data( this );
    
    			// clear marker counters if we know they won't be
    			if ( !gotoEnd ) {
    				jQuery._unmark( true, this );
    			}
    
    			function stopQueue( elem, data, index ) {
    				var hooks = data[ index ];
    				jQuery.removeData( elem, index, true );
    				hooks.stop( gotoEnd );
    			}
    
    			if ( type == null ) {
    				for ( index in data ) {
    					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
    						stopQueue( this, data, index );
    					}
    				}
    			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
    				stopQueue( this, data, index );
    			}
    
    			for ( index = timers.length; index--; ) {
    				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
    					if ( gotoEnd ) {
    
    						// force the next step to be the last
    						timers[ index ]( true );
    					} else {
    						timers[ index ].saveState();
    					}
    					hadTimers = true;
    					timers.splice( index, 1 );
    				}
    			}
    
    			// start the next in the queue if the last step wasn't forced
    			// timers currently will call their complete callbacks, which will dequeue
    			// but only if they were gotoEnd
    			if ( !( gotoEnd && hadTimers ) ) {
    				jQuery.dequeue( this, type );
    			}
    		});
    	}
    
    });
    
    // Animations created synchronously will run synchronously
    function createFxNow() {
    	setTimeout( clearFxNow, 0 );
    	return ( fxNow = jQuery.now() );
    }
    
    function clearFxNow() {
    	fxNow = undefined;
    }
    
    // Generate parameters to create a standard animation
    function genFx( type, num ) {
    	var obj = {};
    
    	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
    		obj[ this ] = type;
    	});
    
    	return obj;
    }
    
    // Generate shortcuts for custom animations
    jQuery.each({
    	slideDown: genFx( "show", 1 ),
    	slideUp: genFx( "hide", 1 ),
    	slideToggle: genFx( "toggle", 1 ),
    	fadeIn: { opacity: "show" },
    	fadeOut: { opacity: "hide" },
    	fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
    	jQuery.fn[ name ] = function( speed, easing, callback ) {
    		return this.animate( props, speed, easing, callback );
    	};
    });
    
    jQuery.extend({
    	speed: function( speed, easing, fn ) {
    		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    			complete: fn || !fn && easing ||
    				jQuery.isFunction( speed ) && speed,
    			duration: speed,
    			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    		};
    
    		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
    			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
    
    		// normalize opt.queue - true/undefined/null -> "fx"
    		if ( opt.queue == null || opt.queue === true ) {
    			opt.queue = "fx";
    		}
    
    		// Queueing
    		opt.old = opt.complete;
    
    		opt.complete = function( noUnmark ) {
    			if ( jQuery.isFunction( opt.old ) ) {
    				opt.old.call( this );
    			}
    
    			if ( opt.queue ) {
    				jQuery.dequeue( this, opt.queue );
    			} else if ( noUnmark !== false ) {
    				jQuery._unmark( this );
    			}
    		};
    
    		return opt;
    	},
    
    	easing: {
    		linear: function( p, n, firstNum, diff ) {
    			return firstNum + diff * p;
    		},
    		swing: function( p, n, firstNum, diff ) {
    			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
    		}
    	},
    
    	timers: [],
    
    	fx: function( elem, options, prop ) {
    		this.options = options;
    		this.elem = elem;
    		this.prop = prop;
    
    		options.orig = options.orig || {};
    	}
    
    });
    
    jQuery.fx.prototype = {
    	// Simple function for setting a style value
    	update: function() {
    		if ( this.options.step ) {
    			this.options.step.call( this.elem, this.now, this );
    		}
    
    		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
    	},
    
    	// Get the current size
    	cur: function() {
    		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
    			return this.elem[ this.prop ];
    		}
    
    		var parsed,
    			r = jQuery.css( this.elem, this.prop );
    		// Empty strings, null, undefined and "auto" are converted to 0,
    		// complex values such as "rotate(1rad)" are returned as is,
    		// simple values such as "10px" are parsed to Float.
    		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
    	},
    
    	// Start an animation from one number to another
    	custom: function( from, to, unit ) {
    		var self = this,
    			fx = jQuery.fx;
    
    		this.startTime = fxNow || createFxNow();
    		this.end = to;
    		this.now = this.start = from;
    		this.pos = this.state = 0;
    		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
    
    		function t( gotoEnd ) {
    			return self.step( gotoEnd );
    		}
    
    		t.queue = this.options.queue;
    		t.elem = this.elem;
    		t.saveState = function() {
    			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
    				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
    			}
    		};
    
    		if ( t() && jQuery.timers.push(t) && !timerId ) {
    			timerId = setInterval( fx.tick, fx.interval );
    		}
    	},
    
    	// Simple 'show' function
    	show: function() {
    		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );
    
    		// Remember where we started, so that we can go back to it later
    		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
    		this.options.show = true;
    
    		// Begin the animation
    		// Make sure that we start at a small width/height to avoid any flash of content
    		if ( dataShow !== undefined ) {
    			// This show is picking up where a previous hide or show left off
    			this.custom( this.cur(), dataShow );
    		} else {
    			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
    		}
    
    		// Start by showing the element
    		jQuery( this.elem ).show();
    	},
    
    	// Simple 'hide' function
    	hide: function() {
    		// Remember where we started, so that we can go back to it later
    		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
    		this.options.hide = true;
    
    		// Begin the animation
    		this.custom( this.cur(), 0 );
    	},
    
    	// Each step of an animation
    	step: function( gotoEnd ) {
    		var p, n, complete,
    			t = fxNow || createFxNow(),
    			done = true,
    			elem = this.elem,
    			options = this.options;
    
    		if ( gotoEnd || t >= options.duration + this.startTime ) {
    			this.now = this.end;
    			this.pos = this.state = 1;
    			this.update();
    
    			options.animatedProperties[ this.prop ] = true;
    
    			for ( p in options.animatedProperties ) {
    				if ( options.animatedProperties[ p ] !== true ) {
    					done = false;
    				}
    			}
    
    			if ( done ) {
    				// Reset the overflow
    				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
    
    					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
    						elem.style[ "overflow" + value ] = options.overflow[ index ];
    					});
    				}
    
    				// Hide the element if the "hide" operation was done
    				if ( options.hide ) {
    					jQuery( elem ).hide();
    				}
    
    				// Reset the properties, if the item has been hidden or shown
    				if ( options.hide || options.show ) {
    					for ( p in options.animatedProperties ) {
    						jQuery.style( elem, p, options.orig[ p ] );
    						jQuery.removeData( elem, "fxshow" + p, true );
    						// Toggle data is no longer needed
    						jQuery.removeData( elem, "toggle" + p, true );
    					}
    				}
    
    				// Execute the complete function
    				// in the event that the complete function throws an exception
    				// we must ensure it won't be called twice. #5684
    
    				complete = options.complete;
    				if ( complete ) {
    
    					options.complete = false;
    					complete.call( elem );
    				}
    			}
    
    			return false;
    
    		} else {
    			// classical easing cannot be used with an Infinity duration
    			if ( options.duration == Infinity ) {
    				this.now = t;
    			} else {
    				n = t - this.startTime;
    				this.state = n / options.duration;
    
    				// Perform the easing function, defaults to swing
    				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
    				this.now = this.start + ( (this.end - this.start) * this.pos );
    			}
    			// Perform the next step of the animation
    			this.update();
    		}
    
    		return true;
    	}
    };
    
    jQuery.extend( jQuery.fx, {
    	tick: function() {
    		var timer,
    			timers = jQuery.timers,
    			i = 0;
    
    		for ( ; i < timers.length; i++ ) {
    			timer = timers[ i ];
    			// Checks the timer has not already been removed
    			if ( !timer() && timers[ i ] === timer ) {
    				timers.splice( i--, 1 );
    			}
    		}
    
    		if ( !timers.length ) {
    			jQuery.fx.stop();
    		}
    	},
    
    	interval: 13,
    
    	stop: function() {
    		clearInterval( timerId );
    		timerId = null;
    	},
    
    	speeds: {
    		slow: 600,
    		fast: 200,
    		// Default speed
    		_default: 400
    	},
    
    	step: {
    		opacity: function( fx ) {
    			jQuery.style( fx.elem, "opacity", fx.now );
    		},
    
    		_default: function( fx ) {
    			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
    				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
    			} else {
    				fx.elem[ fx.prop ] = fx.now;
    			}
    		}
    	}
    });
    
    // Adds width/height step functions
    // Do not set anything below 0
    jQuery.each([ "width", "height" ], function( i, prop ) {
    	jQuery.fx.step[ prop ] = function( fx ) {
    		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
    	};
    });
    
    if ( jQuery.expr && jQuery.expr.filters ) {
    	jQuery.expr.filters.animated = function( elem ) {
    		return jQuery.grep(jQuery.timers, function( fn ) {
    			return elem === fn.elem;
    		}).length;
    	};
    }
    
    // Try to restore the default display value of an element
    function defaultDisplay( nodeName ) {
    
    	if ( !elemdisplay[ nodeName ] ) {
    
    		var body = document.body,
    			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
    			display = elem.css( "display" );
    		elem.remove();
    
    		// If the simple way fails,
    		// get element's real default display by attaching it to a temp iframe
    		if ( display === "none" || display === "" ) {
    			// No iframe to use yet, so create it
    			if ( !iframe ) {
    				iframe = document.createElement( "iframe" );
    				iframe.frameBorder = iframe.width = iframe.height = 0;
    			}
    
    			body.appendChild( iframe );
    
    			// Create a cacheable copy of the iframe document on first call.
    			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
    			// document to it; WebKit & Firefox won't allow reusing the iframe document.
    			if ( !iframeDoc || !iframe.createElement ) {
    				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
    				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
    				iframeDoc.close();
    			}
    
    			elem = iframeDoc.createElement( nodeName );
    
    			iframeDoc.body.appendChild( elem );
    
    			display = jQuery.css( elem, "display" );
    			body.removeChild( iframe );
    		}
    
    		// Store the correct default display
    		elemdisplay[ nodeName ] = display;
    	}
    
    	return elemdisplay[ nodeName ];
    }
    
    
    
    
    var rtable = /^t(?:able|d|h)$/i,
    	rroot = /^(?:body|html)$/i;
    
    if ( "getBoundingClientRect" in document.documentElement ) {
    	jQuery.fn.offset = function( options ) {
    		var elem = this[0], box;
    
    		if ( options ) {
    			return this.each(function( i ) {
    				jQuery.offset.setOffset( this, options, i );
    			});
    		}
    
    		if ( !elem || !elem.ownerDocument ) {
    			return null;
    		}
    
    		if ( elem === elem.ownerDocument.body ) {
    			return jQuery.offset.bodyOffset( elem );
    		}
    
    		try {
    			box = elem.getBoundingClientRect();
    		} catch(e) {}
    
    		var doc = elem.ownerDocument,
    			docElem = doc.documentElement;
    
    		// Make sure we're not dealing with a disconnected DOM node
    		if ( !box || !jQuery.contains( docElem, elem ) ) {
    			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
    		}
    
    		var body = doc.body,
    			win = getWindow(doc),
    			clientTop  = docElem.clientTop  || body.clientTop  || 0,
    			clientLeft = docElem.clientLeft || body.clientLeft || 0,
    			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
    			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
    			top  = box.top  + scrollTop  - clientTop,
    			left = box.left + scrollLeft - clientLeft;
    
    		return { top: top, left: left };
    	};
    
    } else {
    	jQuery.fn.offset = function( options ) {
    		var elem = this[0];
    
    		if ( options ) {
    			return this.each(function( i ) {
    				jQuery.offset.setOffset( this, options, i );
    			});
    		}
    
    		if ( !elem || !elem.ownerDocument ) {
    			return null;
    		}
    
    		if ( elem === elem.ownerDocument.body ) {
    			return jQuery.offset.bodyOffset( elem );
    		}
    
    		var computedStyle,
    			offsetParent = elem.offsetParent,
    			prevOffsetParent = elem,
    			doc = elem.ownerDocument,
    			docElem = doc.documentElement,
    			body = doc.body,
    			defaultView = doc.defaultView,
    			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
    			top = elem.offsetTop,
    			left = elem.offsetLeft;
    
    		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
    			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
    				break;
    			}
    
    			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
    			top  -= elem.scrollTop;
    			left -= elem.scrollLeft;
    
    			if ( elem === offsetParent ) {
    				top  += elem.offsetTop;
    				left += elem.offsetLeft;
    
    				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
    					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
    					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
    				}
    
    				prevOffsetParent = offsetParent;
    				offsetParent = elem.offsetParent;
    			}
    
    			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
    				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
    				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
    			}
    
    			prevComputedStyle = computedStyle;
    		}
    
    		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
    			top  += body.offsetTop;
    			left += body.offsetLeft;
    		}
    
    		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
    			top  += Math.max( docElem.scrollTop, body.scrollTop );
    			left += Math.max( docElem.scrollLeft, body.scrollLeft );
    		}
    
    		return { top: top, left: left };
    	};
    }
    
    jQuery.offset = {
    
    	bodyOffset: function( body ) {
    		var top = body.offsetTop,
    			left = body.offsetLeft;
    
    		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
    			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
    			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
    		}
    
    		return { top: top, left: left };
    	},
    
    	setOffset: function( elem, options, i ) {
    		var position = jQuery.css( elem, "position" );
    
    		// set position first, in-case top/left are set even on static elem
    		if ( position === "static" ) {
    			elem.style.position = "relative";
    		}
    
    		var curElem = jQuery( elem ),
    			curOffset = curElem.offset(),
    			curCSSTop = jQuery.css( elem, "top" ),
    			curCSSLeft = jQuery.css( elem, "left" ),
    			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
    			props = {}, curPosition = {}, curTop, curLeft;
    
    		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
    		if ( calculatePosition ) {
    			curPosition = curElem.position();
    			curTop = curPosition.top;
    			curLeft = curPosition.left;
    		} else {
    			curTop = parseFloat( curCSSTop ) || 0;
    			curLeft = parseFloat( curCSSLeft ) || 0;
    		}
    
    		if ( jQuery.isFunction( options ) ) {
    			options = options.call( elem, i, curOffset );
    		}
    
    		if ( options.top != null ) {
    			props.top = ( options.top - curOffset.top ) + curTop;
    		}
    		if ( options.left != null ) {
    			props.left = ( options.left - curOffset.left ) + curLeft;
    		}
    
    		if ( "using" in options ) {
    			options.using.call( elem, props );
    		} else {
    			curElem.css( props );
    		}
    	}
    };
    
    
    jQuery.fn.extend({
    
    	position: function() {
    		if ( !this[0] ) {
    			return null;
    		}
    
    		var elem = this[0],
    
    		// Get *real* offsetParent
    		offsetParent = this.offsetParent(),
    
    		// Get correct offsets
    		offset       = this.offset(),
    		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
    
    		// Subtract element margins
    		// note: when an element has margin: auto the offsetLeft and marginLeft
    		// are the same in Safari causing offset.left to incorrectly be 0
    		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
    		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;
    
    		// Add offsetParent borders
    		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
    		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;
    
    		// Subtract the two offsets
    		return {
    			top:  offset.top  - parentOffset.top,
    			left: offset.left - parentOffset.left
    		};
    	},
    
    	offsetParent: function() {
    		return this.map(function() {
    			var offsetParent = this.offsetParent || document.body;
    			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
    				offsetParent = offsetParent.offsetParent;
    			}
    			return offsetParent;
    		});
    	}
    });
    
    
    // Create scrollLeft and scrollTop methods
    jQuery.each( ["Left", "Top"], function( i, name ) {
    	var method = "scroll" + name;
    
    	jQuery.fn[ method ] = function( val ) {
    		var elem, win;
    
    		if ( val === undefined ) {
    			elem = this[ 0 ];
    
    			if ( !elem ) {
    				return null;
    			}
    
    			win = getWindow( elem );
    
    			// Return the scroll offset
    			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
    				jQuery.support.boxModel && win.document.documentElement[ method ] ||
    					win.document.body[ method ] :
    				elem[ method ];
    		}
    
    		// Set the scroll offset
    		return this.each(function() {
    			win = getWindow( this );
    
    			if ( win ) {
    				win.scrollTo(
    					!i ? val : jQuery( win ).scrollLeft(),
    					 i ? val : jQuery( win ).scrollTop()
    				);
    
    			} else {
    				this[ method ] = val;
    			}
    		});
    	};
    });
    
    function getWindow( elem ) {
    	return jQuery.isWindow( elem ) ?
    		elem :
    		elem.nodeType === 9 ?
    			elem.defaultView || elem.parentWindow :
    			false;
    }
    
    
    
    
    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each([ "Height", "Width" ], function( i, name ) {
    
    	var type = name.toLowerCase();
    
    	// innerHeight and innerWidth
    	jQuery.fn[ "inner" + name ] = function() {
    		var elem = this[0];
    		return elem ?
    			elem.style ?
    			parseFloat( jQuery.css( elem, type, "padding" ) ) :
    			this[ type ]() :
    			null;
    	};
    
    	// outerHeight and outerWidth
    	jQuery.fn[ "outer" + name ] = function( margin ) {
    		var elem = this[0];
    		return elem ?
    			elem.style ?
    			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
    			this[ type ]() :
    			null;
    	};
    
    	jQuery.fn[ type ] = function( size ) {
    		// Get window width or height
    		var elem = this[0];
    		if ( !elem ) {
    			return size == null ? null : this;
    		}
    
    		if ( jQuery.isFunction( size ) ) {
    			return this.each(function( i ) {
    				var self = jQuery( this );
    				self[ type ]( size.call( this, i, self[ type ]() ) );
    			});
    		}
    
    		if ( jQuery.isWindow( elem ) ) {
    			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
    			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
    			var docElemProp = elem.document.documentElement[ "client" + name ],
    				body = elem.document.body;
    			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
    				body && body[ "client" + name ] || docElemProp;
    
    		// Get document width or height
    		} else if ( elem.nodeType === 9 ) {
    			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
    			return Math.max(
    				elem.documentElement["client" + name],
    				elem.body["scroll" + name], elem.documentElement["scroll" + name],
    				elem.body["offset" + name], elem.documentElement["offset" + name]
    			);
    
    		// Get or set width or height on the element
    		} else if ( size === undefined ) {
    			var orig = jQuery.css( elem, type ),
    				ret = parseFloat( orig );
    
    			return jQuery.isNumeric( ret ) ? ret : orig;
    
    		// Set the width or height on the element (default to pixels if value is unitless)
    		} else {
    			return this.css( type, typeof size === "string" ? size : size + "px" );
    		}
    	};
    
    });
    
    
    
    
    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;
    
    // Expose jQuery as an AMD module, but only for AMD loaders that
    // understand the issues with loading multiple versions of jQuery
    // in a page that all might call define(). The loader will indicate
    // they have special allowances for multiple jQuery versions by
    // specifying define.amd.jQuery = true. Register as a named module,
    // since jQuery can be concatenated with other files that may use define,
    // but not use a proper concatenation script that understands anonymous
    // AMD modules. A named AMD is safest and most robust way to register.
    // Lowercase jquery is used because AMD module names are derived from
    // file names, and jQuery is normally delivered in a lowercase file name.
    // Do this after creating the global so that if an AMD module wants to call
    // noConflict to hide this version of jQuery, it will work.
    if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
    	define( "jquery", [], function () { return jQuery; } );
    }
    
    
    
    })( window );

    return noConflictMode ? window.jQuery.noConflict(true) : window.jQuery;
  };

  // For CommonJS
  if (typeof module !== 'undefined') {
    if (typeof window !== 'undefined') {
      module.exports = create(window, true);
    }
    module.exports.create = create;

  // For non-CommonJS
  } else {
    create(window, false);
  }

}());

}).call(this);}
});


/*ZB:  */
require.define('', {

/*ZB:  /jquery */
'jquery': function(exports, require, module) {(function() {
(function() {
  module.exports = require('commonjs-jquery');

}).call(this);

}).call(this);}
});

/*ZB:  jquery-compat */
(function() {
  window.jQuery = require('jquery');

}).call(this);
;

/*ZB:  jquery-cookie */
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};;


/*ZB: UserQuestion */
require.define('UserQuestion', {

/*ZB:  UserQuestion/index */
'index': function(exports, require, module) {(function() {
(function() {
  var $, CSLib, MESSAGE_S, PopupExtend, SUCCESS_MESSAGE, Spine, UserQuestion, UserQuestionModel, popup_params, replace_map,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  UserQuestionModel = require('models/UserQuestionModel');

  PopupExtend = require('CSLib/lib/popup_extend');

  MESSAGE_S = '.js-message';

  SUCCESS_MESSAGE = 'Ваш запрос отправлен.\n</br> Служба поддержки свяжется с вами в ближайшее время.';

  popup_params = {
    z_index: 10000002,
    orientation: "E",
    is_popup_hint: false
  };

  Spine = require('spine');

  $ = require('jquery');

  CSLib = require('CSLib');

  $.ajaxSetup({
    beforeSend: function(xhr, settings) {
      return xhr.setRequestHeader("X-CSRFToken", $.cookie('_csrf_token'));
    }
  });

  replace_map = {
    first_name: "#first_name_line",
    email: "#email_line"
  };

  UserQuestion = (function(superClass) {
    extend(UserQuestion, superClass);

    UserQuestion.include(PopupExtend);

    function UserQuestion(el) {
      this.el = el;
      this.submit_handler = bind(this.submit_handler, this);
      UserQuestion.__super__.constructor.apply(this, arguments);
      this.data = this.el.data();
      this.host = this.data.host;
      this._get_user_info(this.data);
      this.el.submit(this.submit_handler);
      this.is_sent = false;
    }

    UserQuestion.prototype.submit_handler = function(ev) {
      var user_question;
      ev.preventDefault();
      user_question = UserQuestionModel.fromForm(this.el);
      if (!this.is_sent) {
        this.is_sent = true;
        this.save(this.host, user_question, (function(_this) {
          return function(errors) {
            if (errors) {
              return _this.show_popups(_this.el, errors, popup_params, replace_map);
            } else {
              return _this.show_message(SUCCESS_MESSAGE);
            }
          };
        })(this));
      }
      return false;
    };

    UserQuestion.prototype.save = function(url, question, cb) {
      return $.ajax({
        type: 'POST',
        url: url,
        data: question.toJSON(),
        success: function(data, status, xhr) {
          return typeof cb === "function" ? cb() : void 0;
        },
        error: function(xhr, status, error) {
          console.log(JSON.parse(xhr.responseText));
          return typeof cb === "function" ? cb(JSON.parse(xhr.responseText)) : void 0;
        }
      });
    };

    UserQuestion.prototype._get_user_info = function(arg) {
      var users_auth_info_url;
      users_auth_info_url = arg.users_auth_info_url;
      return CSLib.AUTOIO.GET("" + users_auth_info_url, (function(_this) {
        return function(data) {
          _this.el.find("[name='username']").val(data.name);
          return _this.el.find("[name='email']").val(data.email);
        };
      })(this));
    };

    UserQuestion.prototype.show_message = function(message, type) {
      if (type == null) {
        type = 'info';
      }
      return $(MESSAGE_S).html(require('views/mail_message')({
        message: message
      }));
    };

    return UserQuestion;

  })(Spine.Controller);

  module.exports = UserQuestion;

}).call(this);

}).call(this);},

/*ZB:  UserQuestion/models/UserQuestionModel */
'models/UserQuestionModel': function(exports, require, module) {(function() {
(function() {
  var Spine, TransportExtend, UserQuestion,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  TransportExtend = require('CSLib/lib/model_extender');

  UserQuestion = (function(superClass) {
    extend(UserQuestion, superClass);

    function UserQuestion() {
      return UserQuestion.__super__.constructor.apply(this, arguments);
    }

    UserQuestion.configure('UserQuestion', 'username', 'email', 'question');

    UserQuestion.extend(TransportExtend);

    return UserQuestion;

  })(Spine.Model);

  module.exports = UserQuestion;

}).call(this);

}).call(this);},

/*ZB:  UserQuestion/views/mail_message */
'views/mail_message': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      __out.push('<div class="fancy-hint" style="width:338px">\n      ');
    
      __out.push(this.message);
    
      __out.push('\n</div>');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);}
});

/*ZB:  jqueryui */
/*!
 * jQuery UI 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(c,j){function k(a,b){var d=a.nodeName.toLowerCase();if("area"===d){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!=="map")return false;a=c("img[usemap=#"+d+"]")[0];return!!a&&l(a)}return(/input|select|textarea|button|object/.test(d)?!a.disabled:"a"==d?a.href||b:b)&&l(a)}function l(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,"visibility")==="hidden"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:"1.8.14",
keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({_focus:c.fn.focus,focus:function(a,b){return typeof a==="number"?this.each(function(){var d=this;setTimeout(function(){c(d).focus();
b&&b.call(d)},a)}):this._focus.apply(this,arguments)},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this,"position",1))&&/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,
"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css("zIndex",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css("position");if(b==="absolute"||b==="relative"||b==="fixed"){b=parseInt(a.css("zIndex"),10);if(!isNaN(b)&&b!==0)return b}a=a.parent()}}return 0},disableSelection:function(){return this.bind((c.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",
function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}});c.each(["Width","Height"],function(a,b){function d(f,g,m,n){c.each(e,function(){g-=parseFloat(c.curCSS(f,"padding"+this,true))||0;if(m)g-=parseFloat(c.curCSS(f,"border"+this+"Width",true))||0;if(n)g-=parseFloat(c.curCSS(f,"margin"+this,true))||0});return g}var e=b==="Width"?["Left","Right"]:["Top","Bottom"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,outerWidth:c.fn.outerWidth,
outerHeight:c.fn.outerHeight};c.fn["inner"+b]=function(f){if(f===j)return i["inner"+b].call(this);return this.each(function(){c(this).css(h,d(this,f)+"px")})};c.fn["outer"+b]=function(f,g){if(typeof f!=="number")return i["outer"+b].call(this,f);return this.each(function(){c(this).css(h,d(this,f,true,g)+"px")})}});c.extend(c.expr[":"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){return k(a,!isNaN(c.attr(a,"tabindex")))},tabbable:function(a){var b=c.attr(a,"tabindex"),d=isNaN(b);
return(d||b>=0)&&k(a,!d)}});c(function(){var a=document.body,b=a.appendChild(b=document.createElement("div"));c.extend(b.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0});c.support.minHeight=b.offsetHeight===100;c.support.selectstart="onselectstart"in b;a.removeChild(b).style.display="none"});c.extend(c.ui,{plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&a.element[0].parentNode)for(var e=
0;e<b.length;e++)a.options[b[e][0]]&&b[e][1].apply(a.element,d)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(a,b){if(c(a).css("overflow")==="hidden")return false;b=b&&b==="left"?"scrollLeft":"scrollTop";var d=false;if(a[b]>0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a<b+d},isOver:function(a,b,d,e,h,i){return c.ui.isOverAxis(a,d,h)&&c.ui.isOverAxis(b,e,i)}})}})(jQuery);
;/*!
 * jQuery UI Widget 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(b,j){if(b.cleanData){var k=b.cleanData;b.cleanData=function(a){for(var c=0,d;(d=a[c])!=null;c++)b(d).triggerHandler("remove");k(a)}}else{var l=b.fn.remove;b.fn.remove=function(a,c){return this.each(function(){if(!c)if(!a||b.filter(a,[this]).length)b("*",this).add([this]).each(function(){b(this).triggerHandler("remove")});return l.call(b(this),a,c)})}}b.widget=function(a,c,d){var e=a.split(".")[0],f;a=a.split(".")[1];f=e+"-"+a;if(!d){d=c;c=b.Widget}b.expr[":"][f]=function(h){return!!b.data(h,
a)};b[e]=b[e]||{};b[e][a]=function(h,g){arguments.length&&this._createWidget(h,g)};c=new c;c.options=b.extend(true,{},c.options);b[e][a].prototype=b.extend(true,c,{namespace:e,widgetName:a,widgetEventPrefix:b[e][a].prototype.widgetEventPrefix||a,widgetBaseClass:f},d);b.widget.bridge(a,b[e][a])};b.widget.bridge=function(a,c){b.fn[a]=function(d){var e=typeof d==="string",f=Array.prototype.slice.call(arguments,1),h=this;d=!e&&f.length?b.extend.apply(null,[true,d].concat(f)):d;if(e&&d.charAt(0)==="_")return h;
e?this.each(function(){var g=b.data(this,a),i=g&&b.isFunction(g[d])?g[d].apply(g,f):g;if(i!==g&&i!==j){h=i;return false}}):this.each(function(){var g=b.data(this,a);g?g.option(d||{})._init():b.data(this,a,new c(d,this))});return h}};b.Widget=function(a,c){arguments.length&&this._createWidget(a,c)};b.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(a,c){b.data(c,this.widgetName,this);this.element=b(c);this.options=b.extend(true,{},this.options,
this._getCreateOptions(),a);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()});this._create();this._trigger("create");this._init()},_getCreateOptions:function(){return b.metadata&&b.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled ui-state-disabled")},
widget:function(){return this.element},option:function(a,c){var d=a;if(arguments.length===0)return b.extend({},this.options);if(typeof a==="string"){if(c===j)return this.options[a];d={};d[a]=c}this._setOptions(d);return this},_setOptions:function(a){var c=this;b.each(a,function(d,e){c._setOption(d,e)});return this},_setOption:function(a,c){this.options[a]=c;if(a==="disabled")this.widget()[c?"addClass":"removeClass"](this.widgetBaseClass+"-disabled ui-state-disabled").attr("aria-disabled",c);return this},
enable:function(){return this._setOption("disabled",false)},disable:function(){return this._setOption("disabled",true)},_trigger:function(a,c,d){var e=this.options[a];c=b.Event(c);c.type=(a===this.widgetEventPrefix?a:this.widgetEventPrefix+a).toLowerCase();d=d||{};if(c.originalEvent){a=b.event.props.length;for(var f;a;){f=b.event.props[--a];c[f]=c.originalEvent[f]}}this.element.trigger(c,d);return!(b.isFunction(e)&&e.call(this.element[0],c,d)===false||c.isDefaultPrevented())}}})(jQuery);
;/*!
 * jQuery UI Mouse 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function(b){var d=false;b(document).mousedown(function(){d=false});b.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var a=this;this.element.bind("mousedown."+this.widgetName,function(c){return a._mouseDown(c)}).bind("click."+this.widgetName,function(c){if(true===b.data(c.target,a.widgetName+".preventClickEvent")){b.removeData(c.target,a.widgetName+".preventClickEvent");c.stopImmediatePropagation();return false}});this.started=false},_mouseDestroy:function(){this.element.unbind("."+
this.widgetName)},_mouseDown:function(a){if(!d){this._mouseStarted&&this._mouseUp(a);this._mouseDownEvent=a;var c=this,f=a.which==1,g=typeof this.options.cancel=="string"?b(a.target).closest(this.options.cancel).length:false;if(!f||g||!this._mouseCapture(a))return true;this.mouseDelayMet=!this.options.delay;if(!this.mouseDelayMet)this._mouseDelayTimer=setTimeout(function(){c.mouseDelayMet=true},this.options.delay);if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a)){this._mouseStarted=this._mouseStart(a)!==
false;if(!this._mouseStarted){a.preventDefault();return true}}true===b.data(a.target,this.widgetName+".preventClickEvent")&&b.removeData(a.target,this.widgetName+".preventClickEvent");this._mouseMoveDelegate=function(e){return c._mouseMove(e)};this._mouseUpDelegate=function(e){return c._mouseUp(e)};b(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate);a.preventDefault();return d=true}},_mouseMove:function(a){if(b.browser.msie&&
!(document.documentMode>=9)&&!a.button)return this._mouseUp(a);if(this._mouseStarted){this._mouseDrag(a);return a.preventDefault()}if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a))(this._mouseStarted=this._mouseStart(this._mouseDownEvent,a)!==false)?this._mouseDrag(a):this._mouseUp(a);return!this._mouseStarted},_mouseUp:function(a){b(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate);if(this._mouseStarted){this._mouseStarted=
false;a.target==this._mouseDownEvent.target&&b.data(a.target,this.widgetName+".preventClickEvent",true);this._mouseStop(a)}return false},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return true}})})(jQuery);
;/*
 * jQuery UI Position 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function(c){c.ui=c.ui||{};var n=/left|center|right/,o=/top|center|bottom/,t=c.fn.position,u=c.fn.offset;c.fn.position=function(b){if(!b||!b.of)return t.apply(this,arguments);b=c.extend({},b);var a=c(b.of),d=a[0],g=(b.collision||"flip").split(" "),e=b.offset?b.offset.split(" "):[0,0],h,k,j;if(d.nodeType===9){h=a.width();k=a.height();j={top:0,left:0}}else if(d.setTimeout){h=a.width();k=a.height();j={top:a.scrollTop(),left:a.scrollLeft()}}else if(d.preventDefault){b.at="left top";h=k=0;j={top:b.of.pageY,
left:b.of.pageX}}else{h=a.outerWidth();k=a.outerHeight();j=a.offset()}c.each(["my","at"],function(){var f=(b[this]||"").split(" ");if(f.length===1)f=n.test(f[0])?f.concat(["center"]):o.test(f[0])?["center"].concat(f):["center","center"];f[0]=n.test(f[0])?f[0]:"center";f[1]=o.test(f[1])?f[1]:"center";b[this]=f});if(g.length===1)g[1]=g[0];e[0]=parseInt(e[0],10)||0;if(e.length===1)e[1]=e[0];e[1]=parseInt(e[1],10)||0;if(b.at[0]==="right")j.left+=h;else if(b.at[0]==="center")j.left+=h/2;if(b.at[1]==="bottom")j.top+=
k;else if(b.at[1]==="center")j.top+=k/2;j.left+=e[0];j.top+=e[1];return this.each(function(){var f=c(this),l=f.outerWidth(),m=f.outerHeight(),p=parseInt(c.curCSS(this,"marginLeft",true))||0,q=parseInt(c.curCSS(this,"marginTop",true))||0,v=l+p+(parseInt(c.curCSS(this,"marginRight",true))||0),w=m+q+(parseInt(c.curCSS(this,"marginBottom",true))||0),i=c.extend({},j),r;if(b.my[0]==="right")i.left-=l;else if(b.my[0]==="center")i.left-=l/2;if(b.my[1]==="bottom")i.top-=m;else if(b.my[1]==="center")i.top-=
m/2;i.left=Math.round(i.left);i.top=Math.round(i.top);r={left:i.left-p,top:i.top-q};c.each(["left","top"],function(s,x){c.ui.position[g[s]]&&c.ui.position[g[s]][x](i,{targetWidth:h,targetHeight:k,elemWidth:l,elemHeight:m,collisionPosition:r,collisionWidth:v,collisionHeight:w,offset:e,my:b.my,at:b.at})});c.fn.bgiframe&&f.bgiframe();f.offset(c.extend(i,{using:b.using}))})};c.ui.position={fit:{left:function(b,a){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();b.left=
d>0?b.left-d:Math.max(b.left-a.collisionPosition.left,b.left)},top:function(b,a){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();b.top=d>0?b.top-d:Math.max(b.top-a.collisionPosition.top,b.top)}},flip:{left:function(b,a){if(a.at[0]!=="center"){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();var g=a.my[0]==="left"?-a.elemWidth:a.my[0]==="right"?a.elemWidth:0,e=a.at[0]==="left"?a.targetWidth:-a.targetWidth,h=-2*a.offset[0];b.left+=
a.collisionPosition.left<0?g+e+h:d>0?g+e+h:0}},top:function(b,a){if(a.at[1]!=="center"){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();var g=a.my[1]==="top"?-a.elemHeight:a.my[1]==="bottom"?a.elemHeight:0,e=a.at[1]==="top"?a.targetHeight:-a.targetHeight,h=-2*a.offset[1];b.top+=a.collisionPosition.top<0?g+e+h:d>0?g+e+h:0}}}};if(!c.offset.setOffset){c.offset.setOffset=function(b,a){if(/static/.test(c.curCSS(b,"position")))b.style.position="relative";var d=c(b),
g=d.offset(),e=parseInt(c.curCSS(b,"top",true),10)||0,h=parseInt(c.curCSS(b,"left",true),10)||0;g={top:a.top-g.top+e,left:a.left-g.left+h};"using"in a?a.using.call(b,g):d.css(g)};c.fn.offset=function(b){var a=this[0];if(!a||!a.ownerDocument)return null;if(b)return this.each(function(){c.offset.setOffset(this,b)});return u.call(this)}}})(jQuery);
;/*
 * jQuery UI Draggable 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.draggable",d.ui.mouse,{widgetEventPrefix:"drag",options:{addClasses:true,appendTo:"parent",axis:false,connectToSortable:false,containment:false,cursor:"auto",cursorAt:false,grid:false,handle:false,helper:"original",iframeFix:false,opacity:false,refreshPositions:false,revert:false,revertDuration:500,scope:"default",scroll:true,scrollSensitivity:20,scrollSpeed:20,snap:false,snapMode:"both",snapTolerance:20,stack:false,zIndex:false},_create:function(){if(this.options.helper==
"original"&&!/^(?:r|a|f)/.test(this.element.css("position")))this.element[0].style.position="relative";this.options.addClasses&&this.element.addClass("ui-draggable");this.options.disabled&&this.element.addClass("ui-draggable-disabled");this._mouseInit()},destroy:function(){if(this.element.data("draggable")){this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");this._mouseDestroy();return this}},_mouseCapture:function(a){var b=
this.options;if(this.helper||b.disabled||d(a.target).is(".ui-resizable-handle"))return false;this.handle=this._getHandle(a);if(!this.handle)return false;d(b.iframeFix===true?"iframe":b.iframeFix).each(function(){d('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1E3}).css(d(this).offset()).appendTo("body")});return true},_mouseStart:function(a){var b=this.options;this.helper=
this._createHelper(a);this._cacheHelperProportions();if(d.ui.ddmanager)d.ui.ddmanager.current=this;this._cacheMargins();this.cssPosition=this.helper.css("position");this.scrollParent=this.helper.scrollParent();this.offset=this.positionAbs=this.element.offset();this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left};d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});
this.originalPosition=this.position=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);b.containment&&this._setContainment();if(this._trigger("start",a)===false){this._clear();return false}this._cacheHelperProportions();d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.helper.addClass("ui-draggable-dragging");this._mouseDrag(a,true);d.ui.ddmanager&&d.ui.ddmanager.dragStart(this,a);return true},
_mouseDrag:function(a,b){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");if(!b){b=this._uiHash();if(this._trigger("drag",a,b)===false){this._mouseUp({});return false}this.position=b.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);return false},_mouseStop:function(a){var b=
false;if(d.ui.ddmanager&&!this.options.dropBehaviour)b=d.ui.ddmanager.drop(this,a);if(this.dropped){b=this.dropped;this.dropped=false}if((!this.element[0]||!this.element[0].parentNode)&&this.options.helper=="original")return false;if(this.options.revert=="invalid"&&!b||this.options.revert=="valid"&&b||this.options.revert===true||d.isFunction(this.options.revert)&&this.options.revert.call(this.element,b)){var c=this;d(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,
10),function(){c._trigger("stop",a)!==false&&c._clear()})}else this._trigger("stop",a)!==false&&this._clear();return false},_mouseUp:function(a){this.options.iframeFix===true&&d("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)});d.ui.ddmanager&&d.ui.ddmanager.dragStop(this,a);return d.ui.mouse.prototype._mouseUp.call(this,a)},cancel:function(){this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear();return this},_getHandle:function(a){var b=!this.options.handle||
!d(this.options.handle,this.element).length?true:false;d(this.options.handle,this.element).find("*").andSelf().each(function(){if(this==a.target)b=true});return b},_createHelper:function(a){var b=this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a])):b.helper=="clone"?this.element.clone().removeAttr("id"):this.element;a.parents("body").length||a.appendTo(b.appendTo=="parent"?this.element[0].parentNode:b.appendTo);a[0]!=this.element[0]&&!/(fixed|absolute)/.test(a.css("position"))&&
a.css("position","absolute");return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=
this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a={top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),
10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.element.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),
10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment=="parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[a.containment=="document"?0:d(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,a.containment=="document"?0:d(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,
(a.containment=="document"?0:d(window).scrollLeft())+d(a.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(a.containment=="document"?0:d(window).scrollTop())+(d(a.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)&&a.containment.constructor!=Array){a=d(a.containment);var b=a[0];if(b){a.offset();var c=d(b).css("overflow")!=
"hidden";this.containment=[(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0),(parseInt(d(b).css("borderTopWidth"),10)||0)+(parseInt(d(b).css("paddingTop"),10)||0),(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),
10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom];this.relative_container=a}}else if(a.containment.constructor==Array)this.containment=a.containment},_convertPositionTo:function(a,b){if(!b)b=this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName);return{top:b.top+
this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():f?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&
!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName),e=a.pageX,h=a.pageY;if(this.originalPosition){var g;if(this.containment){if(this.relative_container){g=this.relative_container.offset();g=[this.containment[0]+g.left,this.containment[1]+g.top,this.containment[2]+g.left,this.containment[3]+g.top]}else g=this.containment;if(a.pageX-this.offset.click.left<g[0])e=g[0]+this.offset.click.left;
if(a.pageY-this.offset.click.top<g[1])h=g[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>g[2])e=g[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>g[3])h=g[3]+this.offset.click.top}if(b.grid){h=b.grid[1]?this.originalPageY+Math.round((h-this.originalPageY)/b.grid[1])*b.grid[1]:this.originalPageY;h=g?!(h-this.offset.click.top<g[1]||h-this.offset.click.top>g[3])?h:!(h-this.offset.click.top<g[1])?h-b.grid[1]:h+b.grid[1]:h;e=b.grid[0]?this.originalPageX+Math.round((e-this.originalPageX)/
b.grid[0])*b.grid[0]:this.originalPageX;e=g?!(e-this.offset.click.left<g[0]||e-this.offset.click.left>g[2])?e:!(e-this.offset.click.left<g[0])?e-b.grid[0]:e+b.grid[0]:e}}return{top:h-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():f?0:c.scrollTop()),left:e-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&d.browser.version<
526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging");this.helper[0]!=this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove();this.helper=null;this.cancelHelperRemoval=false},_trigger:function(a,b,c){c=c||this._uiHash();d.ui.plugin.call(this,a,[b,c]);if(a=="drag")this.positionAbs=this._convertPositionTo("absolute");return d.Widget.prototype._trigger.call(this,a,b,
c)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}});d.extend(d.ui.draggable,{version:"1.8.14"});d.ui.plugin.add("draggable","connectToSortable",{start:function(a,b){var c=d(this).data("draggable"),f=c.options,e=d.extend({},b,{item:c.element});c.sortables=[];d(f.connectToSortable).each(function(){var h=d.data(this,"sortable");if(h&&!h.options.disabled){c.sortables.push({instance:h,shouldRevert:h.options.revert});
h.refreshPositions();h._trigger("activate",a,e)}})},stop:function(a,b){var c=d(this).data("draggable"),f=d.extend({},b,{item:c.element});d.each(c.sortables,function(){if(this.instance.isOver){this.instance.isOver=0;c.cancelHelperRemoval=true;this.instance.cancelHelperRemoval=false;if(this.shouldRevert)this.instance.options.revert=true;this.instance._mouseStop(a);this.instance.options.helper=this.instance.options._helper;c.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})}else{this.instance.cancelHelperRemoval=
false;this.instance._trigger("deactivate",a,f)}})},drag:function(a,b){var c=d(this).data("draggable"),f=this;d.each(c.sortables,function(){this.instance.positionAbs=c.positionAbs;this.instance.helperProportions=c.helperProportions;this.instance.offset.click=c.offset.click;if(this.instance._intersectsWith(this.instance.containerCache)){if(!this.instance.isOver){this.instance.isOver=1;this.instance.currentItem=d(f).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",true);
this.instance.options._helper=this.instance.options.helper;this.instance.options.helper=function(){return b.helper[0]};a.target=this.instance.currentItem[0];this.instance._mouseCapture(a,true);this.instance._mouseStart(a,true,true);this.instance.offset.click.top=c.offset.click.top;this.instance.offset.click.left=c.offset.click.left;this.instance.offset.parent.left-=c.offset.parent.left-this.instance.offset.parent.left;this.instance.offset.parent.top-=c.offset.parent.top-this.instance.offset.parent.top;
c._trigger("toSortable",a);c.dropped=this.instance.element;c.currentItem=c.element;this.instance.fromOutside=c}this.instance.currentItem&&this.instance._mouseDrag(a)}else if(this.instance.isOver){this.instance.isOver=0;this.instance.cancelHelperRemoval=true;this.instance.options.revert=false;this.instance._trigger("out",a,this.instance._uiHash(this.instance));this.instance._mouseStop(a,true);this.instance.options.helper=this.instance.options._helper;this.instance.currentItem.remove();this.instance.placeholder&&
this.instance.placeholder.remove();c._trigger("fromSortable",a);c.dropped=false}})}});d.ui.plugin.add("draggable","cursor",{start:function(){var a=d("body"),b=d(this).data("draggable").options;if(a.css("cursor"))b._cursor=a.css("cursor");a.css("cursor",b.cursor)},stop:function(){var a=d(this).data("draggable").options;a._cursor&&d("body").css("cursor",a._cursor)}});d.ui.plugin.add("draggable","opacity",{start:function(a,b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("opacity"))b._opacity=
a.css("opacity");a.css("opacity",b.opacity)},stop:function(a,b){a=d(this).data("draggable").options;a._opacity&&d(b.helper).css("opacity",a._opacity)}});d.ui.plugin.add("draggable","scroll",{start:function(){var a=d(this).data("draggable");if(a.scrollParent[0]!=document&&a.scrollParent[0].tagName!="HTML")a.overflowOffset=a.scrollParent.offset()},drag:function(a){var b=d(this).data("draggable"),c=b.options,f=false;if(b.scrollParent[0]!=document&&b.scrollParent[0].tagName!="HTML"){if(!c.axis||c.axis!=
"x")if(b.overflowOffset.top+b.scrollParent[0].offsetHeight-a.pageY<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop+c.scrollSpeed;else if(a.pageY-b.overflowOffset.top<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop-c.scrollSpeed;if(!c.axis||c.axis!="y")if(b.overflowOffset.left+b.scrollParent[0].offsetWidth-a.pageX<c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft+c.scrollSpeed;else if(a.pageX-b.overflowOffset.left<
c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft-c.scrollSpeed}else{if(!c.axis||c.axis!="x")if(a.pageY-d(document).scrollTop()<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()-c.scrollSpeed);else if(d(window).height()-(a.pageY-d(document).scrollTop())<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()+c.scrollSpeed);if(!c.axis||c.axis!="y")if(a.pageX-d(document).scrollLeft()<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()-
c.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()+c.scrollSpeed)}f!==false&&d.ui.ddmanager&&!c.dropBehaviour&&d.ui.ddmanager.prepareOffsets(b,a)}});d.ui.plugin.add("draggable","snap",{start:function(){var a=d(this).data("draggable"),b=a.options;a.snapElements=[];d(b.snap.constructor!=String?b.snap.items||":data(draggable)":b.snap).each(function(){var c=d(this),f=c.offset();this!=a.element[0]&&a.snapElements.push({item:this,
width:c.outerWidth(),height:c.outerHeight(),top:f.top,left:f.left})})},drag:function(a,b){for(var c=d(this).data("draggable"),f=c.options,e=f.snapTolerance,h=b.offset.left,g=h+c.helperProportions.width,n=b.offset.top,o=n+c.helperProportions.height,i=c.snapElements.length-1;i>=0;i--){var j=c.snapElements[i].left,l=j+c.snapElements[i].width,k=c.snapElements[i].top,m=k+c.snapElements[i].height;if(j-e<h&&h<l+e&&k-e<n&&n<m+e||j-e<h&&h<l+e&&k-e<o&&o<m+e||j-e<g&&g<l+e&&k-e<n&&n<m+e||j-e<g&&g<l+e&&k-e<o&&
o<m+e){if(f.snapMode!="inner"){var p=Math.abs(k-o)<=e,q=Math.abs(m-n)<=e,r=Math.abs(j-g)<=e,s=Math.abs(l-h)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:k-c.helperProportions.height,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",{top:m,left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:j-c.helperProportions.width}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:l}).left-c.margins.left}var t=
p||q||r||s;if(f.snapMode!="outer"){p=Math.abs(k-n)<=e;q=Math.abs(m-o)<=e;r=Math.abs(j-h)<=e;s=Math.abs(l-g)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:k,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",{top:m-c.helperProportions.height,left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:j}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:l-c.helperProportions.width}).left-c.margins.left}if(!c.snapElements[i].snapping&&
(p||q||r||s||t))c.options.snap.snap&&c.options.snap.snap.call(c.element,a,d.extend(c._uiHash(),{snapItem:c.snapElements[i].item}));c.snapElements[i].snapping=p||q||r||s||t}else{c.snapElements[i].snapping&&c.options.snap.release&&c.options.snap.release.call(c.element,a,d.extend(c._uiHash(),{snapItem:c.snapElements[i].item}));c.snapElements[i].snapping=false}}}});d.ui.plugin.add("draggable","stack",{start:function(){var a=d(this).data("draggable").options;a=d.makeArray(d(a.stack)).sort(function(c,f){return(parseInt(d(c).css("zIndex"),
10)||0)-(parseInt(d(f).css("zIndex"),10)||0)});if(a.length){var b=parseInt(a[0].style.zIndex)||0;d(a).each(function(c){this.style.zIndex=b+c});this[0].style.zIndex=b+a.length}}});d.ui.plugin.add("draggable","zIndex",{start:function(a,b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("zIndex"))b._zIndex=a.css("zIndex");a.css("zIndex",b.zIndex)},stop:function(a,b){a=d(this).data("draggable").options;a._zIndex&&d(b.helper).css("zIndex",a._zIndex)}})})(jQuery);
;/*
 * jQuery UI Resizable 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(e){e.widget("ui.resizable",e.ui.mouse,{widgetEventPrefix:"resize",options:{alsoResize:false,animate:false,animateDuration:"slow",animateEasing:"swing",aspectRatio:false,autoHide:false,containment:false,ghost:false,grid:false,handles:"e,s,se",helper:false,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1E3},_create:function(){var b=this,a=this.options;this.element.addClass("ui-resizable");e.extend(this,{_aspectRatio:!!a.aspectRatio,aspectRatio:a.aspectRatio,originalElement:this.element,
_proportionallyResizeElements:[],_helper:a.helper||a.ghost||a.animate?a.helper||"ui-resizable-helper":null});if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)){/relative/.test(this.element.css("position"))&&e.browser.opera&&this.element.css({position:"relative",top:"auto",left:"auto"});this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),
top:this.element.css("top"),left:this.element.css("left")}));this.element=this.element.parent().data("resizable",this.element.data("resizable"));this.elementIsWrapper=true;this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")});this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0});this.originalResizeStyle=
this.originalElement.css("resize");this.originalElement.css("resize","none");this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"}));this.originalElement.css({margin:this.originalElement.css("margin")});this._proportionallyResize()}this.handles=a.handles||(!e(".ui-resizable-handle",this.element).length?"e,s,se":{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",
nw:".ui-resizable-nw"});if(this.handles.constructor==String){if(this.handles=="all")this.handles="n,e,s,w,se,sw,ne,nw";var c=this.handles.split(",");this.handles={};for(var d=0;d<c.length;d++){var f=e.trim(c[d]),g=e('<div class="ui-resizable-handle '+("ui-resizable-"+f)+'"></div>');/sw|se|ne|nw/.test(f)&&g.css({zIndex:++a.zIndex});"se"==f&&g.addClass("ui-icon ui-icon-gripsmall-diagonal-se");this.handles[f]=".ui-resizable-"+f;this.element.append(g)}}this._renderAxis=function(h){h=h||this.element;for(var i in this.handles){if(this.handles[i].constructor==
String)this.handles[i]=e(this.handles[i],this.element).show();if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var j=e(this.handles[i],this.element),l=0;l=/sw|ne|nw|se|n|s/.test(i)?j.outerHeight():j.outerWidth();j=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join("");h.css(j,l);this._proportionallyResize()}e(this.handles[i])}};this._renderAxis(this.element);this._handles=e(".ui-resizable-handle",this.element).disableSelection();
this._handles.mouseover(function(){if(!b.resizing){if(this.className)var h=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);b.axis=h&&h[1]?h[1]:"se"}});if(a.autoHide){this._handles.hide();e(this.element).addClass("ui-resizable-autohide").hover(function(){if(!a.disabled){e(this).removeClass("ui-resizable-autohide");b._handles.show()}},function(){if(!a.disabled)if(!b.resizing){e(this).addClass("ui-resizable-autohide");b._handles.hide()}})}this._mouseInit()},destroy:function(){this._mouseDestroy();
var b=function(c){e(c).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){b(this.element);var a=this.element;a.after(this.originalElement.css({position:a.css("position"),width:a.outerWidth(),height:a.outerHeight(),top:a.css("top"),left:a.css("left")})).remove()}this.originalElement.css("resize",this.originalResizeStyle);b(this.originalElement);return this},_mouseCapture:function(b){var a=
false;for(var c in this.handles)if(e(this.handles[c])[0]==b.target)a=true;return!this.options.disabled&&a},_mouseStart:function(b){var a=this.options,c=this.element.position(),d=this.element;this.resizing=true;this.documentScroll={top:e(document).scrollTop(),left:e(document).scrollLeft()};if(d.is(".ui-draggable")||/absolute/.test(d.css("position")))d.css({position:"absolute",top:c.top,left:c.left});e.browser.opera&&/relative/.test(d.css("position"))&&d.css({position:"relative",top:"auto",left:"auto"});
this._renderProxy();c=m(this.helper.css("left"));var f=m(this.helper.css("top"));if(a.containment){c+=e(a.containment).scrollLeft()||0;f+=e(a.containment).scrollTop()||0}this.offset=this.helper.offset();this.position={left:c,top:f};this.size=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalSize=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalPosition={left:c,top:f};this.sizeDiff=
{width:d.outerWidth()-d.width(),height:d.outerHeight()-d.height()};this.originalMousePosition={left:b.pageX,top:b.pageY};this.aspectRatio=typeof a.aspectRatio=="number"?a.aspectRatio:this.originalSize.width/this.originalSize.height||1;a=e(".ui-resizable-"+this.axis).css("cursor");e("body").css("cursor",a=="auto"?this.axis+"-resize":a);d.addClass("ui-resizable-resizing");this._propagate("start",b);return true},_mouseDrag:function(b){var a=this.helper,c=this.originalMousePosition,d=this._change[this.axis];
if(!d)return false;c=d.apply(this,[b,b.pageX-c.left||0,b.pageY-c.top||0]);this._updateVirtualBoundaries(b.shiftKey);if(this._aspectRatio||b.shiftKey)c=this._updateRatio(c,b);c=this._respectSize(c,b);this._propagate("resize",b);a.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"});!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize();this._updateCache(c);this._trigger("resize",b,this.ui());return false},
_mouseStop:function(b){this.resizing=false;var a=this.options,c=this;if(this._helper){var d=this._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName);d=f&&e.ui.hasScroll(d[0],"left")?0:c.sizeDiff.height;f=f?0:c.sizeDiff.width;f={width:c.helper.width()-f,height:c.helper.height()-d};d=parseInt(c.element.css("left"),10)+(c.position.left-c.originalPosition.left)||null;var g=parseInt(c.element.css("top"),10)+(c.position.top-c.originalPosition.top)||null;a.animate||this.element.css(e.extend(f,
{top:g,left:d}));c.helper.height(c.size.height);c.helper.width(c.size.width);this._helper&&!a.animate&&this._proportionallyResize()}e("body").css("cursor","auto");this.element.removeClass("ui-resizable-resizing");this._propagate("stop",b);this._helper&&this.helper.remove();return false},_updateVirtualBoundaries:function(b){var a=this.options,c,d,f;a={minWidth:k(a.minWidth)?a.minWidth:0,maxWidth:k(a.maxWidth)?a.maxWidth:Infinity,minHeight:k(a.minHeight)?a.minHeight:0,maxHeight:k(a.maxHeight)?a.maxHeight:
Infinity};if(this._aspectRatio||b){b=a.minHeight*this.aspectRatio;d=a.minWidth/this.aspectRatio;c=a.maxHeight*this.aspectRatio;f=a.maxWidth/this.aspectRatio;if(b>a.minWidth)a.minWidth=b;if(d>a.minHeight)a.minHeight=d;if(c<a.maxWidth)a.maxWidth=c;if(f<a.maxHeight)a.maxHeight=f}this._vBoundaries=a},_updateCache:function(b){this.offset=this.helper.offset();if(k(b.left))this.position.left=b.left;if(k(b.top))this.position.top=b.top;if(k(b.height))this.size.height=b.height;if(k(b.width))this.size.width=
b.width},_updateRatio:function(b){var a=this.position,c=this.size,d=this.axis;if(k(b.height))b.width=b.height*this.aspectRatio;else if(k(b.width))b.height=b.width/this.aspectRatio;if(d=="sw"){b.left=a.left+(c.width-b.width);b.top=null}if(d=="nw"){b.top=a.top+(c.height-b.height);b.left=a.left+(c.width-b.width)}return b},_respectSize:function(b){var a=this._vBoundaries,c=this.axis,d=k(b.width)&&a.maxWidth&&a.maxWidth<b.width,f=k(b.height)&&a.maxHeight&&a.maxHeight<b.height,g=k(b.width)&&a.minWidth&&
a.minWidth>b.width,h=k(b.height)&&a.minHeight&&a.minHeight>b.height;if(g)b.width=a.minWidth;if(h)b.height=a.minHeight;if(d)b.width=a.maxWidth;if(f)b.height=a.maxHeight;var i=this.originalPosition.left+this.originalSize.width,j=this.position.top+this.size.height,l=/sw|nw|w/.test(c);c=/nw|ne|n/.test(c);if(g&&l)b.left=i-a.minWidth;if(d&&l)b.left=i-a.maxWidth;if(h&&c)b.top=j-a.minHeight;if(f&&c)b.top=j-a.maxHeight;if((a=!b.width&&!b.height)&&!b.left&&b.top)b.top=null;else if(a&&!b.top&&b.left)b.left=
null;return b},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var b=this.helper||this.element,a=0;a<this._proportionallyResizeElements.length;a++){var c=this._proportionallyResizeElements[a];if(!this.borderDif){var d=[c.css("borderTopWidth"),c.css("borderRightWidth"),c.css("borderBottomWidth"),c.css("borderLeftWidth")],f=[c.css("paddingTop"),c.css("paddingRight"),c.css("paddingBottom"),c.css("paddingLeft")];this.borderDif=e.map(d,function(g,h){g=parseInt(g,10)||
0;h=parseInt(f[h],10)||0;return g+h})}e.browser.msie&&(e(b).is(":hidden")||e(b).parents(":hidden").length)||c.css({height:b.height()-this.borderDif[0]-this.borderDif[2]||0,width:b.width()-this.borderDif[1]-this.borderDif[3]||0})}},_renderProxy:function(){var b=this.options;this.elementOffset=this.element.offset();if(this._helper){this.helper=this.helper||e('<div style="overflow:hidden;"></div>');var a=e.browser.msie&&e.browser.version<7,c=a?1:0;a=a?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+
a,height:this.element.outerHeight()+a,position:"absolute",left:this.elementOffset.left-c+"px",top:this.elementOffset.top-c+"px",zIndex:++b.zIndex});this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(b,a){return{width:this.originalSize.width+a}},w:function(b,a){return{left:this.originalPosition.left+a,width:this.originalSize.width-a}},n:function(b,a,c){return{top:this.originalPosition.top+c,height:this.originalSize.height-c}},s:function(b,a,c){return{height:this.originalSize.height+
c}},se:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},sw:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[b,a,c]))},ne:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},nw:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[b,a,c]))}},_propagate:function(b,a){e.ui.plugin.call(this,b,[a,this.ui()]);
b!="resize"&&this._trigger(b,a,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}});e.extend(e.ui.resizable,{version:"1.8.14"});e.ui.plugin.add("resizable","alsoResize",{start:function(){var b=e(this).data("resizable").options,a=function(c){e(c).each(function(){var d=e(this);d.data("resizable-alsoresize",{width:parseInt(d.width(),
10),height:parseInt(d.height(),10),left:parseInt(d.css("left"),10),top:parseInt(d.css("top"),10),position:d.css("position")})})};if(typeof b.alsoResize=="object"&&!b.alsoResize.parentNode)if(b.alsoResize.length){b.alsoResize=b.alsoResize[0];a(b.alsoResize)}else e.each(b.alsoResize,function(c){a(c)});else a(b.alsoResize)},resize:function(b,a){var c=e(this).data("resizable");b=c.options;var d=c.originalSize,f=c.originalPosition,g={height:c.size.height-d.height||0,width:c.size.width-d.width||0,top:c.position.top-
f.top||0,left:c.position.left-f.left||0},h=function(i,j){e(i).each(function(){var l=e(this),q=e(this).data("resizable-alsoresize"),p={},r=j&&j.length?j:l.parents(a.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(r,function(n,o){if((n=(q[o]||0)+(g[o]||0))&&n>=0)p[o]=n||null});if(e.browser.opera&&/relative/.test(l.css("position"))){c._revertToRelativePosition=true;l.css({position:"absolute",top:"auto",left:"auto"})}l.css(p)})};typeof b.alsoResize=="object"&&!b.alsoResize.nodeType?
e.each(b.alsoResize,function(i,j){h(i,j)}):h(b.alsoResize)},stop:function(){var b=e(this).data("resizable"),a=b.options,c=function(d){e(d).each(function(){var f=e(this);f.css({position:f.data("resizable-alsoresize").position})})};if(b._revertToRelativePosition){b._revertToRelativePosition=false;typeof a.alsoResize=="object"&&!a.alsoResize.nodeType?e.each(a.alsoResize,function(d){c(d)}):c(a.alsoResize)}e(this).removeData("resizable-alsoresize")}});e.ui.plugin.add("resizable","animate",{stop:function(b){var a=
e(this).data("resizable"),c=a.options,d=a._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName),g=f&&e.ui.hasScroll(d[0],"left")?0:a.sizeDiff.height;f={width:a.size.width-(f?0:a.sizeDiff.width),height:a.size.height-g};g=parseInt(a.element.css("left"),10)+(a.position.left-a.originalPosition.left)||null;var h=parseInt(a.element.css("top"),10)+(a.position.top-a.originalPosition.top)||null;a.element.animate(e.extend(f,h&&g?{top:h,left:g}:{}),{duration:c.animateDuration,easing:c.animateEasing,
step:function(){var i={width:parseInt(a.element.css("width"),10),height:parseInt(a.element.css("height"),10),top:parseInt(a.element.css("top"),10),left:parseInt(a.element.css("left"),10)};d&&d.length&&e(d[0]).css({width:i.width,height:i.height});a._updateCache(i);a._propagate("resize",b)}})}});e.ui.plugin.add("resizable","containment",{start:function(){var b=e(this).data("resizable"),a=b.element,c=b.options.containment;if(a=c instanceof e?c.get(0):/parent/.test(c)?a.parent().get(0):c){b.containerElement=
e(a);if(/document/.test(c)||c==document){b.containerOffset={left:0,top:0};b.containerPosition={left:0,top:0};b.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}}else{var d=e(a),f=[];e(["Top","Right","Left","Bottom"]).each(function(i,j){f[i]=m(d.css("padding"+j))});b.containerOffset=d.offset();b.containerPosition=d.position();b.containerSize={height:d.innerHeight()-f[3],width:d.innerWidth()-f[1]};c=b.containerOffset;
var g=b.containerSize.height,h=b.containerSize.width;h=e.ui.hasScroll(a,"left")?a.scrollWidth:h;g=e.ui.hasScroll(a)?a.scrollHeight:g;b.parentData={element:a,left:c.left,top:c.top,width:h,height:g}}}},resize:function(b){var a=e(this).data("resizable"),c=a.options,d=a.containerOffset,f=a.position;b=a._aspectRatio||b.shiftKey;var g={top:0,left:0},h=a.containerElement;if(h[0]!=document&&/static/.test(h.css("position")))g=d;if(f.left<(a._helper?d.left:0)){a.size.width+=a._helper?a.position.left-d.left:
a.position.left-g.left;if(b)a.size.height=a.size.width/c.aspectRatio;a.position.left=c.helper?d.left:0}if(f.top<(a._helper?d.top:0)){a.size.height+=a._helper?a.position.top-d.top:a.position.top;if(b)a.size.width=a.size.height*c.aspectRatio;a.position.top=a._helper?d.top:0}a.offset.left=a.parentData.left+a.position.left;a.offset.top=a.parentData.top+a.position.top;c=Math.abs((a._helper?a.offset.left-g.left:a.offset.left-g.left)+a.sizeDiff.width);d=Math.abs((a._helper?a.offset.top-g.top:a.offset.top-
d.top)+a.sizeDiff.height);f=a.containerElement.get(0)==a.element.parent().get(0);g=/relative|absolute/.test(a.containerElement.css("position"));if(f&&g)c-=a.parentData.left;if(c+a.size.width>=a.parentData.width){a.size.width=a.parentData.width-c;if(b)a.size.height=a.size.width/a.aspectRatio}if(d+a.size.height>=a.parentData.height){a.size.height=a.parentData.height-d;if(b)a.size.width=a.size.height*a.aspectRatio}},stop:function(){var b=e(this).data("resizable"),a=b.options,c=b.containerOffset,d=b.containerPosition,
f=b.containerElement,g=e(b.helper),h=g.offset(),i=g.outerWidth()-b.sizeDiff.width;g=g.outerHeight()-b.sizeDiff.height;b._helper&&!a.animate&&/relative/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g});b._helper&&!a.animate&&/static/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g})}});e.ui.plugin.add("resizable","ghost",{start:function(){var b=e(this).data("resizable"),a=b.options,c=b.size;b.ghost=b.originalElement.clone();b.ghost.css({opacity:0.25,
display:"block",position:"relative",height:c.height,width:c.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof a.ghost=="string"?a.ghost:"");b.ghost.appendTo(b.helper)},resize:function(){var b=e(this).data("resizable");b.ghost&&b.ghost.css({position:"relative",height:b.size.height,width:b.size.width})},stop:function(){var b=e(this).data("resizable");b.ghost&&b.helper&&b.helper.get(0).removeChild(b.ghost.get(0))}});e.ui.plugin.add("resizable","grid",{resize:function(){var b=
e(this).data("resizable"),a=b.options,c=b.size,d=b.originalSize,f=b.originalPosition,g=b.axis;a.grid=typeof a.grid=="number"?[a.grid,a.grid]:a.grid;var h=Math.round((c.width-d.width)/(a.grid[0]||1))*(a.grid[0]||1);a=Math.round((c.height-d.height)/(a.grid[1]||1))*(a.grid[1]||1);if(/^(se|s|e)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a}else if(/^(ne)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}else{if(/^(sw)$/.test(g)){b.size.width=d.width+h;b.size.height=
d.height+a}else{b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}b.position.left=f.left-h}}});var m=function(b){return parseInt(b,10)||0},k=function(b){return!isNaN(parseInt(b,10))}})(jQuery);
;/*
 * jQuery UI Sortable 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.sortable",d.ui.mouse,{widgetEventPrefix:"sort",options:{appendTo:"parent",axis:false,connectWith:false,containment:false,cursor:"auto",cursorAt:false,dropOnEmpty:true,forcePlaceholderSize:false,forceHelperSize:false,grid:false,handle:false,helper:"original",items:"> *",opacity:false,placeholder:false,revert:false,scroll:true,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1E3},_create:function(){var a=this.options;this.containerCache={};this.element.addClass("ui-sortable");
this.refresh();this.floating=this.items.length?a.axis==="x"||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):false;this.offset=this.element.offset();this._mouseInit()},destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").removeData("sortable").unbind(".sortable");this._mouseDestroy();for(var a=this.items.length-1;a>=0;a--)this.items[a].item.removeData("sortable-item");return this},_setOption:function(a,b){if(a===
"disabled"){this.options[a]=b;this.widget()[b?"addClass":"removeClass"]("ui-sortable-disabled")}else d.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(a,b){if(this.reverting)return false;if(this.options.disabled||this.options.type=="static")return false;this._refreshItems(a);var c=null,e=this;d(a.target).parents().each(function(){if(d.data(this,"sortable-item")==e){c=d(this);return false}});if(d.data(a.target,"sortable-item")==e)c=d(a.target);if(!c)return false;if(this.options.handle&&
!b){var f=false;d(this.options.handle,c).find("*").andSelf().each(function(){if(this==a.target)f=true});if(!f)return false}this.currentItem=c;this._removeCurrentsFromItems();return true},_mouseStart:function(a,b,c){b=this.options;var e=this;this.currentContainer=this;this.refreshPositions();this.helper=this._createHelper(a);this._cacheHelperProportions();this._cacheMargins();this.scrollParent=this.helper.scrollParent();this.offset=this.currentItem.offset();this.offset={top:this.offset.top-this.margins.top,
left:this.offset.left-this.margins.left};this.helper.css("position","absolute");this.cssPosition=this.helper.css("position");d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});this.originalPosition=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]};
this.helper[0]!=this.currentItem[0]&&this.currentItem.hide();this._createPlaceholder();b.containment&&this._setContainment();if(b.cursor){if(d("body").css("cursor"))this._storedCursor=d("body").css("cursor");d("body").css("cursor",b.cursor)}if(b.opacity){if(this.helper.css("opacity"))this._storedOpacity=this.helper.css("opacity");this.helper.css("opacity",b.opacity)}if(b.zIndex){if(this.helper.css("zIndex"))this._storedZIndex=this.helper.css("zIndex");this.helper.css("zIndex",b.zIndex)}if(this.scrollParent[0]!=
document&&this.scrollParent[0].tagName!="HTML")this.overflowOffset=this.scrollParent.offset();this._trigger("start",a,this._uiHash());this._preserveHelperProportions||this._cacheHelperProportions();if(!c)for(c=this.containers.length-1;c>=0;c--)this.containers[c]._trigger("activate",a,e._uiHash(this));if(d.ui.ddmanager)d.ui.ddmanager.current=this;d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.dragging=true;this.helper.addClass("ui-sortable-helper");this._mouseDrag(a);
return true},_mouseDrag:function(a){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");if(!this.lastPositionAbs)this.lastPositionAbs=this.positionAbs;if(this.options.scroll){var b=this.options,c=false;if(this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"){if(this.overflowOffset.top+this.scrollParent[0].offsetHeight-a.pageY<b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop+b.scrollSpeed;else if(a.pageY-this.overflowOffset.top<
b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop-b.scrollSpeed;if(this.overflowOffset.left+this.scrollParent[0].offsetWidth-a.pageX<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft+b.scrollSpeed;else if(a.pageX-this.overflowOffset.left<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft-b.scrollSpeed}else{if(a.pageY-d(document).scrollTop()<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()-
b.scrollSpeed);else if(d(window).height()-(a.pageY-d(document).scrollTop())<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()+b.scrollSpeed);if(a.pageX-d(document).scrollLeft()<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()-b.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()+b.scrollSpeed)}c!==false&&d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,
a)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(b=this.items.length-1;b>=0;b--){c=this.items[b];var e=c.item[0],f=this._intersectsWithPointer(c);if(f)if(e!=this.currentItem[0]&&this.placeholder[f==1?"next":"prev"]()[0]!=e&&!d.ui.contains(this.placeholder[0],e)&&(this.options.type=="semi-dynamic"?!d.ui.contains(this.element[0],
e):true)){this.direction=f==1?"down":"up";if(this.options.tolerance=="pointer"||this._intersectsWithSides(c))this._rearrange(a,c);else break;this._trigger("change",a,this._uiHash());break}}this._contactContainers(a);d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);this._trigger("sort",a,this._uiHash());this.lastPositionAbs=this.positionAbs;return false},_mouseStop:function(a,b){if(a){d.ui.ddmanager&&!this.options.dropBehaviour&&d.ui.ddmanager.drop(this,a);if(this.options.revert){var c=this;b=c.placeholder.offset();
c.reverting=true;d(this.helper).animate({left:b.left-this.offset.parent.left-c.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:b.top-this.offset.parent.top-c.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){c._clear(a)})}else this._clear(a,b);return false}},cancel:function(){var a=this;if(this.dragging){this._mouseUp({target:null});this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):
this.currentItem.show();for(var b=this.containers.length-1;b>=0;b--){this.containers[b]._trigger("deactivate",null,a._uiHash(this));if(this.containers[b].containerCache.over){this.containers[b]._trigger("out",null,a._uiHash(this));this.containers[b].containerCache.over=0}}}if(this.placeholder){this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove();d.extend(this,{helper:null,
dragging:false,reverting:false,_noFinalSort:null});this.domPosition.prev?d(this.domPosition.prev).after(this.currentItem):d(this.domPosition.parent).prepend(this.currentItem)}return this},serialize:function(a){var b=this._getItemsAsjQuery(a&&a.connected),c=[];a=a||{};d(b).each(function(){var e=(d(a.item||this).attr(a.attribute||"id")||"").match(a.expression||/(.+)[-=_](.+)/);if(e)c.push((a.key||e[1]+"[]")+"="+(a.key&&a.expression?e[1]:e[2]))});!c.length&&a.key&&c.push(a.key+"=");return c.join("&")},
toArray:function(a){var b=this._getItemsAsjQuery(a&&a.connected),c=[];a=a||{};b.each(function(){c.push(d(a.item||this).attr(a.attribute||"id")||"")});return c},_intersectsWith:function(a){var b=this.positionAbs.left,c=b+this.helperProportions.width,e=this.positionAbs.top,f=e+this.helperProportions.height,g=a.left,h=g+a.width,i=a.top,k=i+a.height,j=this.offset.click.top,l=this.offset.click.left;j=e+j>i&&e+j<k&&b+l>g&&b+l<h;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||
this.options.tolerance!="pointer"&&this.helperProportions[this.floating?"width":"height"]>a[this.floating?"width":"height"]?j:g<b+this.helperProportions.width/2&&c-this.helperProportions.width/2<h&&i<e+this.helperProportions.height/2&&f-this.helperProportions.height/2<k},_intersectsWithPointer:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left,a.width);b=b&&a;a=this._getDragVerticalDirection();
var c=this._getDragHorizontalDirection();if(!b)return false;return this.floating?c&&c=="right"||a=="down"?2:1:a&&(a=="down"?2:1)},_intersectsWithSides:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top+a.height/2,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left+a.width/2,a.width);var c=this._getDragVerticalDirection(),e=this._getDragHorizontalDirection();return this.floating&&e?e=="right"&&a||e=="left"&&!a:c&&(c=="down"&&b||c=="up"&&!b)},
_getDragVerticalDirection:function(){var a=this.positionAbs.top-this.lastPositionAbs.top;return a!=0&&(a>0?"down":"up")},_getDragHorizontalDirection:function(){var a=this.positionAbs.left-this.lastPositionAbs.left;return a!=0&&(a>0?"right":"left")},refresh:function(a){this._refreshItems(a);this.refreshPositions();return this},_connectWith:function(){var a=this.options;return a.connectWith.constructor==String?[a.connectWith]:a.connectWith},_getItemsAsjQuery:function(a){var b=[],c=[],e=this._connectWith();
if(e&&a)for(a=e.length-1;a>=0;a--)for(var f=d(e[a]),g=f.length-1;g>=0;g--){var h=d.data(f[g],"sortable");if(h&&h!=this&&!h.options.disabled)c.push([d.isFunction(h.options.items)?h.options.items.call(h.element):d(h.options.items,h.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),h])}c.push([d.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):d(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),
this]);for(a=c.length-1;a>=0;a--)c[a][0].each(function(){b.push(this)});return d(b)},_removeCurrentsFromItems:function(){for(var a=this.currentItem.find(":data(sortable-item)"),b=0;b<this.items.length;b++)for(var c=0;c<a.length;c++)a[c]==this.items[b].item[0]&&this.items.splice(b,1)},_refreshItems:function(a){this.items=[];this.containers=[this];var b=this.items,c=[[d.isFunction(this.options.items)?this.options.items.call(this.element[0],a,{item:this.currentItem}):d(this.options.items,this.element),
this]],e=this._connectWith();if(e)for(var f=e.length-1;f>=0;f--)for(var g=d(e[f]),h=g.length-1;h>=0;h--){var i=d.data(g[h],"sortable");if(i&&i!=this&&!i.options.disabled){c.push([d.isFunction(i.options.items)?i.options.items.call(i.element[0],a,{item:this.currentItem}):d(i.options.items,i.element),i]);this.containers.push(i)}}for(f=c.length-1;f>=0;f--){a=c[f][1];e=c[f][0];h=0;for(g=e.length;h<g;h++){i=d(e[h]);i.data("sortable-item",a);b.push({item:i,instance:a,width:0,height:0,left:0,top:0})}}},refreshPositions:function(a){if(this.offsetParent&&
this.helper)this.offset.parent=this._getParentOffset();for(var b=this.items.length-1;b>=0;b--){var c=this.items[b];if(!(c.instance!=this.currentContainer&&this.currentContainer&&c.item[0]!=this.currentItem[0])){var e=this.options.toleranceElement?d(this.options.toleranceElement,c.item):c.item;if(!a){c.width=e.outerWidth();c.height=e.outerHeight()}e=e.offset();c.left=e.left;c.top=e.top}}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(b=
this.containers.length-1;b>=0;b--){e=this.containers[b].element.offset();this.containers[b].containerCache.left=e.left;this.containers[b].containerCache.top=e.top;this.containers[b].containerCache.width=this.containers[b].element.outerWidth();this.containers[b].containerCache.height=this.containers[b].element.outerHeight()}return this},_createPlaceholder:function(a){var b=a||this,c=b.options;if(!c.placeholder||c.placeholder.constructor==String){var e=c.placeholder;c.placeholder={element:function(){var f=
d(document.createElement(b.currentItem[0].nodeName)).addClass(e||b.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];if(!e)f.style.visibility="hidden";return f},update:function(f,g){if(!(e&&!c.forcePlaceholderSize)){g.height()||g.height(b.currentItem.innerHeight()-parseInt(b.currentItem.css("paddingTop")||0,10)-parseInt(b.currentItem.css("paddingBottom")||0,10));g.width()||g.width(b.currentItem.innerWidth()-parseInt(b.currentItem.css("paddingLeft")||0,10)-parseInt(b.currentItem.css("paddingRight")||
0,10))}}}}b.placeholder=d(c.placeholder.element.call(b.element,b.currentItem));b.currentItem.after(b.placeholder);c.placeholder.update(b,b.placeholder)},_contactContainers:function(a){for(var b=null,c=null,e=this.containers.length-1;e>=0;e--)if(!d.ui.contains(this.currentItem[0],this.containers[e].element[0]))if(this._intersectsWith(this.containers[e].containerCache)){if(!(b&&d.ui.contains(this.containers[e].element[0],b.element[0]))){b=this.containers[e];c=e}}else if(this.containers[e].containerCache.over){this.containers[e]._trigger("out",
a,this._uiHash(this));this.containers[e].containerCache.over=0}if(b)if(this.containers.length===1){this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}else if(this.currentContainer!=this.containers[c]){b=1E4;e=null;for(var f=this.positionAbs[this.containers[c].floating?"left":"top"],g=this.items.length-1;g>=0;g--)if(d.ui.contains(this.containers[c].element[0],this.items[g].item[0])){var h=this.items[g][this.containers[c].floating?"left":"top"];if(Math.abs(h-
f)<b){b=Math.abs(h-f);e=this.items[g]}}if(e||this.options.dropOnEmpty){this.currentContainer=this.containers[c];e?this._rearrange(a,e,null,true):this._rearrange(a,null,this.containers[c].element,true);this._trigger("change",a,this._uiHash());this.containers[c]._trigger("change",a,this._uiHash(this));this.options.placeholder.update(this.currentContainer,this.placeholder);this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}}},_createHelper:function(a){var b=
this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a,this.currentItem])):b.helper=="clone"?this.currentItem.clone():this.currentItem;a.parents("body").length||d(b.appendTo!="parent"?b.appendTo:this.currentItem[0].parentNode)[0].appendChild(a[0]);if(a[0]==this.currentItem[0])this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")};if(a[0].style.width==
""||b.forceHelperSize)a.width(this.currentItem.width());if(a[0].style.height==""||b.forceHelperSize)a.height(this.currentItem.height());return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=
this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a=
{top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.currentItem.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),
10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment=="parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,d(a.containment=="document"?
document:window).width()-this.helperProportions.width-this.margins.left,(d(a.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)){var b=d(a.containment)[0];a=d(a.containment).offset();var c=d(b).css("overflow")!="hidden";this.containment=[a.left+(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0)-this.margins.left,a.top+(parseInt(d(b).css("borderTopWidth"),
10)||0)+(parseInt(d(b).css("paddingTop"),10)||0)-this.margins.top,a.left+(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,a.top+(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(a,b){if(!b)b=
this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);return{top:b.top+this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&
this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);if(this.cssPosition=="relative"&&!(this.scrollParent[0]!=document&&this.scrollParent[0]!=this.offsetParent[0]))this.offset.relative=this._getRelativeOffset();
var f=a.pageX,g=a.pageY;if(this.originalPosition){if(this.containment){if(a.pageX-this.offset.click.left<this.containment[0])f=this.containment[0]+this.offset.click.left;if(a.pageY-this.offset.click.top<this.containment[1])g=this.containment[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>this.containment[2])f=this.containment[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>this.containment[3])g=this.containment[3]+this.offset.click.top}if(b.grid){g=this.originalPageY+Math.round((g-
this.originalPageY)/b.grid[1])*b.grid[1];g=this.containment?!(g-this.offset.click.top<this.containment[1]||g-this.offset.click.top>this.containment[3])?g:!(g-this.offset.click.top<this.containment[1])?g-b.grid[1]:g+b.grid[1]:g;f=this.originalPageX+Math.round((f-this.originalPageX)/b.grid[0])*b.grid[0];f=this.containment?!(f-this.offset.click.left<this.containment[0]||f-this.offset.click.left>this.containment[2])?f:!(f-this.offset.click.left<this.containment[0])?f-b.grid[0]:f+b.grid[0]:f}}return{top:g-
this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:c.scrollLeft())}},_rearrange:function(a,b,c,e){c?c[0].appendChild(this.placeholder[0]):b.item[0].parentNode.insertBefore(this.placeholder[0],
this.direction=="down"?b.item[0]:b.item[0].nextSibling);this.counter=this.counter?++this.counter:1;var f=this,g=this.counter;window.setTimeout(function(){g==f.counter&&f.refreshPositions(!e)},0)},_clear:function(a,b){this.reverting=false;var c=[];!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem);this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var e in this._storedCSS)if(this._storedCSS[e]=="auto"||this._storedCSS[e]=="static")this._storedCSS[e]=
"";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!b&&c.push(function(f){this._trigger("receive",f,this._uiHash(this.fromOutside))});if((this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!b)c.push(function(f){this._trigger("update",f,this._uiHash())});if(!d.ui.contains(this.element[0],this.currentItem[0])){b||c.push(function(f){this._trigger("remove",
f,this._uiHash())});for(e=this.containers.length-1;e>=0;e--)if(d.ui.contains(this.containers[e].element[0],this.currentItem[0])&&!b){c.push(function(f){return function(g){f._trigger("receive",g,this._uiHash(this))}}.call(this,this.containers[e]));c.push(function(f){return function(g){f._trigger("update",g,this._uiHash(this))}}.call(this,this.containers[e]))}}for(e=this.containers.length-1;e>=0;e--){b||c.push(function(f){return function(g){f._trigger("deactivate",g,this._uiHash(this))}}.call(this,
this.containers[e]));if(this.containers[e].containerCache.over){c.push(function(f){return function(g){f._trigger("out",g,this._uiHash(this))}}.call(this,this.containers[e]));this.containers[e].containerCache.over=0}}this._storedCursor&&d("body").css("cursor",this._storedCursor);this._storedOpacity&&this.helper.css("opacity",this._storedOpacity);if(this._storedZIndex)this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex);this.dragging=false;if(this.cancelHelperRemoval){if(!b){this._trigger("beforeStop",
a,this._uiHash());for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}return false}b||this._trigger("beforeStop",a,this._uiHash());this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.helper[0]!=this.currentItem[0]&&this.helper.remove();this.helper=null;if(!b){for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}this.fromOutside=false;return true},_trigger:function(){d.Widget.prototype._trigger.apply(this,arguments)===false&&this.cancel()},
_uiHash:function(a){var b=a||this;return{helper:b.helper,placeholder:b.placeholder||d([]),position:b.position,originalPosition:b.originalPosition,offset:b.positionAbs,item:b.currentItem,sender:a?a.element:null}}});d.extend(d.ui.sortable,{version:"1.8.14"})})(jQuery);
;/*
 * jQuery UI Autocomplete 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function(d){var e=0;d.widget("ui.autocomplete",{options:{appendTo:"body",autoFocus:false,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null},pending:0,_create:function(){var a=this,b=this.element[0].ownerDocument,g;this.element.addClass("ui-autocomplete-input").attr("autocomplete","off").attr({role:"textbox","aria-autocomplete":"list","aria-haspopup":"true"}).bind("keydown.autocomplete",function(c){if(!(a.options.disabled||a.element.attr("readonly"))){g=
false;var f=d.ui.keyCode;switch(c.keyCode){case f.PAGE_UP:a._move("previousPage",c);break;case f.PAGE_DOWN:a._move("nextPage",c);break;case f.UP:a._move("previous",c);c.preventDefault();break;case f.DOWN:a._move("next",c);c.preventDefault();break;case f.ENTER:case f.NUMPAD_ENTER:if(a.menu.active){g=true;c.preventDefault()}case f.TAB:if(!a.menu.active)return;a.menu.select(c);break;case f.ESCAPE:a.element.val(a.term);a.close(c);break;default:clearTimeout(a.searching);a.searching=setTimeout(function(){if(a.term!=
a.element.val()){a.selectedItem=null;a.search(null,c)}},a.options.delay);break}}}).bind("keypress.autocomplete",function(c){if(g){g=false;c.preventDefault()}}).bind("focus.autocomplete",function(){if(!a.options.disabled){a.selectedItem=null;a.previous=a.element.val()}}).bind("blur.autocomplete",function(c){if(!a.options.disabled){clearTimeout(a.searching);a.closing=setTimeout(function(){a.close(c);a._change(c)},150)}});this._initSource();this.response=function(){return a._response.apply(a,arguments)};
this.menu=d("<ul></ul>").addClass("ui-autocomplete").appendTo(d(this.options.appendTo||"body",b)[0]).mousedown(function(c){var f=a.menu.element[0];d(c.target).closest(".ui-menu-item").length||setTimeout(function(){d(document).one("mousedown",function(h){h.target!==a.element[0]&&h.target!==f&&!d.ui.contains(f,h.target)&&a.close()})},1);setTimeout(function(){clearTimeout(a.closing)},13)}).menu({focus:function(c,f){f=f.item.data("item.autocomplete");false!==a._trigger("focus",c,{item:f})&&/^key/.test(c.originalEvent.type)&&
a.element.val(f.value)},selected:function(c,f){var h=f.item.data("item.autocomplete"),i=a.previous;if(a.element[0]!==b.activeElement){a.element.focus();a.previous=i;setTimeout(function(){a.previous=i;a.selectedItem=h},1)}false!==a._trigger("select",c,{item:h})&&a.element.val(h.value);a.term=a.element.val();a.close(c);a.selectedItem=h},blur:function(){a.menu.element.is(":visible")&&a.element.val()!==a.term&&a.element.val(a.term)}}).zIndex(this.element.zIndex()+1).css({top:0,left:0}).hide().data("menu");
d.fn.bgiframe&&this.menu.element.bgiframe()},destroy:function(){this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup");this.menu.element.remove();d.Widget.prototype.destroy.call(this)},_setOption:function(a,b){d.Widget.prototype._setOption.apply(this,arguments);a==="source"&&this._initSource();if(a==="appendTo")this.menu.element.appendTo(d(b||"body",this.element[0].ownerDocument)[0]);a==="disabled"&&
b&&this.xhr&&this.xhr.abort()},_initSource:function(){var a=this,b,g;if(d.isArray(this.options.source)){b=this.options.source;this.source=function(c,f){f(d.ui.autocomplete.filter(b,c.term))}}else if(typeof this.options.source==="string"){g=this.options.source;this.source=function(c,f){a.xhr&&a.xhr.abort();a.xhr=d.ajax({url:g,data:c,dataType:"json",autocompleteRequest:++e,success:function(h){this.autocompleteRequest===e&&f(h)},error:function(){this.autocompleteRequest===e&&f([])}})}}else this.source=
this.options.source},search:function(a,b){a=a!=null?a:this.element.val();this.term=this.element.val();if(a.length<this.options.minLength)return this.close(b);clearTimeout(this.closing);if(this._trigger("search",b)!==false)return this._search(a)},_search:function(a){this.pending++;this.element.addClass("ui-autocomplete-loading");this.source({term:a},this.response)},_response:function(a){if(!this.options.disabled&&a&&a.length){a=this._normalize(a);this._suggest(a);this._trigger("open")}else this.close();
this.pending--;this.pending||this.element.removeClass("ui-autocomplete-loading")},close:function(a){clearTimeout(this.closing);if(this.menu.element.is(":visible")){this.menu.element.hide();this.menu.deactivate();this._trigger("close",a)}},_change:function(a){this.previous!==this.element.val()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(a){if(a.length&&a[0].label&&a[0].value)return a;return d.map(a,function(b){if(typeof b==="string")return{label:b,value:b};return d.extend({label:b.label||
b.value,value:b.value||b.label},b)})},_suggest:function(a){var b=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(b,a);this.menu.deactivate();this.menu.refresh();b.show();this._resizeMenu();b.position(d.extend({of:this.element},this.options.position));this.options.autoFocus&&this.menu.next(new d.Event("mouseover"))},_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth(),this.element.outerWidth()))},_renderMenu:function(a,b){var g=this;
d.each(b,function(c,f){g._renderItem(a,f)})},_renderItem:function(a,b){return d("<li></li>").data("item.autocomplete",b).append(d("<a></a>").text(b.label)).appendTo(a)},_move:function(a,b){if(this.menu.element.is(":visible"))if(this.menu.first()&&/^previous/.test(a)||this.menu.last()&&/^next/.test(a)){this.element.val(this.term);this.menu.deactivate()}else this.menu[a](b);else this.search(null,b)},widget:function(){return this.menu.element}});d.extend(d.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,
"\\$&")},filter:function(a,b){var g=new RegExp(d.ui.autocomplete.escapeRegex(b),"i");return d.grep(a,function(c){return g.test(c.label||c.value||c)})}})})(jQuery);
(function(d){d.widget("ui.menu",{_create:function(){var e=this;this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({role:"listbox","aria-activedescendant":"ui-active-menuitem"}).click(function(a){if(d(a.target).closest(".ui-menu-item a").length){a.preventDefault();e.select(a)}});this.refresh()},refresh:function(){var e=this;this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","menuitem").children("a").addClass("ui-corner-all").attr("tabindex",
-1).mouseenter(function(a){e.activate(a,d(this).parent())}).mouseleave(function(){e.deactivate()})},activate:function(e,a){this.deactivate();if(this.hasScroll()){var b=a.offset().top-this.element.offset().top,g=this.element.scrollTop(),c=this.element.height();if(b<0)this.element.scrollTop(g+b);else b>=c&&this.element.scrollTop(g+b-c+a.height())}this.active=a.eq(0).children("a").addClass("ui-state-hover").attr("id","ui-active-menuitem").end();this._trigger("focus",e,{item:a})},deactivate:function(){if(this.active){this.active.children("a").removeClass("ui-state-hover").removeAttr("id");
this._trigger("blur");this.active=null}},next:function(e){this.move("next",".ui-menu-item:first",e)},previous:function(e){this.move("prev",".ui-menu-item:last",e)},first:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},last:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},move:function(e,a,b){if(this.active){e=this.active[e+"All"](".ui-menu-item").eq(0);e.length?this.activate(b,e):this.activate(b,this.element.children(a))}else this.activate(b,
this.element.children(a))},nextPage:function(e){if(this.hasScroll())if(!this.active||this.last())this.activate(e,this.element.children(".ui-menu-item:first"));else{var a=this.active.offset().top,b=this.element.height(),g=this.element.children(".ui-menu-item").filter(function(){var c=d(this).offset().top-a-b+d(this).height();return c<10&&c>-10});g.length||(g=this.element.children(".ui-menu-item:last"));this.activate(e,g)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||
this.last()?":first":":last"))},previousPage:function(e){if(this.hasScroll())if(!this.active||this.first())this.activate(e,this.element.children(".ui-menu-item:last"));else{var a=this.active.offset().top,b=this.element.height();result=this.element.children(".ui-menu-item").filter(function(){var g=d(this).offset().top-a+b-d(this).height();return g<10&&g>-10});result.length||(result=this.element.children(".ui-menu-item:first"));this.activate(e,result)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||
this.first()?":last":":first"))},hasScroll:function(){return this.element.height()<this.element[d.fn.prop?"prop":"attr"]("scrollHeight")},select:function(e){this._trigger("selected",e,{item:this.active})}})})(jQuery);
;/*
 * jQuery UI Button 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(b){var h,i,j,g,l=function(){var a=b(this).find(":ui-button");setTimeout(function(){a.button("refresh")},1)},k=function(a){var c=a.name,e=a.form,f=b([]);if(c)f=e?b(e).find("[name='"+c+"']"):b("[name='"+c+"']",a.ownerDocument).filter(function(){return!this.form});return f};b.widget("ui.button",{options:{disabled:null,text:true,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",l);if(typeof this.options.disabled!==
"boolean")this.options.disabled=this.element.attr("disabled");this._determineButtonType();this.hasTitle=!!this.buttonElement.attr("title");var a=this,c=this.options,e=this.type==="checkbox"||this.type==="radio",f="ui-state-hover"+(!e?" ui-state-active":"");if(c.label===null)c.label=this.buttonElement.html();if(this.element.is(":disabled"))c.disabled=true;this.buttonElement.addClass("ui-button ui-widget ui-state-default ui-corner-all").attr("role","button").bind("mouseenter.button",function(){if(!c.disabled){b(this).addClass("ui-state-hover");
this===h&&b(this).addClass("ui-state-active")}}).bind("mouseleave.button",function(){c.disabled||b(this).removeClass(f)}).bind("click.button",function(d){if(c.disabled){d.preventDefault();d.stopImmediatePropagation()}});this.element.bind("focus.button",function(){a.buttonElement.addClass("ui-state-focus")}).bind("blur.button",function(){a.buttonElement.removeClass("ui-state-focus")});if(e){this.element.bind("change.button",function(){g||a.refresh()});this.buttonElement.bind("mousedown.button",function(d){if(!c.disabled){g=
false;i=d.pageX;j=d.pageY}}).bind("mouseup.button",function(d){if(!c.disabled)if(i!==d.pageX||j!==d.pageY)g=true})}if(this.type==="checkbox")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).toggleClass("ui-state-active");a.buttonElement.attr("aria-pressed",a.element[0].checked)});else if(this.type==="radio")this.buttonElement.bind("click.button",function(){if(c.disabled||g)return false;b(this).addClass("ui-state-active");a.buttonElement.attr("aria-pressed",true);
var d=a.element[0];k(d).not(d).map(function(){return b(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed",false)});else{this.buttonElement.bind("mousedown.button",function(){if(c.disabled)return false;b(this).addClass("ui-state-active");h=this;b(document).one("mouseup",function(){h=null})}).bind("mouseup.button",function(){if(c.disabled)return false;b(this).removeClass("ui-state-active")}).bind("keydown.button",function(d){if(c.disabled)return false;if(d.keyCode==b.ui.keyCode.SPACE||
d.keyCode==b.ui.keyCode.ENTER)b(this).addClass("ui-state-active")}).bind("keyup.button",function(){b(this).removeClass("ui-state-active")});this.buttonElement.is("a")&&this.buttonElement.keyup(function(d){d.keyCode===b.ui.keyCode.SPACE&&b(this).click()})}this._setOption("disabled",c.disabled);this._resetButton()},_determineButtonType:function(){this.type=this.element.is(":checkbox")?"checkbox":this.element.is(":radio")?"radio":this.element.is("input")?"input":"button";if(this.type==="checkbox"||this.type===
"radio"){var a=this.element.parents().filter(":last"),c="label[for="+this.element.attr("id")+"]";this.buttonElement=a.find(c);if(!this.buttonElement.length){a=a.length?a.siblings():this.element.siblings();this.buttonElement=a.filter(c);if(!this.buttonElement.length)this.buttonElement=a.find(c)}this.element.addClass("ui-helper-hidden-accessible");(a=this.element.is(":checked"))&&this.buttonElement.addClass("ui-state-active");this.buttonElement.attr("aria-pressed",a)}else this.buttonElement=this.element},
widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible");this.buttonElement.removeClass("ui-button ui-widget ui-state-default ui-corner-all ui-state-hover ui-state-active  ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only").removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());this.hasTitle||this.buttonElement.removeAttr("title");
b.Widget.prototype.destroy.call(this)},_setOption:function(a,c){b.Widget.prototype._setOption.apply(this,arguments);if(a==="disabled")c?this.element.attr("disabled",true):this.element.removeAttr("disabled");else this._resetButton()},refresh:function(){var a=this.element.is(":disabled");a!==this.options.disabled&&this._setOption("disabled",a);if(this.type==="radio")k(this.element[0]).each(function(){b(this).is(":checked")?b(this).button("widget").addClass("ui-state-active").attr("aria-pressed",true):
b(this).button("widget").removeClass("ui-state-active").attr("aria-pressed",false)});else if(this.type==="checkbox")this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed",true):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed",false)},_resetButton:function(){if(this.type==="input")this.options.label&&this.element.val(this.options.label);else{var a=this.buttonElement.removeClass("ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only"),
c=b("<span></span>").addClass("ui-button-text").html(this.options.label).appendTo(a.empty()).text(),e=this.options.icons,f=e.primary&&e.secondary,d=[];if(e.primary||e.secondary){if(this.options.text)d.push("ui-button-text-icon"+(f?"s":e.primary?"-primary":"-secondary"));e.primary&&a.prepend("<span class='ui-button-icon-primary ui-icon "+e.primary+"'></span>");e.secondary&&a.append("<span class='ui-button-icon-secondary ui-icon "+e.secondary+"'></span>");if(!this.options.text){d.push(f?"ui-button-icons-only":
"ui-button-icon-only");this.hasTitle||a.attr("title",c)}}else d.push("ui-button-text-only");a.addClass(d.join(" "))}}});b.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(a,c){a==="disabled"&&this.buttons.button("option",a,c);b.Widget.prototype._setOption.apply(this,arguments)},refresh:function(){var a=this.element.css("direction")===
"ltr";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(a?"ui-corner-left":"ui-corner-right").end().filter(":last").addClass(a?"ui-corner-right":"ui-corner-left").end().end()},destroy:function(){this.element.removeClass("ui-buttonset");this.buttons.map(function(){return b(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
b.Widget.prototype.destroy.call(this)}})})(jQuery);
;/*
 * jQuery UI Dialog 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function(c,l){var m={buttons:true,height:true,maxHeight:true,maxWidth:true,minHeight:true,minWidth:true,width:true},n={maxHeight:true,maxWidth:true,minHeight:true,minWidth:true},o=c.attrFn||{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true,click:true};c.widget("ui.dialog",{options:{autoOpen:true,buttons:{},closeOnEscape:true,closeText:"close",dialogClass:"",draggable:true,hide:null,height:"auto",maxHeight:false,maxWidth:false,minHeight:150,minWidth:150,modal:false,
position:{my:"center",at:"center",collision:"fit",using:function(a){var b=c(this).css(a).offset().top;b<0&&c(this).css("top",a.top-b)}},resizable:true,show:null,stack:true,title:"",width:300,zIndex:1E3},_create:function(){this.originalTitle=this.element.attr("title");if(typeof this.originalTitle!=="string")this.originalTitle="";this.options.title=this.options.title||this.originalTitle;var a=this,b=a.options,d=b.title||"&#160;",e=c.ui.dialog.getTitleId(a.element),g=(a.uiDialog=c("<div></div>")).appendTo(document.body).hide().addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+
b.dialogClass).css({zIndex:b.zIndex}).attr("tabIndex",-1).css("outline",0).keydown(function(i){if(b.closeOnEscape&&i.keyCode&&i.keyCode===c.ui.keyCode.ESCAPE){a.close(i);i.preventDefault()}}).attr({role:"dialog","aria-labelledby":e}).mousedown(function(i){a.moveToTop(false,i)});a.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(g);var f=(a.uiDialogTitlebar=c("<div></div>")).addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(g),
h=c('<a href="#"></a>').addClass("ui-dialog-titlebar-close ui-corner-all").attr("role","button").hover(function(){h.addClass("ui-state-hover")},function(){h.removeClass("ui-state-hover")}).focus(function(){h.addClass("ui-state-focus")}).blur(function(){h.removeClass("ui-state-focus")}).click(function(i){a.close(i);return false}).appendTo(f);(a.uiDialogTitlebarCloseText=c("<span></span>")).addClass("ui-icon ui-icon-closethick").text(b.closeText).appendTo(h);c("<span></span>").addClass("ui-dialog-title").attr("id",
e).html(d).prependTo(f);if(c.isFunction(b.beforeclose)&&!c.isFunction(b.beforeClose))b.beforeClose=b.beforeclose;f.find("*").add(f).disableSelection();b.draggable&&c.fn.draggable&&a._makeDraggable();b.resizable&&c.fn.resizable&&a._makeResizable();a._createButtons(b.buttons);a._isOpen=false;c.fn.bgiframe&&g.bgiframe()},_init:function(){this.options.autoOpen&&this.open()},destroy:function(){var a=this;a.overlay&&a.overlay.destroy();a.uiDialog.hide();a.element.unbind(".dialog").removeData("dialog").removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body");
a.uiDialog.remove();a.originalTitle&&a.element.attr("title",a.originalTitle);return a},widget:function(){return this.uiDialog},close:function(a){var b=this,d,e;if(false!==b._trigger("beforeClose",a)){b.overlay&&b.overlay.destroy();b.uiDialog.unbind("keypress.ui-dialog");b._isOpen=false;if(b.options.hide)b.uiDialog.hide(b.options.hide,function(){b._trigger("close",a)});else{b.uiDialog.hide();b._trigger("close",a)}c.ui.dialog.overlay.resize();if(b.options.modal){d=0;c(".ui-dialog").each(function(){if(this!==
b.uiDialog[0]){e=c(this).css("z-index");isNaN(e)||(d=Math.max(d,e))}});c.ui.dialog.maxZ=d}return b}},isOpen:function(){return this._isOpen},moveToTop:function(a,b){var d=this,e=d.options;if(e.modal&&!a||!e.stack&&!e.modal)return d._trigger("focus",b);if(e.zIndex>c.ui.dialog.maxZ)c.ui.dialog.maxZ=e.zIndex;if(d.overlay){c.ui.dialog.maxZ+=1;d.overlay.$el.css("z-index",c.ui.dialog.overlay.maxZ=c.ui.dialog.maxZ)}a={scrollTop:d.element.attr("scrollTop"),scrollLeft:d.element.attr("scrollLeft")};c.ui.dialog.maxZ+=
1;d.uiDialog.css("z-index",c.ui.dialog.maxZ);d.element.attr(a);d._trigger("focus",b);return d},open:function(){if(!this._isOpen){var a=this,b=a.options,d=a.uiDialog;a.overlay=b.modal?new c.ui.dialog.overlay(a):null;a._size();a._position(b.position);d.show(b.show);a.moveToTop(true);b.modal&&d.bind("keypress.ui-dialog",function(e){if(e.keyCode===c.ui.keyCode.TAB){var g=c(":tabbable",this),f=g.filter(":first");g=g.filter(":last");if(e.target===g[0]&&!e.shiftKey){f.focus(1);return false}else if(e.target===
f[0]&&e.shiftKey){g.focus(1);return false}}});c(a.element.find(":tabbable").get().concat(d.find(".ui-dialog-buttonpane :tabbable").get().concat(d.get()))).eq(0).focus();a._isOpen=true;a._trigger("open");return a}},_createButtons:function(a){var b=this,d=false,e=c("<div></div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),g=c("<div></div>").addClass("ui-dialog-buttonset").appendTo(e);b.uiDialog.find(".ui-dialog-buttonpane").remove();typeof a==="object"&&a!==null&&c.each(a,
function(){return!(d=true)});if(d){c.each(a,function(f,h){h=c.isFunction(h)?{click:h,text:f}:h;var i=c('<button type="button"></button>').click(function(){h.click.apply(b.element[0],arguments)}).appendTo(g);c.each(h,function(j,k){if(j!=="click")j in o?i[j](k):i.attr(j,k)});c.fn.button&&i.button()});e.appendTo(b.uiDialog)}},_makeDraggable:function(){function a(f){return{position:f.position,offset:f.offset}}var b=this,d=b.options,e=c(document),g;b.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",
handle:".ui-dialog-titlebar",containment:"document",start:function(f,h){g=d.height==="auto"?"auto":c(this).height();c(this).height(c(this).height()).addClass("ui-dialog-dragging");b._trigger("dragStart",f,a(h))},drag:function(f,h){b._trigger("drag",f,a(h))},stop:function(f,h){d.position=[h.position.left-e.scrollLeft(),h.position.top-e.scrollTop()];c(this).removeClass("ui-dialog-dragging").height(g);b._trigger("dragStop",f,a(h));c.ui.dialog.overlay.resize()}})},_makeResizable:function(a){function b(f){return{originalPosition:f.originalPosition,
originalSize:f.originalSize,position:f.position,size:f.size}}a=a===l?this.options.resizable:a;var d=this,e=d.options,g=d.uiDialog.css("position");a=typeof a==="string"?a:"n,e,s,w,se,sw,ne,nw";d.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:d.element,maxWidth:e.maxWidth,maxHeight:e.maxHeight,minWidth:e.minWidth,minHeight:d._minHeight(),handles:a,start:function(f,h){c(this).addClass("ui-dialog-resizing");d._trigger("resizeStart",f,b(h))},resize:function(f,h){d._trigger("resize",
f,b(h))},stop:function(f,h){c(this).removeClass("ui-dialog-resizing");e.height=c(this).height();e.width=c(this).width();d._trigger("resizeStop",f,b(h));c.ui.dialog.overlay.resize()}}).css("position",g).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")},_minHeight:function(){var a=this.options;return a.height==="auto"?a.minHeight:Math.min(a.minHeight,a.height)},_position:function(a){var b=[],d=[0,0],e;if(a){if(typeof a==="string"||typeof a==="object"&&"0"in a){b=a.split?a.split(" "):
[a[0],a[1]];if(b.length===1)b[1]=b[0];c.each(["left","top"],function(g,f){if(+b[g]===b[g]){d[g]=b[g];b[g]=f}});a={my:b.join(" "),at:b.join(" "),offset:d.join(" ")}}a=c.extend({},c.ui.dialog.prototype.options.position,a)}else a=c.ui.dialog.prototype.options.position;(e=this.uiDialog.is(":visible"))||this.uiDialog.show();this.uiDialog.css({top:0,left:0}).position(c.extend({of:window},a));e||this.uiDialog.hide()},_setOptions:function(a){var b=this,d={},e=false;c.each(a,function(g,f){b._setOption(g,f);
if(g in m)e=true;if(g in n)d[g]=f});e&&this._size();this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option",d)},_setOption:function(a,b){var d=this,e=d.uiDialog;switch(a){case "beforeclose":a="beforeClose";break;case "buttons":d._createButtons(b);break;case "closeText":d.uiDialogTitlebarCloseText.text(""+b);break;case "dialogClass":e.removeClass(d.options.dialogClass).addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+b);break;case "disabled":b?e.addClass("ui-dialog-disabled"):
e.removeClass("ui-dialog-disabled");break;case "draggable":var g=e.is(":data(draggable)");g&&!b&&e.draggable("destroy");!g&&b&&d._makeDraggable();break;case "position":d._position(b);break;case "resizable":(g=e.is(":data(resizable)"))&&!b&&e.resizable("destroy");g&&typeof b==="string"&&e.resizable("option","handles",b);!g&&b!==false&&d._makeResizable(b);break;case "title":c(".ui-dialog-title",d.uiDialogTitlebar).html(""+(b||"&#160;"));break}c.Widget.prototype._setOption.apply(d,arguments)},_size:function(){var a=
this.options,b,d,e=this.uiDialog.is(":visible");this.element.show().css({width:"auto",minHeight:0,height:0});if(a.minWidth>a.width)a.width=a.minWidth;b=this.uiDialog.css({height:"auto",width:a.width}).height();d=Math.max(0,a.minHeight-b);if(a.height==="auto")if(c.support.minHeight)this.element.css({minHeight:d,height:"auto"});else{this.uiDialog.show();a=this.element.css("height","auto").height();e||this.uiDialog.hide();this.element.height(Math.max(a,d))}else this.element.height(Math.max(a.height-
b,0));this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())}});c.extend(c.ui.dialog,{version:"1.8.14",uuid:0,maxZ:0,getTitleId:function(a){a=a.attr("id");if(!a){this.uuid+=1;a=this.uuid}return"ui-dialog-title-"+a},overlay:function(a){this.$el=c.ui.dialog.overlay.create(a)}});c.extend(c.ui.dialog.overlay,{instances:[],oldInstances:[],maxZ:0,events:c.map("focus,mousedown,mouseup,keydown,keypress,click".split(","),function(a){return a+".dialog-overlay"}).join(" "),
create:function(a){if(this.instances.length===0){setTimeout(function(){c.ui.dialog.overlay.instances.length&&c(document).bind(c.ui.dialog.overlay.events,function(d){if(c(d.target).zIndex()<c.ui.dialog.overlay.maxZ)return false})},1);c(document).bind("keydown.dialog-overlay",function(d){if(a.options.closeOnEscape&&d.keyCode&&d.keyCode===c.ui.keyCode.ESCAPE){a.close(d);d.preventDefault()}});c(window).bind("resize.dialog-overlay",c.ui.dialog.overlay.resize)}var b=(this.oldInstances.pop()||c("<div></div>").addClass("ui-widget-overlay")).appendTo(document.body).css({width:this.width(),
height:this.height()});c.fn.bgiframe&&b.bgiframe();this.instances.push(b);return b},destroy:function(a){var b=c.inArray(a,this.instances);b!=-1&&this.oldInstances.push(this.instances.splice(b,1)[0]);this.instances.length===0&&c([document,window]).unbind(".dialog-overlay");a.remove();var d=0;c.each(this.instances,function(){d=Math.max(d,this.css("z-index"))});this.maxZ=d},height:function(){var a,b;if(c.browser.msie&&c.browser.version<7){a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight);
b=Math.max(document.documentElement.offsetHeight,document.body.offsetHeight);return a<b?c(window).height()+"px":a+"px"}else return c(document).height()+"px"},width:function(){var a,b;if(c.browser.msie){a=Math.max(document.documentElement.scrollWidth,document.body.scrollWidth);b=Math.max(document.documentElement.offsetWidth,document.body.offsetWidth);return a<b?c(window).width()+"px":a+"px"}else return c(document).width()+"px"},resize:function(){var a=c([]);c.each(c.ui.dialog.overlay.instances,function(){a=
a.add(this)});a.css({width:0,height:0}).css({width:c.ui.dialog.overlay.width(),height:c.ui.dialog.overlay.height()})}});c.extend(c.ui.dialog.overlay.prototype,{destroy:function(){c.ui.dialog.overlay.destroy(this.$el)}})})(jQuery);
;/*
 * jQuery UI Slider 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.slider",d.ui.mouse,{widgetEventPrefix:"slide",options:{animate:false,distance:0,max:100,min:0,orientation:"horizontal",range:false,step:1,value:0,values:null},_create:function(){var b=this,a=this.options,c=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f=a.values&&a.values.length||1,e=[];this._mouseSliding=this._keySliding=false;this._animateOff=true;this._handleIndex=null;this._detectOrientation();this._mouseInit();this.element.addClass("ui-slider ui-slider-"+
this.orientation+" ui-widget ui-widget-content ui-corner-all"+(a.disabled?" ui-slider-disabled ui-disabled":""));this.range=d([]);if(a.range){if(a.range===true){if(!a.values)a.values=[this._valueMin(),this._valueMin()];if(a.values.length&&a.values.length!==2)a.values=[a.values[0],a.values[0]]}this.range=d("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(a.range==="min"||a.range==="max"?" ui-slider-range-"+a.range:""))}for(var j=c.length;j<f;j+=1)e.push("<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>");
this.handles=c.add(d(e.join("")).appendTo(b.element));this.handle=this.handles.eq(0);this.handles.add(this.range).filter("a").click(function(g){g.preventDefault()}).hover(function(){a.disabled||d(this).addClass("ui-state-hover")},function(){d(this).removeClass("ui-state-hover")}).focus(function(){if(a.disabled)d(this).blur();else{d(".ui-slider .ui-state-focus").removeClass("ui-state-focus");d(this).addClass("ui-state-focus")}}).blur(function(){d(this).removeClass("ui-state-focus")});this.handles.each(function(g){d(this).data("index.ui-slider-handle",
g)});this.handles.keydown(function(g){var k=true,l=d(this).data("index.ui-slider-handle"),i,h,m;if(!b.options.disabled){switch(g.keyCode){case d.ui.keyCode.HOME:case d.ui.keyCode.END:case d.ui.keyCode.PAGE_UP:case d.ui.keyCode.PAGE_DOWN:case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:k=false;if(!b._keySliding){b._keySliding=true;d(this).addClass("ui-state-active");i=b._start(g,l);if(i===false)return}break}m=b.options.step;i=b.options.values&&b.options.values.length?
(h=b.values(l)):(h=b.value());switch(g.keyCode){case d.ui.keyCode.HOME:h=b._valueMin();break;case d.ui.keyCode.END:h=b._valueMax();break;case d.ui.keyCode.PAGE_UP:h=b._trimAlignValue(i+(b._valueMax()-b._valueMin())/5);break;case d.ui.keyCode.PAGE_DOWN:h=b._trimAlignValue(i-(b._valueMax()-b._valueMin())/5);break;case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:if(i===b._valueMax())return;h=b._trimAlignValue(i+m);break;case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:if(i===b._valueMin())return;h=b._trimAlignValue(i-
m);break}b._slide(g,l,h);return k}}).keyup(function(g){var k=d(this).data("index.ui-slider-handle");if(b._keySliding){b._keySliding=false;b._stop(g,k);b._change(g,k);d(this).removeClass("ui-state-active")}});this._refreshValue();this._animateOff=false},destroy:function(){this.handles.remove();this.range.remove();this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider");this._mouseDestroy();
return this},_mouseCapture:function(b){var a=this.options,c,f,e,j,g;if(a.disabled)return false;this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()};this.elementOffset=this.element.offset();c=this._normValueFromMouse({x:b.pageX,y:b.pageY});f=this._valueMax()-this._valueMin()+1;j=this;this.handles.each(function(k){var l=Math.abs(c-j.values(k));if(f>l){f=l;e=d(this);g=k}});if(a.range===true&&this.values(1)===a.min){g+=1;e=d(this.handles[g])}if(this._start(b,g)===false)return false;
this._mouseSliding=true;j._handleIndex=g;e.addClass("ui-state-active").focus();a=e.offset();this._clickOffset=!d(b.target).parents().andSelf().is(".ui-slider-handle")?{left:0,top:0}:{left:b.pageX-a.left-e.width()/2,top:b.pageY-a.top-e.height()/2-(parseInt(e.css("borderTopWidth"),10)||0)-(parseInt(e.css("borderBottomWidth"),10)||0)+(parseInt(e.css("marginTop"),10)||0)};this.handles.hasClass("ui-state-hover")||this._slide(b,g,c);return this._animateOff=true},_mouseStart:function(){return true},_mouseDrag:function(b){var a=
this._normValueFromMouse({x:b.pageX,y:b.pageY});this._slide(b,this._handleIndex,a);return false},_mouseStop:function(b){this.handles.removeClass("ui-state-active");this._mouseSliding=false;this._stop(b,this._handleIndex);this._change(b,this._handleIndex);this._clickOffset=this._handleIndex=null;return this._animateOff=false},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(b){var a;if(this.orientation==="horizontal"){a=
this.elementSize.width;b=b.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)}else{a=this.elementSize.height;b=b.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)}a=b/a;if(a>1)a=1;if(a<0)a=0;if(this.orientation==="vertical")a=1-a;b=this._valueMax()-this._valueMin();return this._trimAlignValue(this._valueMin()+a*b)},_start:function(b,a){var c={handle:this.handles[a],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(a);
c.values=this.values()}return this._trigger("start",b,c)},_slide:function(b,a,c){var f;if(this.options.values&&this.options.values.length){f=this.values(a?0:1);if(this.options.values.length===2&&this.options.range===true&&(a===0&&c>f||a===1&&c<f))c=f;if(c!==this.values(a)){f=this.values();f[a]=c;b=this._trigger("slide",b,{handle:this.handles[a],value:c,values:f});this.values(a?0:1);b!==false&&this.values(a,c,true)}}else if(c!==this.value()){b=this._trigger("slide",b,{handle:this.handles[a],value:c});
b!==false&&this.value(c)}},_stop:function(b,a){var c={handle:this.handles[a],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(a);c.values=this.values()}this._trigger("stop",b,c)},_change:function(b,a){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[a],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(a);c.values=this.values()}this._trigger("change",b,c)}},value:function(b){if(arguments.length){this.options.value=
this._trimAlignValue(b);this._refreshValue();this._change(null,0)}else return this._value()},values:function(b,a){var c,f,e;if(arguments.length>1){this.options.values[b]=this._trimAlignValue(a);this._refreshValue();this._change(null,b)}else if(arguments.length)if(d.isArray(arguments[0])){c=this.options.values;f=arguments[0];for(e=0;e<c.length;e+=1){c[e]=this._trimAlignValue(f[e]);this._change(null,e)}this._refreshValue()}else return this.options.values&&this.options.values.length?this._values(b):
this.value();else return this._values()},_setOption:function(b,a){var c,f=0;if(d.isArray(this.options.values))f=this.options.values.length;d.Widget.prototype._setOption.apply(this,arguments);switch(b){case "disabled":if(a){this.handles.filter(".ui-state-focus").blur();this.handles.removeClass("ui-state-hover");this.handles.attr("disabled","disabled");this.element.addClass("ui-disabled")}else{this.handles.removeAttr("disabled");this.element.removeClass("ui-disabled")}break;case "orientation":this._detectOrientation();
this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation);this._refreshValue();break;case "value":this._animateOff=true;this._refreshValue();this._change(null,0);this._animateOff=false;break;case "values":this._animateOff=true;this._refreshValue();for(c=0;c<f;c+=1)this._change(null,c);this._animateOff=false;break}},_value:function(){var b=this.options.value;return b=this._trimAlignValue(b)},_values:function(b){var a,c;if(arguments.length){a=this.options.values[b];
return a=this._trimAlignValue(a)}else{a=this.options.values.slice();for(c=0;c<a.length;c+=1)a[c]=this._trimAlignValue(a[c]);return a}},_trimAlignValue:function(b){if(b<=this._valueMin())return this._valueMin();if(b>=this._valueMax())return this._valueMax();var a=this.options.step>0?this.options.step:1,c=(b-this._valueMin())%a;alignValue=b-c;if(Math.abs(c)*2>=a)alignValue+=c>0?a:-a;return parseFloat(alignValue.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},
_refreshValue:function(){var b=this.options.range,a=this.options,c=this,f=!this._animateOff?a.animate:false,e,j={},g,k,l,i;if(this.options.values&&this.options.values.length)this.handles.each(function(h){e=(c.values(h)-c._valueMin())/(c._valueMax()-c._valueMin())*100;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";d(this).stop(1,1)[f?"animate":"css"](j,a.animate);if(c.options.range===true)if(c.orientation==="horizontal"){if(h===0)c.range.stop(1,1)[f?"animate":"css"]({left:e+"%"},a.animate);
if(h===1)c.range[f?"animate":"css"]({width:e-g+"%"},{queue:false,duration:a.animate})}else{if(h===0)c.range.stop(1,1)[f?"animate":"css"]({bottom:e+"%"},a.animate);if(h===1)c.range[f?"animate":"css"]({height:e-g+"%"},{queue:false,duration:a.animate})}g=e});else{k=this.value();l=this._valueMin();i=this._valueMax();e=i!==l?(k-l)/(i-l)*100:0;j[c.orientation==="horizontal"?"left":"bottom"]=e+"%";this.handle.stop(1,1)[f?"animate":"css"](j,a.animate);if(b==="min"&&this.orientation==="horizontal")this.range.stop(1,
1)[f?"animate":"css"]({width:e+"%"},a.animate);if(b==="max"&&this.orientation==="horizontal")this.range[f?"animate":"css"]({width:100-e+"%"},{queue:false,duration:a.animate});if(b==="min"&&this.orientation==="vertical")this.range.stop(1,1)[f?"animate":"css"]({height:e+"%"},a.animate);if(b==="max"&&this.orientation==="vertical")this.range[f?"animate":"css"]({height:100-e+"%"},{queue:false,duration:a.animate})}}});d.extend(d.ui.slider,{version:"1.8.14"})})(jQuery);
;/*
 * jQuery UI Tabs 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(d,p){function u(){return++v}function w(){return++x}var v=0,x=0;d.widget("ui.tabs",{options:{add:null,ajaxOptions:null,cache:false,cookie:null,collapsible:false,disable:null,disabled:[],enable:null,event:"click",fx:null,idPrefix:"ui-tabs-",load:null,panelTemplate:"<div></div>",remove:null,select:null,show:null,spinner:"<em>Loading&#8230;</em>",tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},_create:function(){this._tabify(true)},_setOption:function(b,e){if(b=="selected")this.options.collapsible&&
e==this.options.selected||this.select(e);else{this.options[b]=e;this._tabify()}},_tabId:function(b){return b.title&&b.title.replace(/\s/g,"_").replace(/[^\w\u00c0-\uFFFF-]/g,"")||this.options.idPrefix+u()},_sanitizeSelector:function(b){return b.replace(/:/g,"\\:")},_cookie:function(){var b=this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+w());return d.cookie.apply(null,[b].concat(d.makeArray(arguments)))},_ui:function(b,e){return{tab:b,panel:e,index:this.anchors.index(b)}},_cleanup:function(){this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function(){var b=
d(this);b.html(b.data("label.tabs")).removeData("label.tabs")})},_tabify:function(b){function e(g,f){g.css("display","");!d.support.opacity&&f.opacity&&g[0].style.removeAttribute("filter")}var a=this,c=this.options,h=/^#.+/;this.list=this.element.find("ol,ul").eq(0);this.lis=d(" > li:has(a[href])",this.list);this.anchors=this.lis.map(function(){return d("a",this)[0]});this.panels=d([]);this.anchors.each(function(g,f){var i=d(f).attr("href"),l=i.split("#")[0],q;if(l&&(l===location.toString().split("#")[0]||
(q=d("base")[0])&&l===q.href)){i=f.hash;f.href=i}if(h.test(i))a.panels=a.panels.add(a.element.find(a._sanitizeSelector(i)));else if(i&&i!=="#"){d.data(f,"href.tabs",i);d.data(f,"load.tabs",i.replace(/#.*$/,""));i=a._tabId(f);f.href="#"+i;f=a.element.find("#"+i);if(!f.length){f=d(c.panelTemplate).attr("id",i).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(a.panels[g-1]||a.list);f.data("destroy.tabs",true)}a.panels=a.panels.add(f)}else c.disabled.push(g)});if(b){this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all");
this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.lis.addClass("ui-state-default ui-corner-top");this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom");if(c.selected===p){location.hash&&this.anchors.each(function(g,f){if(f.hash==location.hash){c.selected=g;return false}});if(typeof c.selected!=="number"&&c.cookie)c.selected=parseInt(a._cookie(),10);if(typeof c.selected!=="number"&&this.lis.filter(".ui-tabs-selected").length)c.selected=
this.lis.index(this.lis.filter(".ui-tabs-selected"));c.selected=c.selected||(this.lis.length?0:-1)}else if(c.selected===null)c.selected=-1;c.selected=c.selected>=0&&this.anchors[c.selected]||c.selected<0?c.selected:0;c.disabled=d.unique(c.disabled.concat(d.map(this.lis.filter(".ui-state-disabled"),function(g){return a.lis.index(g)}))).sort();d.inArray(c.selected,c.disabled)!=-1&&c.disabled.splice(d.inArray(c.selected,c.disabled),1);this.panels.addClass("ui-tabs-hide");this.lis.removeClass("ui-tabs-selected ui-state-active");
if(c.selected>=0&&this.anchors.length){a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash)).removeClass("ui-tabs-hide");this.lis.eq(c.selected).addClass("ui-tabs-selected ui-state-active");a.element.queue("tabs",function(){a._trigger("show",null,a._ui(a.anchors[c.selected],a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash))[0]))});this.load(c.selected)}d(window).bind("unload",function(){a.lis.add(a.anchors).unbind(".tabs");a.lis=a.anchors=a.panels=null})}else c.selected=this.lis.index(this.lis.filter(".ui-tabs-selected"));
this.element[c.collapsible?"addClass":"removeClass"]("ui-tabs-collapsible");c.cookie&&this._cookie(c.selected,c.cookie);b=0;for(var j;j=this.lis[b];b++)d(j)[d.inArray(b,c.disabled)!=-1&&!d(j).hasClass("ui-tabs-selected")?"addClass":"removeClass"]("ui-state-disabled");c.cache===false&&this.anchors.removeData("cache.tabs");this.lis.add(this.anchors).unbind(".tabs");if(c.event!=="mouseover"){var k=function(g,f){f.is(":not(.ui-state-disabled)")&&f.addClass("ui-state-"+g)},n=function(g,f){f.removeClass("ui-state-"+
g)};this.lis.bind("mouseover.tabs",function(){k("hover",d(this))});this.lis.bind("mouseout.tabs",function(){n("hover",d(this))});this.anchors.bind("focus.tabs",function(){k("focus",d(this).closest("li"))});this.anchors.bind("blur.tabs",function(){n("focus",d(this).closest("li"))})}var m,o;if(c.fx)if(d.isArray(c.fx)){m=c.fx[0];o=c.fx[1]}else m=o=c.fx;var r=o?function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.hide().removeClass("ui-tabs-hide").animate(o,o.duration||"normal",
function(){e(f,o);a._trigger("show",null,a._ui(g,f[0]))})}:function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.removeClass("ui-tabs-hide");a._trigger("show",null,a._ui(g,f[0]))},s=m?function(g,f){f.animate(m,m.duration||"normal",function(){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");e(f,m);a.element.dequeue("tabs")})}:function(g,f){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");a.element.dequeue("tabs")};
this.anchors.bind(c.event+".tabs",function(){var g=this,f=d(g).closest("li"),i=a.panels.filter(":not(.ui-tabs-hide)"),l=a.element.find(a._sanitizeSelector(g.hash));if(f.hasClass("ui-tabs-selected")&&!c.collapsible||f.hasClass("ui-state-disabled")||f.hasClass("ui-state-processing")||a.panels.filter(":animated").length||a._trigger("select",null,a._ui(this,l[0]))===false){this.blur();return false}c.selected=a.anchors.index(this);a.abort();if(c.collapsible)if(f.hasClass("ui-tabs-selected")){c.selected=
-1;c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){s(g,i)}).dequeue("tabs");this.blur();return false}else if(!i.length){c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this));this.blur();return false}c.cookie&&a._cookie(c.selected,c.cookie);if(l.length){i.length&&a.element.queue("tabs",function(){s(g,i)});a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this))}else throw"jQuery UI Tabs: Mismatching fragment identifier.";
d.browser.msie&&this.blur()});this.anchors.bind("click.tabs",function(){return false})},_getIndex:function(b){if(typeof b=="string")b=this.anchors.index(this.anchors.filter("[href$="+b+"]"));return b},destroy:function(){var b=this.options;this.abort();this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs");this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.anchors.each(function(){var e=
d.data(this,"href.tabs");if(e)this.href=e;var a=d(this).unbind(".tabs");d.each(["href","load","cache"],function(c,h){a.removeData(h+".tabs")})});this.lis.unbind(".tabs").add(this.panels).each(function(){d.data(this,"destroy.tabs")?d(this).remove():d(this).removeClass("ui-state-default ui-corner-top ui-tabs-selected ui-state-active ui-state-hover ui-state-focus ui-state-disabled ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide")});b.cookie&&this._cookie(null,b.cookie);return this},add:function(b,
e,a){if(a===p)a=this.anchors.length;var c=this,h=this.options;e=d(h.tabTemplate.replace(/#\{href\}/g,b).replace(/#\{label\}/g,e));b=!b.indexOf("#")?b.replace("#",""):this._tabId(d("a",e)[0]);e.addClass("ui-state-default ui-corner-top").data("destroy.tabs",true);var j=c.element.find("#"+b);j.length||(j=d(h.panelTemplate).attr("id",b).data("destroy.tabs",true));j.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide");if(a>=this.lis.length){e.appendTo(this.list);j.appendTo(this.list[0].parentNode)}else{e.insertBefore(this.lis[a]);
j.insertBefore(this.panels[a])}h.disabled=d.map(h.disabled,function(k){return k>=a?++k:k});this._tabify();if(this.anchors.length==1){h.selected=0;e.addClass("ui-tabs-selected ui-state-active");j.removeClass("ui-tabs-hide");this.element.queue("tabs",function(){c._trigger("show",null,c._ui(c.anchors[0],c.panels[0]))});this.load(0)}this._trigger("add",null,this._ui(this.anchors[a],this.panels[a]));return this},remove:function(b){b=this._getIndex(b);var e=this.options,a=this.lis.eq(b).remove(),c=this.panels.eq(b).remove();
if(a.hasClass("ui-tabs-selected")&&this.anchors.length>1)this.select(b+(b+1<this.anchors.length?1:-1));e.disabled=d.map(d.grep(e.disabled,function(h){return h!=b}),function(h){return h>=b?--h:h});this._tabify();this._trigger("remove",null,this._ui(a.find("a")[0],c[0]));return this},enable:function(b){b=this._getIndex(b);var e=this.options;if(d.inArray(b,e.disabled)!=-1){this.lis.eq(b).removeClass("ui-state-disabled");e.disabled=d.grep(e.disabled,function(a){return a!=b});this._trigger("enable",null,
this._ui(this.anchors[b],this.panels[b]));return this}},disable:function(b){b=this._getIndex(b);var e=this.options;if(b!=e.selected){this.lis.eq(b).addClass("ui-state-disabled");e.disabled.push(b);e.disabled.sort();this._trigger("disable",null,this._ui(this.anchors[b],this.panels[b]))}return this},select:function(b){b=this._getIndex(b);if(b==-1)if(this.options.collapsible&&this.options.selected!=-1)b=this.options.selected;else return this;this.anchors.eq(b).trigger(this.options.event+".tabs");return this},
load:function(b){b=this._getIndex(b);var e=this,a=this.options,c=this.anchors.eq(b)[0],h=d.data(c,"load.tabs");this.abort();if(!h||this.element.queue("tabs").length!==0&&d.data(c,"cache.tabs"))this.element.dequeue("tabs");else{this.lis.eq(b).addClass("ui-state-processing");if(a.spinner){var j=d("span",c);j.data("label.tabs",j.html()).html(a.spinner)}this.xhr=d.ajax(d.extend({},a.ajaxOptions,{url:h,success:function(k,n){e.element.find(e._sanitizeSelector(c.hash)).html(k);e._cleanup();a.cache&&d.data(c,
"cache.tabs",true);e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.success(k,n)}catch(m){}},error:function(k,n){e._cleanup();e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.error(k,n,b,c)}catch(m){}}}));e.element.dequeue("tabs");return this}},abort:function(){this.element.queue([]);this.panels.stop(false,true);this.element.queue("tabs",this.element.queue("tabs").splice(-2,2));if(this.xhr){this.xhr.abort();delete this.xhr}this._cleanup();return this},
url:function(b,e){this.anchors.eq(b).removeData("cache.tabs").data("load.tabs",e);return this},length:function(){return this.anchors.length}});d.extend(d.ui.tabs,{version:"1.8.14"});d.extend(d.ui.tabs.prototype,{rotation:null,rotate:function(b,e){var a=this,c=this.options,h=a._rotate||(a._rotate=function(j){clearTimeout(a.rotation);a.rotation=setTimeout(function(){var k=c.selected;a.select(++k<a.anchors.length?k:0)},b);j&&j.stopPropagation()});e=a._unrotate||(a._unrotate=!e?function(j){j.clientX&&
a.rotate(null)}:function(){t=c.selected;h()});if(b){this.element.bind("tabsshow",h);this.anchors.bind(c.event+".tabs",e);h()}else{clearTimeout(a.rotation);this.element.unbind("tabsshow",h);this.anchors.unbind(c.event+".tabs",e);delete this._rotate;delete this._unrotate}return this}})})(jQuery);
;/*
 * jQuery UI Datepicker 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function(d,C){function M(){this.debug=false;this._curInst=null;this._keyEvent=false;this._disabledInputs=[];this._inDialog=this._datepickerShowing=false;this._mainDivId="ui-datepicker-div";this._inlineClass="ui-datepicker-inline";this._appendClass="ui-datepicker-append";this._triggerClass="ui-datepicker-trigger";this._dialogClass="ui-datepicker-dialog";this._disableClass="ui-datepicker-disabled";this._unselectableClass="ui-datepicker-unselectable";this._currentClass="ui-datepicker-current-day";this._dayOverClass=
"ui-datepicker-days-cell-over";this.regional=[];this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su",
"Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:false,showMonthAfterYear:false,yearSuffix:""};this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:false,hideIfNoPrevNext:false,navigationAsDateFormat:false,gotoCurrent:false,changeMonth:false,changeYear:false,yearRange:"c-10:c+10",showOtherMonths:false,selectOtherMonths:false,showWeek:false,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",
minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:true,showButtonPanel:false,autoSize:false};d.extend(this._defaults,this.regional[""]);this.dpDiv=N(d('<div id="'+this._mainDivId+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}function N(a){return a.bind("mouseout",function(b){b=
d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");b.length&&b.removeClass("ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover")}).bind("mouseover",function(b){b=d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");if(!(d.datepicker._isDisabledDatepicker(J.inline?a.parent()[0]:J.input[0])||!b.length)){b.parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");b.addClass("ui-state-hover");
b.hasClass("ui-datepicker-prev")&&b.addClass("ui-datepicker-prev-hover");b.hasClass("ui-datepicker-next")&&b.addClass("ui-datepicker-next-hover")}})}function H(a,b){d.extend(a,b);for(var c in b)if(b[c]==null||b[c]==C)a[c]=b[c];return a}d.extend(d.ui,{datepicker:{version:"1.8.14"}});var A=(new Date).getTime(),J;d.extend(M.prototype,{markerClassName:"hasDatepicker",maxRows:4,log:function(){this.debug&&console.log.apply("",arguments)},_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(a){H(this._defaults,
a||{});return this},_attachDatepicker:function(a,b){var c=null;for(var e in this._defaults){var f=a.getAttribute("date:"+e);if(f){c=c||{};try{c[e]=eval(f)}catch(h){c[e]=f}}}e=a.nodeName.toLowerCase();f=e=="div"||e=="span";if(!a.id){this.uuid+=1;a.id="dp"+this.uuid}var i=this._newInst(d(a),f);i.settings=d.extend({},b||{},c||{});if(e=="input")this._connectDatepicker(a,i);else f&&this._inlineDatepicker(a,i)},_newInst:function(a,b){return{id:a[0].id.replace(/([^A-Za-z0-9_-])/g,"\\\\$1"),input:a,selectedDay:0,
selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:b,dpDiv:!b?this.dpDiv:N(d('<div class="'+this._inlineClass+' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}},_connectDatepicker:function(a,b){var c=d(a);b.append=d([]);b.trigger=d([]);if(!c.hasClass(this.markerClassName)){this._attachments(c,b);c.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",function(e,f,h){b.settings[f]=
h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});this._autoSize(b);d.data(a,"datepicker",b)}},_attachments:function(a,b){var c=this._get(b,"appendText"),e=this._get(b,"isRTL");b.append&&b.append.remove();if(c){b.append=d('<span class="'+this._appendClass+'">'+c+"</span>");a[e?"before":"after"](b.append)}a.unbind("focus",this._showDatepicker);b.trigger&&b.trigger.remove();c=this._get(b,"showOn");if(c=="focus"||c=="both")a.focus(this._showDatepicker);if(c=="button"||c=="both"){c=
this._get(b,"buttonText");var f=this._get(b,"buttonImage");b.trigger=d(this._get(b,"buttonImageOnly")?d("<img/>").addClass(this._triggerClass).attr({src:f,alt:c,title:c}):d('<button type="button"></button>').addClass(this._triggerClass).html(f==""?c:d("<img/>").attr({src:f,alt:c,title:c})));a[e?"before":"after"](b.trigger);b.trigger.click(function(){d.datepicker._datepickerShowing&&d.datepicker._lastInput==a[0]?d.datepicker._hideDatepicker():d.datepicker._showDatepicker(a[0]);return false})}},_autoSize:function(a){if(this._get(a,
"autoSize")&&!a.inline){var b=new Date(2009,11,20),c=this._get(a,"dateFormat");if(c.match(/[DM]/)){var e=function(f){for(var h=0,i=0,g=0;g<f.length;g++)if(f[g].length>h){h=f[g].length;i=g}return i};b.setMonth(e(this._get(a,c.match(/MM/)?"monthNames":"monthNamesShort")));b.setDate(e(this._get(a,c.match(/DD/)?"dayNames":"dayNamesShort"))+20-b.getDay())}a.input.attr("size",this._formatDate(a,b).length)}},_inlineDatepicker:function(a,b){var c=d(a);if(!c.hasClass(this.markerClassName)){c.addClass(this.markerClassName).append(b.dpDiv).bind("setData.datepicker",
function(e,f,h){b.settings[f]=h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});d.data(a,"datepicker",b);this._setDate(b,this._getDefaultDate(b),true);this._updateDatepicker(b);this._updateAlternate(b);b.dpDiv.show()}},_dialogDatepicker:function(a,b,c,e,f){a=this._dialogInst;if(!a){this.uuid+=1;this._dialogInput=d('<input type="text" id="'+("dp"+this.uuid)+'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');this._dialogInput.keydown(this._doKeyDown);d("body").append(this._dialogInput);
a=this._dialogInst=this._newInst(this._dialogInput,false);a.settings={};d.data(this._dialogInput[0],"datepicker",a)}H(a.settings,e||{});b=b&&b.constructor==Date?this._formatDate(a,b):b;this._dialogInput.val(b);this._pos=f?f.length?f:[f.pageX,f.pageY]:null;if(!this._pos)this._pos=[document.documentElement.clientWidth/2-100+(document.documentElement.scrollLeft||document.body.scrollLeft),document.documentElement.clientHeight/2-150+(document.documentElement.scrollTop||document.body.scrollTop)];this._dialogInput.css("left",
this._pos[0]+20+"px").css("top",this._pos[1]+"px");a.settings.onSelect=c;this._inDialog=true;this.dpDiv.addClass(this._dialogClass);this._showDatepicker(this._dialogInput[0]);d.blockUI&&d.blockUI(this.dpDiv);d.data(this._dialogInput[0],"datepicker",a);return this},_destroyDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();d.removeData(a,"datepicker");if(e=="input"){c.append.remove();c.trigger.remove();b.removeClass(this.markerClassName).unbind("focus",
this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)}else if(e=="div"||e=="span")b.removeClass(this.markerClassName).empty()}},_enableDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();if(e=="input"){a.disabled=false;c.trigger.filter("button").each(function(){this.disabled=false}).end().filter("img").css({opacity:"1.0",cursor:""})}else if(e=="div"||e=="span"){b=
b.children("."+this._inlineClass);b.children().removeClass("ui-state-disabled");b.find("select.ui-datepicker-month, select.ui-datepicker-year").removeAttr("disabled")}this._disabledInputs=d.map(this._disabledInputs,function(f){return f==a?null:f})}},_disableDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();if(e=="input"){a.disabled=true;c.trigger.filter("button").each(function(){this.disabled=true}).end().filter("img").css({opacity:"0.5",
cursor:"default"})}else if(e=="div"||e=="span"){b=b.children("."+this._inlineClass);b.children().addClass("ui-state-disabled");b.find("select.ui-datepicker-month, select.ui-datepicker-year").attr("disabled","disabled")}this._disabledInputs=d.map(this._disabledInputs,function(f){return f==a?null:f});this._disabledInputs[this._disabledInputs.length]=a}},_isDisabledDatepicker:function(a){if(!a)return false;for(var b=0;b<this._disabledInputs.length;b++)if(this._disabledInputs[b]==a)return true;return false},
_getInst:function(a){try{return d.data(a,"datepicker")}catch(b){throw"Missing instance data for this datepicker";}},_optionDatepicker:function(a,b,c){var e=this._getInst(a);if(arguments.length==2&&typeof b=="string")return b=="defaults"?d.extend({},d.datepicker._defaults):e?b=="all"?d.extend({},e.settings):this._get(e,b):null;var f=b||{};if(typeof b=="string"){f={};f[b]=c}if(e){this._curInst==e&&this._hideDatepicker();var h=this._getDateDatepicker(a,true),i=this._getMinMaxDate(e,"min"),g=this._getMinMaxDate(e,
"max");H(e.settings,f);if(i!==null&&f.dateFormat!==C&&f.minDate===C)e.settings.minDate=this._formatDate(e,i);if(g!==null&&f.dateFormat!==C&&f.maxDate===C)e.settings.maxDate=this._formatDate(e,g);this._attachments(d(a),e);this._autoSize(e);this._setDate(e,h);this._updateAlternate(e);this._updateDatepicker(e)}},_changeDatepicker:function(a,b,c){this._optionDatepicker(a,b,c)},_refreshDatepicker:function(a){(a=this._getInst(a))&&this._updateDatepicker(a)},_setDateDatepicker:function(a,b){if(a=this._getInst(a)){this._setDate(a,
b);this._updateDatepicker(a);this._updateAlternate(a)}},_getDateDatepicker:function(a,b){(a=this._getInst(a))&&!a.inline&&this._setDateFromField(a,b);return a?this._getDate(a):null},_doKeyDown:function(a){var b=d.datepicker._getInst(a.target),c=true,e=b.dpDiv.is(".ui-datepicker-rtl");b._keyEvent=true;if(d.datepicker._datepickerShowing)switch(a.keyCode){case 9:d.datepicker._hideDatepicker();c=false;break;case 13:c=d("td."+d.datepicker._dayOverClass+":not(."+d.datepicker._currentClass+")",b.dpDiv);
c[0]?d.datepicker._selectDay(a.target,b.selectedMonth,b.selectedYear,c[0]):d.datepicker._hideDatepicker();return false;case 27:d.datepicker._hideDatepicker();break;case 33:d.datepicker._adjustDate(a.target,a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 34:d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,"stepMonths"),"M");break;case 35:if(a.ctrlKey||a.metaKey)d.datepicker._clearDate(a.target);
c=a.ctrlKey||a.metaKey;break;case 36:if(a.ctrlKey||a.metaKey)d.datepicker._gotoToday(a.target);c=a.ctrlKey||a.metaKey;break;case 37:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,e?+1:-1,"D");c=a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 38:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,-7,"D");c=a.ctrlKey||a.metaKey;break;case 39:if(a.ctrlKey||
a.metaKey)d.datepicker._adjustDate(a.target,e?-1:+1,"D");c=a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,"stepMonths"),"M");break;case 40:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,+7,"D");c=a.ctrlKey||a.metaKey;break;default:c=false}else if(a.keyCode==36&&a.ctrlKey)d.datepicker._showDatepicker(this);else c=false;if(c){a.preventDefault();a.stopPropagation()}},_doKeyPress:function(a){var b=
d.datepicker._getInst(a.target);if(d.datepicker._get(b,"constrainInput")){b=d.datepicker._possibleChars(d.datepicker._get(b,"dateFormat"));var c=String.fromCharCode(a.charCode==C?a.keyCode:a.charCode);return a.ctrlKey||a.metaKey||c<" "||!b||b.indexOf(c)>-1}},_doKeyUp:function(a){a=d.datepicker._getInst(a.target);if(a.input.val()!=a.lastVal)try{if(d.datepicker.parseDate(d.datepicker._get(a,"dateFormat"),a.input?a.input.val():null,d.datepicker._getFormatConfig(a))){d.datepicker._setDateFromField(a);
d.datepicker._updateAlternate(a);d.datepicker._updateDatepicker(a)}}catch(b){d.datepicker.log(b)}return true},_showDatepicker:function(a){a=a.target||a;if(a.nodeName.toLowerCase()!="input")a=d("input",a.parentNode)[0];if(!(d.datepicker._isDisabledDatepicker(a)||d.datepicker._lastInput==a)){var b=d.datepicker._getInst(a);if(d.datepicker._curInst&&d.datepicker._curInst!=b){d.datepicker._datepickerShowing&&d.datepicker._triggerOnClose(d.datepicker._curInst);d.datepicker._curInst.dpDiv.stop(true,true)}var c=
d.datepicker._get(b,"beforeShow");H(b.settings,c?c.apply(a,[a,b]):{});b.lastVal=null;d.datepicker._lastInput=a;d.datepicker._setDateFromField(b);if(d.datepicker._inDialog)a.value="";if(!d.datepicker._pos){d.datepicker._pos=d.datepicker._findPos(a);d.datepicker._pos[1]+=a.offsetHeight}var e=false;d(a).parents().each(function(){e|=d(this).css("position")=="fixed";return!e});if(e&&d.browser.opera){d.datepicker._pos[0]-=document.documentElement.scrollLeft;d.datepicker._pos[1]-=document.documentElement.scrollTop}c=
{left:d.datepicker._pos[0],top:d.datepicker._pos[1]};d.datepicker._pos=null;b.dpDiv.empty();b.dpDiv.css({position:"absolute",display:"block",top:"-1000px"});d.datepicker._updateDatepicker(b);c=d.datepicker._checkOffset(b,c,e);b.dpDiv.css({position:d.datepicker._inDialog&&d.blockUI?"static":e?"fixed":"absolute",display:"none",left:c.left+"px",top:c.top+"px"});if(!b.inline){c=d.datepicker._get(b,"showAnim");var f=d.datepicker._get(b,"duration"),h=function(){var i=b.dpDiv.find("iframe.ui-datepicker-cover");
if(i.length){var g=d.datepicker._getBorders(b.dpDiv);i.css({left:-g[0],top:-g[1],width:b.dpDiv.outerWidth(),height:b.dpDiv.outerHeight()})}};b.dpDiv.zIndex(d(a).zIndex()+1);d.datepicker._datepickerShowing=true;d.effects&&d.effects[c]?b.dpDiv.show(c,d.datepicker._get(b,"showOptions"),f,h):b.dpDiv[c||"show"](c?f:null,h);if(!c||!f)h();b.input.is(":visible")&&!b.input.is(":disabled")&&b.input.focus();d.datepicker._curInst=b}}},_updateDatepicker:function(a){this.maxRows=4;var b=d.datepicker._getBorders(a.dpDiv);
J=a;a.dpDiv.empty().append(this._generateHTML(a));var c=a.dpDiv.find("iframe.ui-datepicker-cover");c.length&&c.css({left:-b[0],top:-b[1],width:a.dpDiv.outerWidth(),height:a.dpDiv.outerHeight()});a.dpDiv.find("."+this._dayOverClass+" a").mouseover();b=this._getNumberOfMonths(a);c=b[1];a.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");c>1&&a.dpDiv.addClass("ui-datepicker-multi-"+c).css("width",17*c+"em");a.dpDiv[(b[0]!=1||b[1]!=1?"add":"remove")+"Class"]("ui-datepicker-multi");
a.dpDiv[(this._get(a,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl");a==d.datepicker._curInst&&d.datepicker._datepickerShowing&&a.input&&a.input.is(":visible")&&!a.input.is(":disabled")&&a.input[0]!=document.activeElement&&a.input.focus();if(a.yearshtml){var e=a.yearshtml;setTimeout(function(){e===a.yearshtml&&a.yearshtml&&a.dpDiv.find("select.ui-datepicker-year:first").replaceWith(a.yearshtml);e=a.yearshtml=null},0)}},_getBorders:function(a){var b=function(c){return{thin:1,medium:2,thick:3}[c]||
c};return[parseFloat(b(a.css("border-left-width"))),parseFloat(b(a.css("border-top-width")))]},_checkOffset:function(a,b,c){var e=a.dpDiv.outerWidth(),f=a.dpDiv.outerHeight(),h=a.input?a.input.outerWidth():0,i=a.input?a.input.outerHeight():0,g=document.documentElement.clientWidth+d(document).scrollLeft(),j=document.documentElement.clientHeight+d(document).scrollTop();b.left-=this._get(a,"isRTL")?e-h:0;b.left-=c&&b.left==a.input.offset().left?d(document).scrollLeft():0;b.top-=c&&b.top==a.input.offset().top+
i?d(document).scrollTop():0;b.left-=Math.min(b.left,b.left+e>g&&g>e?Math.abs(b.left+e-g):0);b.top-=Math.min(b.top,b.top+f>j&&j>f?Math.abs(f+i):0);return b},_findPos:function(a){for(var b=this._get(this._getInst(a),"isRTL");a&&(a.type=="hidden"||a.nodeType!=1||d.expr.filters.hidden(a));)a=a[b?"previousSibling":"nextSibling"];a=d(a).offset();return[a.left,a.top]},_triggerOnClose:function(a){var b=this._get(a,"onClose");if(b)b.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a])},_hideDatepicker:function(a){var b=
this._curInst;if(!(!b||a&&b!=d.data(a,"datepicker")))if(this._datepickerShowing){a=this._get(b,"showAnim");var c=this._get(b,"duration"),e=function(){d.datepicker._tidyDialog(b);this._curInst=null};d.effects&&d.effects[a]?b.dpDiv.hide(a,d.datepicker._get(b,"showOptions"),c,e):b.dpDiv[a=="slideDown"?"slideUp":a=="fadeIn"?"fadeOut":"hide"](a?c:null,e);a||e();d.datepicker._triggerOnClose(b);this._datepickerShowing=false;this._lastInput=null;if(this._inDialog){this._dialogInput.css({position:"absolute",
left:"0",top:"-100px"});if(d.blockUI){d.unblockUI();d("body").append(this.dpDiv)}}this._inDialog=false}},_tidyDialog:function(a){a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(a){if(d.datepicker._curInst){a=d(a.target);a[0].id!=d.datepicker._mainDivId&&a.parents("#"+d.datepicker._mainDivId).length==0&&!a.hasClass(d.datepicker.markerClassName)&&!a.hasClass(d.datepicker._triggerClass)&&d.datepicker._datepickerShowing&&!(d.datepicker._inDialog&&
d.blockUI)&&d.datepicker._hideDatepicker()}},_adjustDate:function(a,b,c){a=d(a);var e=this._getInst(a[0]);if(!this._isDisabledDatepicker(a[0])){this._adjustInstDate(e,b+(c=="M"?this._get(e,"showCurrentAtPos"):0),c);this._updateDatepicker(e)}},_gotoToday:function(a){a=d(a);var b=this._getInst(a[0]);if(this._get(b,"gotoCurrent")&&b.currentDay){b.selectedDay=b.currentDay;b.drawMonth=b.selectedMonth=b.currentMonth;b.drawYear=b.selectedYear=b.currentYear}else{var c=new Date;b.selectedDay=c.getDate();b.drawMonth=
b.selectedMonth=c.getMonth();b.drawYear=b.selectedYear=c.getFullYear()}this._notifyChange(b);this._adjustDate(a)},_selectMonthYear:function(a,b,c){a=d(a);var e=this._getInst(a[0]);e._selectingMonthYear=false;e["selected"+(c=="M"?"Month":"Year")]=e["draw"+(c=="M"?"Month":"Year")]=parseInt(b.options[b.selectedIndex].value,10);this._notifyChange(e);this._adjustDate(a)},_clickMonthYear:function(a){var b=this._getInst(d(a)[0]);b.input&&b._selectingMonthYear&&setTimeout(function(){b.input.focus()},0);b._selectingMonthYear=
!b._selectingMonthYear},_selectDay:function(a,b,c,e){var f=d(a);if(!(d(e).hasClass(this._unselectableClass)||this._isDisabledDatepicker(f[0]))){f=this._getInst(f[0]);f.selectedDay=f.currentDay=d("a",e).html();f.selectedMonth=f.currentMonth=b;f.selectedYear=f.currentYear=c;this._selectDate(a,this._formatDate(f,f.currentDay,f.currentMonth,f.currentYear))}},_clearDate:function(a){a=d(a);this._getInst(a[0]);this._selectDate(a,"")},_selectDate:function(a,b){a=this._getInst(d(a)[0]);b=b!=null?b:this._formatDate(a);
a.input&&a.input.val(b);this._updateAlternate(a);var c=this._get(a,"onSelect");if(c)c.apply(a.input?a.input[0]:null,[b,a]);else a.input&&a.input.trigger("change");if(a.inline)this._updateDatepicker(a);else{this._hideDatepicker();this._lastInput=a.input[0];typeof a.input[0]!="object"&&a.input.focus();this._lastInput=null}},_updateAlternate:function(a){var b=this._get(a,"altField");if(b){var c=this._get(a,"altFormat")||this._get(a,"dateFormat"),e=this._getDate(a),f=this.formatDate(c,e,this._getFormatConfig(a));
d(b).each(function(){d(this).val(f)})}},noWeekends:function(a){a=a.getDay();return[a>0&&a<6,""]},iso8601Week:function(a){a=new Date(a.getTime());a.setDate(a.getDate()+4-(a.getDay()||7));var b=a.getTime();a.setMonth(0);a.setDate(1);return Math.floor(Math.round((b-a)/864E5)/7)+1},parseDate:function(a,b,c){if(a==null||b==null)throw"Invalid arguments";b=typeof b=="object"?b.toString():b+"";if(b=="")return null;var e=(c?c.shortYearCutoff:null)||this._defaults.shortYearCutoff;e=typeof e!="string"?e:(new Date).getFullYear()%
100+parseInt(e,10);for(var f=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,h=(c?c.dayNames:null)||this._defaults.dayNames,i=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,g=(c?c.monthNames:null)||this._defaults.monthNames,j=c=-1,l=-1,u=-1,k=false,o=function(p){(p=B+1<a.length&&a.charAt(B+1)==p)&&B++;return p},m=function(p){var D=o(p);p=new RegExp("^\\d{1,"+(p=="@"?14:p=="!"?20:p=="y"&&D?4:p=="o"?3:2)+"}");p=b.substring(q).match(p);if(!p)throw"Missing number at position "+q;q+=
p[0].length;return parseInt(p[0],10)},n=function(p,D,K){p=d.map(o(p)?K:D,function(w,x){return[[x,w]]}).sort(function(w,x){return-(w[1].length-x[1].length)});var E=-1;d.each(p,function(w,x){w=x[1];if(b.substr(q,w.length).toLowerCase()==w.toLowerCase()){E=x[0];q+=w.length;return false}});if(E!=-1)return E+1;else throw"Unknown name at position "+q;},s=function(){if(b.charAt(q)!=a.charAt(B))throw"Unexpected literal at position "+q;q++},q=0,B=0;B<a.length;B++)if(k)if(a.charAt(B)=="'"&&!o("'"))k=false;
else s();else switch(a.charAt(B)){case "d":l=m("d");break;case "D":n("D",f,h);break;case "o":u=m("o");break;case "m":j=m("m");break;case "M":j=n("M",i,g);break;case "y":c=m("y");break;case "@":var v=new Date(m("@"));c=v.getFullYear();j=v.getMonth()+1;l=v.getDate();break;case "!":v=new Date((m("!")-this._ticksTo1970)/1E4);c=v.getFullYear();j=v.getMonth()+1;l=v.getDate();break;case "'":if(o("'"))s();else k=true;break;default:s()}if(q<b.length)throw"Extra/unparsed characters found in date: "+b.substring(q);
if(c==-1)c=(new Date).getFullYear();else if(c<100)c+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c<=e?0:-100);if(u>-1){j=1;l=u;do{e=this._getDaysInMonth(c,j-1);if(l<=e)break;j++;l-=e}while(1)}v=this._daylightSavingAdjust(new Date(c,j-1,l));if(v.getFullYear()!=c||v.getMonth()+1!=j||v.getDate()!=l)throw"Invalid date";return v},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",
TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*24*60*60*1E7,formatDate:function(a,b,c){if(!b)return"";var e=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,f=(c?c.dayNames:null)||this._defaults.dayNames,h=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort;c=(c?c.monthNames:null)||this._defaults.monthNames;var i=function(o){(o=k+1<a.length&&a.charAt(k+1)==o)&&k++;return o},g=function(o,m,n){m=""+m;if(i(o))for(;m.length<
n;)m="0"+m;return m},j=function(o,m,n,s){return i(o)?s[m]:n[m]},l="",u=false;if(b)for(var k=0;k<a.length;k++)if(u)if(a.charAt(k)=="'"&&!i("'"))u=false;else l+=a.charAt(k);else switch(a.charAt(k)){case "d":l+=g("d",b.getDate(),2);break;case "D":l+=j("D",b.getDay(),e,f);break;case "o":l+=g("o",Math.round(((new Date(b.getFullYear(),b.getMonth(),b.getDate())).getTime()-(new Date(b.getFullYear(),0,0)).getTime())/864E5),3);break;case "m":l+=g("m",b.getMonth()+1,2);break;case "M":l+=j("M",b.getMonth(),h,
c);break;case "y":l+=i("y")?b.getFullYear():(b.getYear()%100<10?"0":"")+b.getYear()%100;break;case "@":l+=b.getTime();break;case "!":l+=b.getTime()*1E4+this._ticksTo1970;break;case "'":if(i("'"))l+="'";else u=true;break;default:l+=a.charAt(k)}return l},_possibleChars:function(a){for(var b="",c=false,e=function(h){(h=f+1<a.length&&a.charAt(f+1)==h)&&f++;return h},f=0;f<a.length;f++)if(c)if(a.charAt(f)=="'"&&!e("'"))c=false;else b+=a.charAt(f);else switch(a.charAt(f)){case "d":case "m":case "y":case "@":b+=
"0123456789";break;case "D":case "M":return null;case "'":if(e("'"))b+="'";else c=true;break;default:b+=a.charAt(f)}return b},_get:function(a,b){return a.settings[b]!==C?a.settings[b]:this._defaults[b]},_setDateFromField:function(a,b){if(a.input.val()!=a.lastVal){var c=this._get(a,"dateFormat"),e=a.lastVal=a.input?a.input.val():null,f,h;f=h=this._getDefaultDate(a);var i=this._getFormatConfig(a);try{f=this.parseDate(c,e,i)||h}catch(g){this.log(g);e=b?"":e}a.selectedDay=f.getDate();a.drawMonth=a.selectedMonth=
f.getMonth();a.drawYear=a.selectedYear=f.getFullYear();a.currentDay=e?f.getDate():0;a.currentMonth=e?f.getMonth():0;a.currentYear=e?f.getFullYear():0;this._adjustInstDate(a)}},_getDefaultDate:function(a){return this._restrictMinMax(a,this._determineDate(a,this._get(a,"defaultDate"),new Date))},_determineDate:function(a,b,c){var e=function(h){var i=new Date;i.setDate(i.getDate()+h);return i},f=function(h){try{return d.datepicker.parseDate(d.datepicker._get(a,"dateFormat"),h,d.datepicker._getFormatConfig(a))}catch(i){}var g=
(h.toLowerCase().match(/^c/)?d.datepicker._getDate(a):null)||new Date,j=g.getFullYear(),l=g.getMonth();g=g.getDate();for(var u=/([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,k=u.exec(h);k;){switch(k[2]||"d"){case "d":case "D":g+=parseInt(k[1],10);break;case "w":case "W":g+=parseInt(k[1],10)*7;break;case "m":case "M":l+=parseInt(k[1],10);g=Math.min(g,d.datepicker._getDaysInMonth(j,l));break;case "y":case "Y":j+=parseInt(k[1],10);g=Math.min(g,d.datepicker._getDaysInMonth(j,l));break}k=u.exec(h)}return new Date(j,
l,g)};if(b=(b=b==null||b===""?c:typeof b=="string"?f(b):typeof b=="number"?isNaN(b)?c:e(b):new Date(b.getTime()))&&b.toString()=="Invalid Date"?c:b){b.setHours(0);b.setMinutes(0);b.setSeconds(0);b.setMilliseconds(0)}return this._daylightSavingAdjust(b)},_daylightSavingAdjust:function(a){if(!a)return null;a.setHours(a.getHours()>12?a.getHours()+2:0);return a},_setDate:function(a,b,c){var e=!b,f=a.selectedMonth,h=a.selectedYear;b=this._restrictMinMax(a,this._determineDate(a,b,new Date));a.selectedDay=
a.currentDay=b.getDate();a.drawMonth=a.selectedMonth=a.currentMonth=b.getMonth();a.drawYear=a.selectedYear=a.currentYear=b.getFullYear();if((f!=a.selectedMonth||h!=a.selectedYear)&&!c)this._notifyChange(a);this._adjustInstDate(a);if(a.input)a.input.val(e?"":this._formatDate(a))},_getDate:function(a){return!a.currentYear||a.input&&a.input.val()==""?null:this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay))},_generateHTML:function(a){var b=new Date;b=this._daylightSavingAdjust(new Date(b.getFullYear(),
b.getMonth(),b.getDate()));var c=this._get(a,"isRTL"),e=this._get(a,"showButtonPanel"),f=this._get(a,"hideIfNoPrevNext"),h=this._get(a,"navigationAsDateFormat"),i=this._getNumberOfMonths(a),g=this._get(a,"showCurrentAtPos"),j=this._get(a,"stepMonths"),l=i[0]!=1||i[1]!=1,u=this._daylightSavingAdjust(!a.currentDay?new Date(9999,9,9):new Date(a.currentYear,a.currentMonth,a.currentDay)),k=this._getMinMaxDate(a,"min"),o=this._getMinMaxDate(a,"max");g=a.drawMonth-g;var m=a.drawYear;if(g<0){g+=12;m--}if(o){var n=
this._daylightSavingAdjust(new Date(o.getFullYear(),o.getMonth()-i[0]*i[1]+1,o.getDate()));for(n=k&&n<k?k:n;this._daylightSavingAdjust(new Date(m,g,1))>n;){g--;if(g<0){g=11;m--}}}a.drawMonth=g;a.drawYear=m;n=this._get(a,"prevText");n=!h?n:this.formatDate(n,this._daylightSavingAdjust(new Date(m,g-j,1)),this._getFormatConfig(a));n=this._canAdjustMonth(a,-1,m,g)?'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_'+A+".datepicker._adjustDate('#"+a.id+"', -"+j+", 'M');\" title=\""+n+'"><span class="ui-icon ui-icon-circle-triangle-'+
(c?"e":"w")+'">'+n+"</span></a>":f?"":'<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+n+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+n+"</span></a>";var s=this._get(a,"nextText");s=!h?s:this.formatDate(s,this._daylightSavingAdjust(new Date(m,g+j,1)),this._getFormatConfig(a));f=this._canAdjustMonth(a,+1,m,g)?'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_'+A+".datepicker._adjustDate('#"+a.id+"', +"+j+", 'M');\" title=\""+s+'"><span class="ui-icon ui-icon-circle-triangle-'+
(c?"w":"e")+'">'+s+"</span></a>":f?"":'<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>";j=this._get(a,"currentText");s=this._get(a,"gotoCurrent")&&a.currentDay?u:b;j=!h?j:this.formatDate(j,s,this._getFormatConfig(a));h=!a.inline?'<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_'+A+'.datepicker._hideDatepicker();">'+this._get(a,
"closeText")+"</button>":"";e=e?'<div class="ui-datepicker-buttonpane ui-widget-content">'+(c?h:"")+(this._isInRange(a,s)?'<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_'+A+".datepicker._gotoToday('#"+a.id+"');\">"+j+"</button>":"")+(c?"":h)+"</div>":"";h=parseInt(this._get(a,"firstDay"),10);h=isNaN(h)?0:h;j=this._get(a,"showWeek");s=this._get(a,"dayNames");this._get(a,"dayNamesShort");var q=this._get(a,"dayNamesMin"),B=
this._get(a,"monthNames"),v=this._get(a,"monthNamesShort"),p=this._get(a,"beforeShowDay"),D=this._get(a,"showOtherMonths"),K=this._get(a,"selectOtherMonths");this._get(a,"calculateWeek");for(var E=this._getDefaultDate(a),w="",x=0;x<i[0];x++){var O="";this.maxRows=4;for(var G=0;G<i[1];G++){var P=this._daylightSavingAdjust(new Date(m,g,a.selectedDay)),t=" ui-corner-all",y="";if(l){y+='<div class="ui-datepicker-group';if(i[1]>1)switch(G){case 0:y+=" ui-datepicker-group-first";t=" ui-corner-"+(c?"right":
"left");break;case i[1]-1:y+=" ui-datepicker-group-last";t=" ui-corner-"+(c?"left":"right");break;default:y+=" ui-datepicker-group-middle";t="";break}y+='">'}y+='<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix'+t+'">'+(/all|left/.test(t)&&x==0?c?f:n:"")+(/all|right/.test(t)&&x==0?c?n:f:"")+this._generateMonthYearHeader(a,g,m,k,o,x>0||G>0,B,v)+'</div><table class="ui-datepicker-calendar"><thead><tr>';var z=j?'<th class="ui-datepicker-week-col">'+this._get(a,"weekHeader")+"</th>":
"";for(t=0;t<7;t++){var r=(t+h)%7;z+="<th"+((t+h+6)%7>=5?' class="ui-datepicker-week-end"':"")+'><span title="'+s[r]+'">'+q[r]+"</span></th>"}y+=z+"</tr></thead><tbody>";z=this._getDaysInMonth(m,g);if(m==a.selectedYear&&g==a.selectedMonth)a.selectedDay=Math.min(a.selectedDay,z);t=(this._getFirstDayOfMonth(m,g)-h+7)%7;z=Math.ceil((t+z)/7);this.maxRows=z=l?this.maxRows>z?this.maxRows:z:z;r=this._daylightSavingAdjust(new Date(m,g,1-t));for(var Q=0;Q<z;Q++){y+="<tr>";var R=!j?"":'<td class="ui-datepicker-week-col">'+
this._get(a,"calculateWeek")(r)+"</td>";for(t=0;t<7;t++){var I=p?p.apply(a.input?a.input[0]:null,[r]):[true,""],F=r.getMonth()!=g,L=F&&!K||!I[0]||k&&r<k||o&&r>o;R+='<td class="'+((t+h+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(r.getTime()==P.getTime()&&g==a.selectedMonth&&a._keyEvent||E.getTime()==r.getTime()&&E.getTime()==P.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!D?"":" "+I[1]+(r.getTime()==u.getTime()?" "+
this._currentClass:"")+(r.getTime()==b.getTime()?" ui-datepicker-today":""))+'"'+((!F||D)&&I[2]?' title="'+I[2]+'"':"")+(L?"":' onclick="DP_jQuery_'+A+".datepicker._selectDay('#"+a.id+"',"+r.getMonth()+","+r.getFullYear()+', this);return false;"')+">"+(F&&!D?"&#xa0;":L?'<span class="ui-state-default">'+r.getDate()+"</span>":'<a class="ui-state-default'+(r.getTime()==b.getTime()?" ui-state-highlight":"")+(r.getTime()==u.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+'" href="#">'+
r.getDate()+"</a>")+"</td>";r.setDate(r.getDate()+1);r=this._daylightSavingAdjust(r)}y+=R+"</tr>"}g++;if(g>11){g=0;m++}y+="</tbody></table>"+(l?"</div>"+(i[0]>0&&G==i[1]-1?'<div class="ui-datepicker-row-break"></div>':""):"");O+=y}w+=O}w+=e+(d.browser.msie&&parseInt(d.browser.version,10)<7&&!a.inline?'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>':"");a._keyEvent=false;return w},_generateMonthYearHeader:function(a,b,c,e,f,h,i,g){var j=this._get(a,"changeMonth"),
l=this._get(a,"changeYear"),u=this._get(a,"showMonthAfterYear"),k='<div class="ui-datepicker-title">',o="";if(h||!j)o+='<span class="ui-datepicker-month">'+i[b]+"</span>";else{i=e&&e.getFullYear()==c;var m=f&&f.getFullYear()==c;o+='<select class="ui-datepicker-month" onchange="DP_jQuery_'+A+".datepicker._selectMonthYear('#"+a.id+"', this, 'M');\" onclick=\"DP_jQuery_"+A+".datepicker._clickMonthYear('#"+a.id+"');\">";for(var n=0;n<12;n++)if((!i||n>=e.getMonth())&&(!m||n<=f.getMonth()))o+='<option value="'+
n+'"'+(n==b?' selected="selected"':"")+">"+g[n]+"</option>";o+="</select>"}u||(k+=o+(h||!(j&&l)?"&#xa0;":""));if(!a.yearshtml){a.yearshtml="";if(h||!l)k+='<span class="ui-datepicker-year">'+c+"</span>";else{g=this._get(a,"yearRange").split(":");var s=(new Date).getFullYear();i=function(q){q=q.match(/c[+-].*/)?c+parseInt(q.substring(1),10):q.match(/[+-].*/)?s+parseInt(q,10):parseInt(q,10);return isNaN(q)?s:q};b=i(g[0]);g=Math.max(b,i(g[1]||""));b=e?Math.max(b,e.getFullYear()):b;g=f?Math.min(g,f.getFullYear()):
g;for(a.yearshtml+='<select class="ui-datepicker-year" onchange="DP_jQuery_'+A+".datepicker._selectMonthYear('#"+a.id+"', this, 'Y');\" onclick=\"DP_jQuery_"+A+".datepicker._clickMonthYear('#"+a.id+"');\">";b<=g;b++)a.yearshtml+='<option value="'+b+'"'+(b==c?' selected="selected"':"")+">"+b+"</option>";a.yearshtml+="</select>";k+=a.yearshtml;a.yearshtml=null}}k+=this._get(a,"yearSuffix");if(u)k+=(h||!(j&&l)?"&#xa0;":"")+o;k+="</div>";return k},_adjustInstDate:function(a,b,c){var e=a.drawYear+(c==
"Y"?b:0),f=a.drawMonth+(c=="M"?b:0);b=Math.min(a.selectedDay,this._getDaysInMonth(e,f))+(c=="D"?b:0);e=this._restrictMinMax(a,this._daylightSavingAdjust(new Date(e,f,b)));a.selectedDay=e.getDate();a.drawMonth=a.selectedMonth=e.getMonth();a.drawYear=a.selectedYear=e.getFullYear();if(c=="M"||c=="Y")this._notifyChange(a)},_restrictMinMax:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");b=c&&b<c?c:b;return b=a&&b>a?a:b},_notifyChange:function(a){var b=this._get(a,"onChangeMonthYear");
if(b)b.apply(a.input?a.input[0]:null,[a.selectedYear,a.selectedMonth+1,a])},_getNumberOfMonths:function(a){a=this._get(a,"numberOfMonths");return a==null?[1,1]:typeof a=="number"?[1,a]:a},_getMinMaxDate:function(a,b){return this._determineDate(a,this._get(a,b+"Date"),null)},_getDaysInMonth:function(a,b){return 32-this._daylightSavingAdjust(new Date(a,b,32)).getDate()},_getFirstDayOfMonth:function(a,b){return(new Date(a,b,1)).getDay()},_canAdjustMonth:function(a,b,c,e){var f=this._getNumberOfMonths(a);
c=this._daylightSavingAdjust(new Date(c,e+(b<0?b:f[0]*f[1]),1));b<0&&c.setDate(this._getDaysInMonth(c.getFullYear(),c.getMonth()));return this._isInRange(a,c)},_isInRange:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");return(!c||b.getTime()>=c.getTime())&&(!a||b.getTime()<=a.getTime())},_getFormatConfig:function(a){var b=this._get(a,"shortYearCutoff");b=typeof b!="string"?b:(new Date).getFullYear()%100+parseInt(b,10);return{shortYearCutoff:b,dayNamesShort:this._get(a,
"dayNamesShort"),dayNames:this._get(a,"dayNames"),monthNamesShort:this._get(a,"monthNamesShort"),monthNames:this._get(a,"monthNames")}},_formatDate:function(a,b,c,e){if(!b){a.currentDay=a.selectedDay;a.currentMonth=a.selectedMonth;a.currentYear=a.selectedYear}b=b?typeof b=="object"?b:this._daylightSavingAdjust(new Date(e,c,b)):this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return this.formatDate(this._get(a,"dateFormat"),b,this._getFormatConfig(a))}});d.fn.datepicker=
function(a){if(!this.length)return this;if(!d.datepicker.initialized){d(document).mousedown(d.datepicker._checkExternalClick).find("body").append(d.datepicker.dpDiv);d.datepicker.initialized=true}var b=Array.prototype.slice.call(arguments,1);if(typeof a=="string"&&(a=="isDisabled"||a=="getDate"||a=="widget"))return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this[0]].concat(b));if(a=="option"&&arguments.length==2&&typeof arguments[1]=="string")return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,
[this[0]].concat(b));return this.each(function(){typeof a=="string"?d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this].concat(b)):d.datepicker._attachDatepicker(this,a)})};d.datepicker=new M;d.datepicker.initialized=false;d.datepicker.uuid=(new Date).getTime();d.datepicker.version="1.8.14";window["DP_jQuery_"+A]=d})(jQuery);
;/*
 * jQuery UI Progressbar 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function(b,d){b.widget("ui.progressbar",{options:{value:0,max:100},min:0,_create:function(){this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min,"aria-valuemax":this.options.max,"aria-valuenow":this._value()});this.valueDiv=b("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);this.oldValue=this._value();this._refreshValue()},destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
this.valueDiv.remove();b.Widget.prototype.destroy.apply(this,arguments)},value:function(a){if(a===d)return this._value();this._setOption("value",a);return this},_setOption:function(a,c){if(a==="value"){this.options.value=c;this._refreshValue();this._value()===this.options.max&&this._trigger("complete")}b.Widget.prototype._setOption.apply(this,arguments)},_value:function(){var a=this.options.value;if(typeof a!=="number")a=0;return Math.min(this.options.max,Math.max(this.min,a))},_percentage:function(){return 100*
this._value()/this.options.max},_refreshValue:function(){var a=this.value(),c=this._percentage();if(this.oldValue!==a){this.oldValue=a;this._trigger("change")}this.valueDiv.toggle(a>this.min).toggleClass("ui-corner-right",a===this.options.max).width(c.toFixed(0)+"%");this.element.attr("aria-valuenow",a)}});b.extend(b.ui.progressbar,{version:"1.8.14"})})(jQuery);
;/*
 * jQuery UI Effects 1.8.14
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
jQuery.effects||function(f,j){function m(c){var a;if(c&&c.constructor==Array&&c.length==3)return c;if(a=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(c))return[parseInt(a[1],10),parseInt(a[2],10),parseInt(a[3],10)];if(a=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(c))return[parseFloat(a[1])*2.55,parseFloat(a[2])*2.55,parseFloat(a[3])*2.55];if(a=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(c))return[parseInt(a[1],
16),parseInt(a[2],16),parseInt(a[3],16)];if(a=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(c))return[parseInt(a[1]+a[1],16),parseInt(a[2]+a[2],16),parseInt(a[3]+a[3],16)];if(/rgba\(0, 0, 0, 0\)/.exec(c))return n.transparent;return n[f.trim(c).toLowerCase()]}function s(c,a){var b;do{b=f.curCSS(c,a);if(b!=""&&b!="transparent"||f.nodeName(c,"body"))break;a="backgroundColor"}while(c=c.parentNode);return m(b)}function o(){var c=document.defaultView?document.defaultView.getComputedStyle(this,null):this.currentStyle,
a={},b,d;if(c&&c.length&&c[0]&&c[c[0]])for(var e=c.length;e--;){b=c[e];if(typeof c[b]=="string"){d=b.replace(/\-(\w)/g,function(g,h){return h.toUpperCase()});a[d]=c[b]}}else for(b in c)if(typeof c[b]==="string")a[b]=c[b];return a}function p(c){var a,b;for(a in c){b=c[a];if(b==null||f.isFunction(b)||a in t||/scrollbar/.test(a)||!/color/i.test(a)&&isNaN(parseFloat(b)))delete c[a]}return c}function u(c,a){var b={_:0},d;for(d in a)if(c[d]!=a[d])b[d]=a[d];return b}function k(c,a,b,d){if(typeof c=="object"){d=
a;b=null;a=c;c=a.effect}if(f.isFunction(a)){d=a;b=null;a={}}if(typeof a=="number"||f.fx.speeds[a]){d=b;b=a;a={}}if(f.isFunction(b)){d=b;b=null}a=a||{};b=b||a.duration;b=f.fx.off?0:typeof b=="number"?b:b in f.fx.speeds?f.fx.speeds[b]:f.fx.speeds._default;d=d||a.complete;return[c,a,b,d]}function l(c){if(!c||typeof c==="number"||f.fx.speeds[c])return true;if(typeof c==="string"&&!f.effects[c])return true;return false}f.effects={};f.each(["backgroundColor","borderBottomColor","borderLeftColor","borderRightColor",
"borderTopColor","borderColor","color","outlineColor"],function(c,a){f.fx.step[a]=function(b){if(!b.colorInit){b.start=s(b.elem,a);b.end=m(b.end);b.colorInit=true}b.elem.style[a]="rgb("+Math.max(Math.min(parseInt(b.pos*(b.end[0]-b.start[0])+b.start[0],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[1]-b.start[1])+b.start[1],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[2]-b.start[2])+b.start[2],10),255),0)+")"}});var n={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,
0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,
211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0],transparent:[255,255,255]},q=["add","remove","toggle"],t={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};f.effects.animateClass=function(c,a,b,
d){if(f.isFunction(b)){d=b;b=null}return this.queue(function(){var e=f(this),g=e.attr("style")||" ",h=p(o.call(this)),r,v=e.attr("class");f.each(q,function(w,i){c[i]&&e[i+"Class"](c[i])});r=p(o.call(this));e.attr("class",v);e.animate(u(h,r),{queue:false,duration:a,easing:b,complete:function(){f.each(q,function(w,i){c[i]&&e[i+"Class"](c[i])});if(typeof e.attr("style")=="object"){e.attr("style").cssText="";e.attr("style").cssText=g}else e.attr("style",g);d&&d.apply(this,arguments);f.dequeue(this)}})})};
f.fn.extend({_addClass:f.fn.addClass,addClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{add:c},a,b,d]):this._addClass(c)},_removeClass:f.fn.removeClass,removeClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{remove:c},a,b,d]):this._removeClass(c)},_toggleClass:f.fn.toggleClass,toggleClass:function(c,a,b,d,e){return typeof a=="boolean"||a===j?b?f.effects.animateClass.apply(this,[a?{add:c}:{remove:c},b,d,e]):this._toggleClass(c,a):f.effects.animateClass.apply(this,
[{toggle:c},a,b,d])},switchClass:function(c,a,b,d,e){return f.effects.animateClass.apply(this,[{add:a,remove:c},b,d,e])}});f.extend(f.effects,{version:"1.8.14",save:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.data("ec.storage."+a[b],c[0].style[a[b]])},restore:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.css(a[b],c.data("ec.storage."+a[b]))},setMode:function(c,a){if(a=="toggle")a=c.is(":hidden")?"show":"hide";return a},getBaseline:function(c,a){var b;switch(c[0]){case "top":b=
0;break;case "middle":b=0.5;break;case "bottom":b=1;break;default:b=c[0]/a.height}switch(c[1]){case "left":c=0;break;case "center":c=0.5;break;case "right":c=1;break;default:c=c[1]/a.width}return{x:c,y:b}},createWrapper:function(c){if(c.parent().is(".ui-effects-wrapper"))return c.parent();var a={width:c.outerWidth(true),height:c.outerHeight(true),"float":c.css("float")},b=f("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0});
c.wrap(b);b=c.parent();if(c.css("position")=="static"){b.css({position:"relative"});c.css({position:"relative"})}else{f.extend(a,{position:c.css("position"),zIndex:c.css("z-index")});f.each(["top","left","bottom","right"],function(d,e){a[e]=c.css(e);if(isNaN(parseInt(a[e],10)))a[e]="auto"});c.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})}return b.css(a).show()},removeWrapper:function(c){if(c.parent().is(".ui-effects-wrapper"))return c.parent().replaceWith(c);return c},setTransition:function(c,
a,b,d){d=d||{};f.each(a,function(e,g){unit=c.cssUnit(g);if(unit[0]>0)d[g]=unit[0]*b+unit[1]});return d}});f.fn.extend({effect:function(c){var a=k.apply(this,arguments),b={options:a[1],duration:a[2],callback:a[3]};a=b.options.mode;var d=f.effects[c];if(f.fx.off||!d)return a?this[a](b.duration,b.callback):this.each(function(){b.callback&&b.callback.call(this)});return d.call(this,b)},_show:f.fn.show,show:function(c){if(l(c))return this._show.apply(this,arguments);else{var a=k.apply(this,arguments);
a[1].mode="show";return this.effect.apply(this,a)}},_hide:f.fn.hide,hide:function(c){if(l(c))return this._hide.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="hide";return this.effect.apply(this,a)}},__toggle:f.fn.toggle,toggle:function(c){if(l(c)||typeof c==="boolean"||f.isFunction(c))return this.__toggle.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="toggle";return this.effect.apply(this,a)}},cssUnit:function(c){var a=this.css(c),b=[];f.each(["em","px","%",
"pt"],function(d,e){if(a.indexOf(e)>0)b=[parseFloat(a),e]});return b}});f.easing.jswing=f.easing.swing;f.extend(f.easing,{def:"easeOutQuad",swing:function(c,a,b,d,e){return f.easing[f.easing.def](c,a,b,d,e)},easeInQuad:function(c,a,b,d,e){return d*(a/=e)*a+b},easeOutQuad:function(c,a,b,d,e){return-d*(a/=e)*(a-2)+b},easeInOutQuad:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a+b;return-d/2*(--a*(a-2)-1)+b},easeInCubic:function(c,a,b,d,e){return d*(a/=e)*a*a+b},easeOutCubic:function(c,a,b,d,e){return d*
((a=a/e-1)*a*a+1)+b},easeInOutCubic:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a+b;return d/2*((a-=2)*a*a+2)+b},easeInQuart:function(c,a,b,d,e){return d*(a/=e)*a*a*a+b},easeOutQuart:function(c,a,b,d,e){return-d*((a=a/e-1)*a*a*a-1)+b},easeInOutQuart:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a*a+b;return-d/2*((a-=2)*a*a*a-2)+b},easeInQuint:function(c,a,b,d,e){return d*(a/=e)*a*a*a*a+b},easeOutQuint:function(c,a,b,d,e){return d*((a=a/e-1)*a*a*a*a+1)+b},easeInOutQuint:function(c,a,b,d,e){if((a/=
e/2)<1)return d/2*a*a*a*a*a+b;return d/2*((a-=2)*a*a*a*a+2)+b},easeInSine:function(c,a,b,d,e){return-d*Math.cos(a/e*(Math.PI/2))+d+b},easeOutSine:function(c,a,b,d,e){return d*Math.sin(a/e*(Math.PI/2))+b},easeInOutSine:function(c,a,b,d,e){return-d/2*(Math.cos(Math.PI*a/e)-1)+b},easeInExpo:function(c,a,b,d,e){return a==0?b:d*Math.pow(2,10*(a/e-1))+b},easeOutExpo:function(c,a,b,d,e){return a==e?b+d:d*(-Math.pow(2,-10*a/e)+1)+b},easeInOutExpo:function(c,a,b,d,e){if(a==0)return b;if(a==e)return b+d;if((a/=
e/2)<1)return d/2*Math.pow(2,10*(a-1))+b;return d/2*(-Math.pow(2,-10*--a)+2)+b},easeInCirc:function(c,a,b,d,e){return-d*(Math.sqrt(1-(a/=e)*a)-1)+b},easeOutCirc:function(c,a,b,d,e){return d*Math.sqrt(1-(a=a/e-1)*a)+b},easeInOutCirc:function(c,a,b,d,e){if((a/=e/2)<1)return-d/2*(Math.sqrt(1-a*a)-1)+b;return d/2*(Math.sqrt(1-(a-=2)*a)+1)+b},easeInElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/
h);return-(h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g))+b},easeOutElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);return h*Math.pow(2,-10*a)*Math.sin((a*e-c)*2*Math.PI/g)+d+b},easeInOutElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e/2)==2)return b+d;g||(g=e*0.3*1.5);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);if(a<1)return-0.5*
h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)+b;return h*Math.pow(2,-10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)*0.5+d+b},easeInBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*(a/=e)*a*((g+1)*a-g)+b},easeOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*((a=a/e-1)*a*((g+1)*a+g)+1)+b},easeInOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;if((a/=e/2)<1)return d/2*a*a*(((g*=1.525)+1)*a-g)+b;return d/2*((a-=2)*a*(((g*=1.525)+1)*a+g)+2)+b},easeInBounce:function(c,a,b,d,e){return d-f.easing.easeOutBounce(c,
e-a,0,d,e)+b},easeOutBounce:function(c,a,b,d,e){return(a/=e)<1/2.75?d*7.5625*a*a+b:a<2/2.75?d*(7.5625*(a-=1.5/2.75)*a+0.75)+b:a<2.5/2.75?d*(7.5625*(a-=2.25/2.75)*a+0.9375)+b:d*(7.5625*(a-=2.625/2.75)*a+0.984375)+b},easeInOutBounce:function(c,a,b,d,e){if(a<e/2)return f.easing.easeInBounce(c,a*2,0,d,e)*0.5+b;return f.easing.easeOutBounce(c,a*2-e,0,d,e)*0.5+d*0.5+b}})}(jQuery);
;;


/*ZB: PAutocomplete */
require.define('PAutocomplete', {

/*ZB:  PAutocomplete/controllers/PAutocompleteDropdownController */
'controllers/PAutocompleteDropdownController': function(exports, require, module) {(function() {
(function() {
  var $, DEFAULT_ACTIVE_CLASS, EVENT_DROPDOWN_ITEM_DEACTIVATE, EVENT_DROPDOWN_ITEM_HIGHLIGHT, EVENT_DROPDOWN_ITEM_SELECT, EVENT_DROPDOWN_POPUP_HIDE, EVENT_DROPDOWN_POPUP_SHOW, PAutocompleteDropdownController, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Spine = require('spine');

  $ = require('jquery');

  EVENT_DROPDOWN_ITEM_SELECT = 'dropdown_item_select';

  EVENT_DROPDOWN_ITEM_HIGHLIGHT = 'dropdown_item_highlight';

  EVENT_DROPDOWN_ITEM_DEACTIVATE = 'dropdown_item_deactivate';

  EVENT_DROPDOWN_POPUP_SHOW = 'dropdown_popup_show';

  EVENT_DROPDOWN_POPUP_HIDE = 'Pautocomplete.dropdown.hide';

  DEFAULT_ACTIVE_CLASS = 'active';

  PAutocompleteDropdownController = (function(superClass) {
    extend(PAutocompleteDropdownController, superClass);

    function PAutocompleteDropdownController() {
      this.item_down = bind(this.item_down, this);
      this.item_up = bind(this.item_up, this);
      this.hide_popup = bind(this.hide_popup, this);
      this.show_popup = bind(this.show_popup, this);
      this._init_position = bind(this._init_position, this);
      this.render = bind(this.render, this);
      var close_if_click_outside_popup;
      PAutocompleteDropdownController.__super__.constructor.apply(this, arguments);
      this.logPrefix = '(PAutocompleteController)';
      if (!this.popup_selector) {
        throw "popup_selector param is missing";
      }
      if (!this.active_item_class) {
        this.active_item_class = DEFAULT_ACTIVE_CLASS;
      }
      this.selected_index = 0;
      $('body').append(this.render());
      this.hide_popup();
      this.dropdown_active = false;
      close_if_click_outside_popup = (function(_this) {
        return function(e) {
          if ($(e.target).parents(_this.popup_selector).length === 0 && '#' + $(e.target).attr('id') !== _this.input_selector) {
            _this.hide_popup();
          }
          return true;
        };
      })(this);
      $(document).click(close_if_click_outside_popup);
      this.el.delegate(this.item_list_selector, 'click', this._bind_item_click(this));
    }

    PAutocompleteDropdownController.prototype._bind_item_click = function(ctrl) {
      return function(e) {
        var item;
        item = $(this);
        ctrl.selected_index = $(ctrl.item_list_selector).index(item);
        ctrl.highlight_item(ctrl.selected_index);
        ctrl.trigger(EVENT_DROPDOWN_ITEM_SELECT, item.data());
        ctrl.hide_popup();
        return true;
      };
    };

    PAutocompleteDropdownController.prototype.get_selected_item = function() {
      if (this.dropdown_active) {
        return $(this.items_list()[this.selected_index]).data();
      } else {
        return null;
      }
    };

    PAutocompleteDropdownController.prototype.render = function(items) {
      return this.html(require(this.template)({
        popup_additional_cls: this.popup_additional_cls,
        items: items
      }));
    };

    PAutocompleteDropdownController.prototype._init_position = function() {

      /* Method for calculating popup windown offset and width */
      var input_selector, left, top;
      input_selector = this.input_container != null ? $(this.input_container) : $(this.input_selector);
      top = input_selector.offset().top + input_selector.outerHeight();
      if (this.is_fixed) {
        top -= $(window).scrollTop();
      }
      left = input_selector.offset().left;
      $(this.popup_selector).outerWidth(input_selector.outerWidth());
      return $(this.popup_selector).css({
        top: top,
        left: left
      });
    };

    PAutocompleteDropdownController.prototype._check_if_item_from_target = function(ev) {
      var classes, i, id, item, ref;
      item = this._get_crossbrowser_event_target(ev);
      classes = (function() {
        var j, len, ref, results;
        ref = item.attr('class').split(' ');
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push("." + i);
        }
        return results;
      })();
      id = "#" + (item.attr('id'));
      return ref = this.item_list_selector, indexOf.call(classes, ref) >= 0;
    };

    PAutocompleteDropdownController.prototype.show_popup = function(items) {
      this.render(items);
      this._init_position();
      $(this.el).show();
      return this.trigger(EVENT_DROPDOWN_POPUP_SHOW);
    };

    PAutocompleteDropdownController.prototype.hide_popup = function() {
      this.selected_index = 0;
      $(this.el).hide();
      this.trigger(EVENT_DROPDOWN_POPUP_HIDE);
      return this.dropdown_active = false;
    };

    PAutocompleteDropdownController.prototype.items_list = function() {
      return this.el.find(this.item_list_selector);
    };

    PAutocompleteDropdownController.prototype.item_up = function() {
      if (this.dropdown_active && this.selected_index === 0) {
        this.dropdown_deactivate();
        return;
      }
      if (!this.dropdown_active && this.selected_index === 0) {
        this.dropdown_activate(false);
        return;
      }
      this.selected_index -= 1;
      return this.highlight_item(this.selected_index);
    };

    PAutocompleteDropdownController.prototype.item_down = function() {
      if (!this.dropdown_active && this.selected_index === 0) {
        this.dropdown_activate();
        return;
      }
      if (this.dropdown_active && this.selected_index === this.items_list().length - 1) {
        this.dropdown_deactivate();
        return;
      }
      this.selected_index += 1;
      return this.highlight_item(this.selected_index);
    };

    PAutocompleteDropdownController.prototype.highlight_item = function(index) {
      this.items_list().removeClass(this.active_item_class);
      $(this.items_list()[index]).addClass(this.active_item_class);
      return this.trigger(EVENT_DROPDOWN_ITEM_HIGHLIGHT, $.trim($(this.items_list()[index]).text()));
    };

    PAutocompleteDropdownController.prototype.dropdown_activate = function(top_active) {
      if (top_active == null) {
        top_active = true;
      }
      if (top_active) {
        this.selected_index = 0;
      } else {
        this.selected_index = this.items_list().length - 1;
      }
      this.dropdown_active = true;
      return this.highlight_item(this.selected_index);
    };

    PAutocompleteDropdownController.prototype.dropdown_deactivate = function() {
      this.items_list().removeClass(this.active_item_class);
      this.dropdown_active = false;
      this.trigger('dropdown_deactivate');
      return this.selected_index = 0;
    };

    return PAutocompleteDropdownController;

  })(Spine.Controller);

  module.exports = [PAutocompleteDropdownController, EVENT_DROPDOWN_ITEM_SELECT, EVENT_DROPDOWN_ITEM_HIGHLIGHT, EVENT_DROPDOWN_POPUP_SHOW, EVENT_DROPDOWN_POPUP_HIDE];

}).call(this);

}).call(this);},

/*ZB:  PAutocomplete/controllers/PAutocompleteInputController */
'controllers/PAutocompleteInputController': function(exports, require, module) {(function() {
(function() {
  var $, EVENT_INPUT_ITEM_SELECT, EVENT_LETTER_ENTERED, EVENT_REQUEST_SUGGESTIONS, PAutocompleteInputController, Spine, keyCode,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = require('jquery');

  keyCode = $.ui.keyCode;

  EVENT_INPUT_ITEM_SELECT = 'input_item_selected';

  EVENT_REQUEST_SUGGESTIONS = 'input_request_suggestions';

  EVENT_LETTER_ENTERED = 'input_letter_entered';

  PAutocompleteInputController = (function(superClass) {
    extend(PAutocompleteInputController, superClass);

    function PAutocompleteInputController() {
      this._show_popup = bind(this._show_popup, this);
      this._hide_popup = bind(this._hide_popup, this);
      this._event_keydown = bind(this._event_keydown, this);
      this.process_suggest_items = bind(this.process_suggest_items, this);

      /*
      Accepts:
      @el: main element.
      @dropdown: Object for displaying recieved items.
       */
      PAutocompleteInputController.__super__.constructor.apply(this, arguments);
      this.dropdown.bind('dropdown_deactivate', (function(_this) {
        return function() {
          return _this.el.val(_this._last_value);
        };
      })(this));
      this._popup_active = false;
      this._last_value = '';
      $(this.el).keydown(this._event_keydown);
    }

    PAutocompleteInputController.prototype.process_suggest_items = function(items) {
      var predicate;
      predicate = this.dropdown_predicate || (function(i) {
        return i.length > 0;
      });
      if (predicate(items)) {
        return this._show_popup(items);
      } else {
        return this._hide_popup();
      }
    };

    PAutocompleteInputController.prototype._event_keydown = function(ev) {
      var length, ref, suggest;
      switch (ev.keyCode) {
        case keyCode.UP:
          event.preventDefault();
          this.dropdown.item_up();
          break;
        case keyCode.DOWN:
          this.dropdown.item_down();
          break;
        case keyCode.ENTER:
          this.trigger(EVENT_INPUT_ITEM_SELECT, this.dropdown.get_selected_item());
          this._hide_popup();
          break;
        case keyCode.ESCAPE:
          if (this.dropdown.dropdown_active) {
            this.el.val(this._last_value);
          }
          this._hide_popup();
      }
      length = this.el.val().length;
      suggest = (function(_this) {
        return function() {
          var timeout_func;
          _this._last_value = _this.el.val();
          timeout_func = function() {
            if (_this.el.val().length >= _this.min_input_chars) {
              return _this.trigger(EVENT_REQUEST_SUGGESTIONS, _this.el.val());
            }
          };
          if (_this._timeout_handler) {
            clearTimeout(_this._timeout_handler);
          }
          return _this._timeout_handler = setTimeout(timeout_func, _this.delay);
        };
      })(this);
      if (!this._control_buttons_handle(ev)) {
        this.trigger(EVENT_LETTER_ENTERED);
        if ((length + 2) <= this.min_input_chars) {
          this._hide_popup();
          return true;
        } else {
          return suggest();
        }
      } else {
        if ((ref = ev.keyCode) === keyCode.DELETE || ref === 8) {
          if (length <= this.min_input_chars) {
            this._hide_popup();
            return true;
          } else {
            return suggest();
          }
        }
      }
    };

    PAutocompleteInputController.prototype._control_buttons_handle = function(event) {
      var ref;
      return (ref = event.keyCode) === keyCode.UP || ref === keyCode.DOWN || ref === keyCode.ENTER || ref === keyCode.ESCAPE || ref === 8 || ref === keyCode.DELETE || ref === keyCode.TAB;
    };

    PAutocompleteInputController.prototype._hide_popup = function() {
      if (this._popup_active) {
        this.dropdown.hide_popup();
        return this._popup_active = false;
      }
    };

    PAutocompleteInputController.prototype._show_popup = function(items) {
      if (!this._popup_active) {
        this._popup_active = true;
      }
      return this.dropdown.show_popup(items);
    };

    return PAutocompleteInputController;

  })(Spine.Controller);

  module.exports = [PAutocompleteInputController, EVENT_INPUT_ITEM_SELECT, EVENT_REQUEST_SUGGESTIONS, EVENT_LETTER_ENTERED];

}).call(this);

}).call(this);},

/*ZB:  PAutocomplete/index */
'index': function(exports, require, module) {(function() {
(function() {
  var $, DEFAULT_ACTIVE_ITEM_CLASS, DEFAULT_DELAY, DEFAULT_ITEMS_SELECTOR, DEFAULT_MIN_CHARS, DEFAULT_POPUP_SELECTOR, DEFAULT_TEMPLATE, EVENT_DROPDOWN_ITEM_HIGHLIGHT, EVENT_DROPDOWN_ITEM_SELECT, EVENT_DROPDOWN_POPUP_HIDE, EVENT_DROPDOWN_POPUP_SHOW, EVENT_INPUT_ITEM_SELECT, EVENT_ITEM_SELECTED, EVENT_LETTER_ENTERED, EVENT_REQUEST_SUGGESTIONS, PAutocompleteController, PAutocompleteDropdownController, PAutocompleteInputController, Spine, _, ref, ref1, regexp_quote,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  regexp_quote = (require('CSLib')).utils.regexp_quote;

  _ = require('lodash');

  $ = require('jquery');

  ref = require('controllers/PAutocompleteDropdownController'), PAutocompleteDropdownController = ref[0], EVENT_DROPDOWN_ITEM_SELECT = ref[1], EVENT_DROPDOWN_ITEM_HIGHLIGHT = ref[2], EVENT_DROPDOWN_POPUP_SHOW = ref[3], EVENT_DROPDOWN_POPUP_HIDE = ref[4];

  ref1 = require('controllers/PAutocompleteInputController'), PAutocompleteInputController = ref1[0], EVENT_INPUT_ITEM_SELECT = ref1[1], EVENT_REQUEST_SUGGESTIONS = ref1[2], EVENT_LETTER_ENTERED = ref1[3];

  DEFAULT_DELAY = 300;

  DEFAULT_MIN_CHARS = 3;

  DEFAULT_ITEMS_SELECTOR = '.b-autocomplete__link';

  DEFAULT_POPUP_SELECTOR = '#search_autocomplete';

  DEFAULT_ACTIVE_ITEM_CLASS = 'b-autocomplete__link_stat_current';

  DEFAULT_TEMPLATE = 'views/dropdown';

  EVENT_ITEM_SELECTED = 'PA.item_selected';

  PAutocompleteController = (function(superClass) {
    extend(PAutocompleteController, superClass);

    function PAutocompleteController(options) {
      this.process_suggest = bind(this.process_suggest, this);
      PAutocompleteController.__super__.constructor.apply(this, arguments);
      if (!('input_selector' in options)) {
        throw 'input_selector param is missing';
      }
      if (!('url' in options)) {
        throw 'url param is missing';
      }
      if (!('delay' in options)) {
        options.delay = DEFAULT_DELAY;
      }
      if (!('min_input_chars' in options)) {
        options.min_input_chars = DEFAULT_MIN_CHARS;
      }
      if (!('items_selector' in options)) {
        options.items_selector = DEFAULT_ITEMS_SELECTOR;
      }
      if (!('popup_selector' in options)) {
        options.popup_selector = DEFAULT_POPUP_SELECTOR;
      }
      if (!('active_item_class' in options)) {
        options.active_item_class = DEFAULT_ACTIVE_ITEM_CLASS;
      }
      if (!('template' in options)) {
        options.template = DEFAULT_TEMPLATE;
      }
      options.popup_additional_cls || (options.popup_additional_cls = '');
      options.is_fixed || (options.is_fixed = false);
      if (options.selected_item_handler) {
        this.selected = options.selected_item_handler;
      }
      this.build_suggest_params_handler = options.build_suggest_params_handler || this._get_default_suggest_params;
      if ('form_id' in options) {
        this.form_id = options.form_id;
      }
      this.suggest_url = options.url;
      this._dropdown = new PAutocompleteDropdownController({
        active_item_class: options.active_item_class,
        popup_selector: options.popup_selector,
        input_selector: options.input_selector,
        item_list_selector: options.items_selector,
        template: options.template,
        input_container: options.input_container,
        popup_additional_cls: options.popup_additional_cls,
        is_fixed: options.is_fixed
      });
      this._input = new PAutocompleteInputController({
        el: $(options.input_selector),
        suggest_url: options.url,
        dropdown: this._dropdown,
        min_input_chars: options.min_input_chars,
        delay: options.delay,
        dropdown_predicate: options.dropdown_predicate
      });
      this._input.bind(EVENT_REQUEST_SUGGESTIONS, this.process_suggest);
      this._input.bind(EVENT_INPUT_ITEM_SELECT, (function(_this) {
        return function(item) {
          return _this.trigger(EVENT_ITEM_SELECTED, item);
        };
      })(this));
      this._dropdown.bind(EVENT_DROPDOWN_ITEM_HIGHLIGHT, (function(_this) {
        return function(item) {
          return _this._input.el.val(item);
        };
      })(this));
      this._dropdown.bind(EVENT_DROPDOWN_ITEM_SELECT, (function(_this) {
        return function(item) {
          return _this.trigger(EVENT_ITEM_SELECTED, item);
        };
      })(this));
      this._dropdown.bind(EVENT_DROPDOWN_POPUP_HIDE, (function(_this) {
        return function(ev) {
          var ref2;
          return (ref2 = _this.xhr) != null ? ref2.abort() : void 0;
        };
      })(this));
      if (this.selected) {
        this.bind(EVENT_ITEM_SELECTED, this.selected);
      }
      this.process_highlight(this._input, this._dropdown);
    }

    PAutocompleteController.prototype.on_item_selected = function(handler) {
      return this.bind(EVENT_ITEM_SELECTED, handler);
    };

    PAutocompleteController.prototype.process_suggest = function() {
      if (this.xhr) {
        this.xhr.abort();
      }
      if (typeof SW !== "undefined" && SW !== null) {
        SW.c["disable_ajax_indicator"] = true;
      }
      this.xhr = $.ajax({
        url: this.suggest_url,
        data: this.build_suggest_params_handler(),
        success: (function(_this) {
          return function(data) {
            return _this._input.process_suggest_items(data);
          };
        })(this),
        error: (function(_this) {
          return function(xhr, textStatus, err) {
            return _this.log({
              textStatus: textStatus,
              error: err
            });
          };
        })(this)
      });
      return typeof SW !== "undefined" && SW !== null ? SW.c["disable_ajax_indicator"] = false : void 0;
    };

    PAutocompleteController.prototype.process_highlight = function(_input, _dropdown) {
      var make_match_bold;
      make_match_bold = (function(_this) {
        return function() {
          var i, items, len, pattern, ref2, word, words;
          if (_input.el.val() === "") {
            return;
          }
          words = [];
          ref2 = _input.el.val().split(" ");
          for (i = 0, len = ref2.length; i < len; i++) {
            word = ref2[i];
            if (!word) {
              continue;
            }
            words.push(regexp_quote(word));
          }
          pattern = new RegExp("(" + words.join("|") + ")", "gi");
          items = _this.highlight_selector ? $(_this.highlight_selector) : _dropdown.items_list();
          return items.map(function(idx, item) {
            var $item, text;
            $item = $(item);
            text = _.escape($item != null ? $item.text() : void 0);
            text = text.replace(pattern, "<b>$1</b>");
            return $item.html(text);
          });
        };
      })(this);
      _dropdown.bind(EVENT_DROPDOWN_POPUP_SHOW, make_match_bold);
      return _input.bind(EVENT_LETTER_ENTERED, make_match_bold);
    };

    PAutocompleteController.prototype._get_default_suggest_params = function() {
      return {
        'term': this._input.el.val()
      };
    };

    return PAutocompleteController;

  })(Spine.Controller);

  module.exports = PAutocompleteController;

}).call(this);

}).call(this);},

/*ZB:  PAutocomplete/lib/setup */
'lib/setup': function(exports, require, module) {(function() {
(function() {
  require('spine');

  require('spine/lib/local');

  require('spine/lib/ajax');

  require('spine/lib/manager');

  require('spine/lib/route');

  require('spine/lib/tmpl');

}).call(this);

}).call(this);},

/*ZB:  PAutocomplete/views/dropdown */
'views/dropdown': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      var i, item, len, ref;
    
      __out.push('<ul id="search_autocomplete" class="b-autocomplete b-portal-header__autocomplete ');
    
      __out.push(__sanitize(this.popup_additional_cls));
    
      __out.push('">\n    ');
    
      if (this.items) {
        __out.push('\n    ');
        ref = this.items;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          __out.push('\n        <li class="b-autocomplete__item">\n            <a  class="b-autocomplete__link"\n                data-class="');
          __out.push(__sanitize(item["class"]));
          __out.push('"\n                data-href="');
          __out.push(__sanitize(item.href));
          __out.push('">\n                    ');
          __out.push(__sanitize(item.label));
          __out.push('\n            </a>\n        </li>\n    ');
        }
        __out.push('\n    ');
      }
    
      __out.push('\n</ul>\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);},

/*ZB:  PAutocomplete/views/group_dropdown */
'views/group_dropdown': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      var i, item, j, k, len, len1, ref, ref1;
    
      __out.push('<div class="b-search-dropdown_group">\n    ');
    
      if (this.items) {
        __out.push('\n    ');
        ref = this.items;
        for (j = 0, len = ref.length; j < len; j++) {
          item = ref[j];
          __out.push('\n        <div class="group_items_wrapper">\n            <ul class="group-items">\n                ');
          ref1 = item.children;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            i = ref1[k];
            __out.push('\n                    <li>\n                        <a  class="item"\n                            data-class="');
            __out.push(__sanitize(i["class"]));
            __out.push('"\n                            data-href="');
            __out.push(__sanitize(i.href));
            __out.push('">\n                            ');
            __out.push(__sanitize(i.label));
            __out.push('\n                        </a>\n                    </li>\n                ');
          }
          __out.push('\n            </ul>\n        </div>\n        <div class="group_attributes">\n            <p class="title">');
          __out.push(__sanitize(item.label));
          __out.push('</p>\n        </div>\n    ');
        }
        __out.push('\n    ');
      }
    
      __out.push('\n</div> \n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);},

/*ZB:  PAutocomplete/views/keyword_dropdown */
'views/keyword_dropdown': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      var i, item, len, ref;
    
      __out.push('<ul class=" search_autocomplete b-autocomplete b-portal-header__autocomplete ');
    
      __out.push(__sanitize(this.popup_additional_cls));
    
      __out.push('">\n    ');
    
      if (this.items) {
        __out.push('\n        ');
        ref = this.items;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          __out.push('\n            <li class="b-autocomplete__item">\n                <a class="b-autocomplete__link" >\n                    ');
          __out.push(__sanitize(item));
          __out.push('\n                </a>\n            </li>\n        ');
        }
        __out.push('\n    ');
      }
    
      __out.push('\n</ul>\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);}
});


/*ZB: spine */
require.define('spine', {

/*ZB:  spine/lib/spine */
'lib/spine': function(exports, require, module) {(function() {
// Generated by CoffeeScript 1.9.3

/*
Spine.js MVC library
Released under the MIT License
 */

(function() {
  var $, Controller, Events, Log, Model, Module, Spine, createObject, makeArray, moduleKeywords,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Events = {
    bind: function(ev, callback) {
      var base, evs, j, len, name;
      evs = ev.split(' ');
      if (!this.hasOwnProperty('_callbacks')) {
        this._callbacks || (this._callbacks = {});
      }
      for (j = 0, len = evs.length; j < len; j++) {
        name = evs[j];
        (base = this._callbacks)[name] || (base[name] = []);
        this._callbacks[name].push(callback);
      }
      return this;
    },
    one: function(ev, callback) {
      var handler;
      return this.bind(ev, handler = function() {
        this.unbind(ev, handler);
        return callback.apply(this, arguments);
      });
    },
    trigger: function() {
      var args, callback, ev, j, len, list, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ev = args.shift();
      list = (ref = this._callbacks) != null ? ref[ev] : void 0;
      if (!list) {
        return;
      }
      for (j = 0, len = list.length; j < len; j++) {
        callback = list[j];
        if (callback.apply(this, args) === false) {
          break;
        }
      }
      return true;
    },
    listenTo: function(obj, ev, callback) {
      obj.bind(ev, callback);
      this.listeningTo || (this.listeningTo = []);
      this.listeningTo.push({
        obj: obj,
        ev: ev,
        callback: callback
      });
      return this;
    },
    listenToOnce: function(obj, ev, callback) {
      var handler, listeningToOnce;
      listeningToOnce = this.listeningToOnce || (this.listeningToOnce = []);
      obj.bind(ev, handler = function() {
        var i, idx, j, len, lt;
        idx = -1;
        for (i = j = 0, len = listeningToOnce.length; j < len; i = ++j) {
          lt = listeningToOnce[i];
          if (lt.obj === obj) {
            if (lt.ev === ev && lt.callback === handler) {
              idx = i;
            }
          }
        }
        obj.unbind(ev, handler);
        if (idx !== -1) {
          listeningToOnce.splice(idx, 1);
        }
        return callback.apply(this, arguments);
      });
      listeningToOnce.push({
        obj: obj,
        ev: ev,
        callback: handler
      });
      return this;
    },
    stopListening: function(obj, events, callback) {
      var e, ev, evts, idx, j, k, l, len, len1, len2, len3, listeningTo, lt, m, n, ref, ref1, ref2;
      if (arguments.length === 0) {
        ref = [this.listeningTo, this.listeningToOnce];
        for (j = 0, len = ref.length; j < len; j++) {
          listeningTo = ref[j];
          if (!(listeningTo != null ? listeningTo.length : void 0)) {
            continue;
          }
          for (k = 0, len1 = listeningTo.length; k < len1; k++) {
            lt = listeningTo[k];
            lt.obj.unbind(lt.ev, lt.callback);
          }
        }
        this.listeningTo = void 0;
        this.listeningToOnce = void 0;
      } else if (obj) {
        events = events ? events.split(' ') : [void 0];
        ref1 = [this.listeningTo, this.listeningToOnce];
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          listeningTo = ref1[l];
          if (!listeningTo) {
            continue;
          }
          for (m = 0, len3 = events.length; m < len3; m++) {
            ev = events[m];
            for (idx = n = ref2 = listeningTo.length - 1; ref2 <= 0 ? n <= 0 : n >= 0; idx = ref2 <= 0 ? ++n : --n) {
              lt = listeningTo[idx];
              if (lt.obj !== obj) {
                continue;
              }
              if (callback && lt.callback !== callback) {
                continue;
              }
              if ((!ev) || (ev === lt.ev)) {
                lt.obj.unbind(lt.ev, lt.callback);
                if (idx !== -1) {
                  listeningTo.splice(idx, 1);
                }
              } else if (ev) {
                evts = lt.ev.split(' ');
                if (indexOf.call(evts, ev) >= 0) {
                  evts = (function() {
                    var len4, p, results;
                    results = [];
                    for (p = 0, len4 = evts.length; p < len4; p++) {
                      e = evts[p];
                      if (e !== ev) {
                        results.push(e);
                      }
                    }
                    return results;
                  })();
                  lt.ev = $.trim(evts.join(' '));
                  lt.obj.unbind(ev, lt.callback);
                }
              }
            }
          }
        }
      }
      return this;
    },
    unbind: function(ev, callback) {
      var cb, evs, i, j, k, len, len1, list, name, ref;
      if (arguments.length === 0) {
        this._callbacks = {};
        return this;
      }
      if (!ev) {
        return this;
      }
      evs = ev.split(' ');
      for (j = 0, len = evs.length; j < len; j++) {
        name = evs[j];
        list = (ref = this._callbacks) != null ? ref[name] : void 0;
        if (!list) {
          continue;
        }
        if (!callback) {
          delete this._callbacks[name];
          continue;
        }
        for (i = k = 0, len1 = list.length; k < len1; i = ++k) {
          cb = list[i];
          if (!(cb === callback)) {
            continue;
          }
          list = list.slice();
          list.splice(i, 1);
          this._callbacks[name] = list;
          break;
        }
      }
      return this;
    }
  };

  Events.on = Events.bind;

  Events.off = Events.unbind;

  Log = {
    trace: true,
    logPrefix: '(App)',
    log: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!this.trace) {
        return;
      }
      if (this.logPrefix) {
        args.unshift(this.logPrefix);
      }
      if (typeof console !== "undefined" && console !== null) {
        if (typeof console.log === "function") {
          console.log.apply(console, args);
        }
      }
      return this;
    }
  };

  moduleKeywords = ['included', 'extended'];

  Module = (function() {
    Module.include = function(obj) {
      var key, ref, value;
      if (!obj) {
        throw new Error('include(obj) requires obj');
      }
      for (key in obj) {
        value = obj[key];
        if (indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((ref = obj.included) != null) {
        ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, ref, value;
      if (!obj) {
        throw new Error('extend(obj) requires obj');
      }
      for (key in obj) {
        value = obj[key];
        if (indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((ref = obj.extended) != null) {
        ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      return (function(_this) {
        return function() {
          return func.apply(_this, arguments);
        };
      })(this);
    };

    Module.prototype.proxy = function(func) {
      return (function(_this) {
        return function() {
          return func.apply(_this, arguments);
        };
      })(this);
    };

    function Module() {
      if (typeof this.init === "function") {
        this.init.apply(this, arguments);
      }
    }

    return Module;

  })();

  Model = (function(superClass) {
    extend(Model, superClass);

    Model.extend(Events);

    Model.include(Events);

    Model.records = [];

    Model.irecords = {};

    Model.attributes = [];

    Model.configure = function() {
      var attributes, name;
      name = arguments[0], attributes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.className = name;
      this.deleteAll();
      if (attributes.length) {
        this.attributes = attributes;
      }
      this.attributes && (this.attributes = makeArray(this.attributes));
      this.attributes || (this.attributes = []);
      this.unbind();
      return this;
    };

    Model.toString = function() {
      return this.className + "(" + (this.attributes.join(", ")) + ")";
    };

    Model.find = function(id, notFound) {
      var ref;
      if (notFound == null) {
        notFound = this.notFound;
      }
      return ((ref = this.irecords[id]) != null ? ref.clone() : void 0) || (typeof notFound === "function" ? notFound(id) : void 0);
    };

    Model.findAll = function(ids, notFound) {
      var id, j, len, results;
      results = [];
      for (j = 0, len = ids.length; j < len; j++) {
        id = ids[j];
        if (this.find(id, notFound)) {
          results.push(this.find(id));
        }
      }
      return results;
    };

    Model.notFound = function(id) {
      return null;
    };

    Model.exists = function(id) {
      return Boolean(this.irecords[id]);
    };

    Model.addRecord = function(record, idx) {
      var root;
      if (root = this.irecords[record.id || record.cid]) {
        root.refresh(record);
      } else {
        record.id || (record.id = record.cid);
        this.irecords[record.id] = this.irecords[record.cid] = record;
        if (idx !== void 0) {
          this.records.splice(idx, 0, record);
        } else {
          this.records.push(record);
        }
      }
      return record;
    };

    Model.refresh = function(values, options) {
      var j, len, record, records, result;
      if (options == null) {
        options = {};
      }
      if (options.clear) {
        this.deleteAll();
      }
      records = this.fromJSON(values);
      if (!Array.isArray(records)) {
        records = [records];
      }
      for (j = 0, len = records.length; j < len; j++) {
        record = records[j];
        this.addRecord(record);
      }
      this.sort();
      result = this.cloneArray(records);
      this.trigger('refresh', result, options);
      return result;
    };

    Model.select = function(callback) {
      var j, len, record, ref, results;
      ref = this.records;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        if (callback(record)) {
          results.push(record.clone());
        }
      }
      return results;
    };

    Model.findByAttribute = function(name, value) {
      var j, len, record, ref;
      ref = this.records;
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        if (record[name] === value) {
          return record.clone();
        }
      }
      return null;
    };

    Model.findAllByAttribute = function(name, value) {
      return this.select(function(item) {
        return item[name] === value;
      });
    };

    Model.each = function(callback) {
      var j, len, record, ref, results;
      ref = this.records;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        results.push(callback(record.clone()));
      }
      return results;
    };

    Model.all = function() {
      return this.cloneArray(this.records);
    };

    Model.slice = function(begin, end) {
      if (begin == null) {
        begin = 0;
      }
      return this.cloneArray(this.records.slice(begin, end));
    };

    Model.first = function(end) {
      var ref;
      if (end == null) {
        end = 1;
      }
      if (end > 1) {
        return this.cloneArray(this.records.slice(0, end));
      } else {
        return (ref = this.records[0]) != null ? ref.clone() : void 0;
      }
    };

    Model.last = function(begin) {
      var ref;
      if (typeof begin === 'number') {
        return this.cloneArray(this.records.slice(-begin));
      } else {
        return (ref = this.records[this.records.length - 1]) != null ? ref.clone() : void 0;
      }
    };

    Model.count = function() {
      return this.records.length;
    };

    Model.deleteAll = function() {
      this.records = [];
      return this.irecords = {};
    };

    Model.destroyAll = function(options) {
      var j, len, record, ref, results;
      ref = this.records;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        results.push(record.destroy(options));
      }
      return results;
    };

    Model.update = function(id, atts, options) {
      return this.find(id).updateAttributes(atts, options);
    };

    Model.create = function(atts, options) {
      var record;
      record = new this(atts);
      return record.save(options);
    };

    Model.destroy = function(id, options) {
      var ref;
      return (ref = this.find(id)) != null ? ref.destroy(options) : void 0;
    };

    Model.change = function(callbackOrParams) {
      if (typeof callbackOrParams === 'function') {
        return this.bind('change', callbackOrParams);
      } else {
        return this.trigger.apply(this, ['change'].concat(slice.call(arguments)));
      }
    };

    Model.fetch = function(callbackOrParams) {
      if (typeof callbackOrParams === 'function') {
        return this.bind('fetch', callbackOrParams);
      } else {
        return this.trigger.apply(this, ['fetch'].concat(slice.call(arguments)));
      }
    };

    Model.toJSON = function() {
      return this.records;
    };

    Model.beforeFromJSON = function(objects) {
      return objects;
    };

    Model.fromJSON = function(objects) {
      var j, len, results, value;
      if (!objects) {
        return;
      }
      if (typeof objects === 'string') {
        objects = JSON.parse(objects);
      }
      objects = this.beforeFromJSON(objects);
      if (Array.isArray(objects)) {
        results = [];
        for (j = 0, len = objects.length; j < len; j++) {
          value = objects[j];
          if (value instanceof this) {
            results.push(value);
          } else {
            results.push(new this(value));
          }
        }
        return results;
      } else {
        if (objects instanceof this) {
          return objects;
        }
        return new this(objects);
      }
    };

    Model.fromForm = function() {
      var ref;
      return (ref = new this).fromForm.apply(ref, arguments);
    };

    Model.sort = function() {
      if (this.comparator) {
        this.records.sort(this.comparator);
      }
      return this;
    };

    Model.cloneArray = function(array) {
      var j, len, results, value;
      results = [];
      for (j = 0, len = array.length; j < len; j++) {
        value = array[j];
        results.push(value.clone());
      }
      return results;
    };

    Model.idCounter = 0;

    Model.uid = function(prefix) {
      var uid;
      if (prefix == null) {
        prefix = '';
      }
      uid = prefix + this.idCounter++;
      if (this.exists(uid)) {
        uid = this.uid(prefix);
      }
      return uid;
    };

    function Model(atts) {
      Model.__super__.constructor.apply(this, arguments);
      if ((this.constructor.uuid != null) && typeof this.constructor.uuid === 'function') {
        this.cid = this.constructor.uuid();
        if (!this.id) {
          this.id = this.cid;
        }
      } else {
        this.cid = (atts != null ? atts.cid : void 0) || this.constructor.uid('c-');
      }
      if (atts) {
        this.load(atts);
      }
    }

    Model.prototype.isNew = function() {
      return !this.exists();
    };

    Model.prototype.isValid = function() {
      return !this.validate();
    };

    Model.prototype.validate = function() {};

    Model.prototype.load = function(atts) {
      var key, value;
      if (atts.id) {
        this.id = atts.id;
      }
      for (key in atts) {
        value = atts[key];
        if (typeof this[key] === 'function') {
          if (typeof value === 'function') {
            continue;
          }
          this[key](value);
        } else {
          this[key] = value;
        }
      }
      return this;
    };

    Model.prototype.attributes = function() {
      var j, key, len, ref, result;
      result = {};
      ref = this.constructor.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        if (key in this) {
          if (typeof this[key] === 'function') {
            result[key] = this[key]();
          } else {
            result[key] = this[key];
          }
        }
      }
      if (this.id) {
        result.id = this.id;
      }
      return result;
    };

    Model.prototype.eql = function(rec) {
      return rec && rec.constructor === this.constructor && ((rec.cid === this.cid) || (rec.id && rec.id === this.id));
    };

    Model.prototype.save = function(options) {
      var error, record;
      if (options == null) {
        options = {};
      }
      if (options.validate !== false) {
        error = this.validate();
        if (error) {
          this.trigger('error', this, error);
          return false;
        }
      }
      this.trigger('beforeSave', this, options);
      record = this.isNew() ? this.create(options) : this.update(options);
      this.stripCloneAttrs();
      this.trigger('save', record, options);
      return record;
    };

    Model.prototype.stripCloneAttrs = function() {
      var key, value;
      if (this.hasOwnProperty('cid')) {
        return;
      }
      for (key in this) {
        if (!hasProp.call(this, key)) continue;
        value = this[key];
        if (indexOf.call(this.constructor.attributes, key) >= 0) {
          delete this[key];
        }
      }
      return this;
    };

    Model.prototype.updateAttribute = function(name, value, options) {
      var atts;
      atts = {};
      atts[name] = value;
      return this.updateAttributes(atts, options);
    };

    Model.prototype.updateAttributes = function(atts, options) {
      this.load(atts);
      return this.save(options);
    };

    Model.prototype.changeID = function(id) {
      var records;
      if (id === this.id) {
        return;
      }
      records = this.constructor.irecords;
      records[id] = records[this.id];
      if (this.cid !== this.id) {
        delete records[this.id];
      }
      return this.id = id;
    };

    Model.prototype.remove = function(options) {
      var i, j, len, record, records;
      if (options == null) {
        options = {};
      }
      records = this.constructor.records.slice(0);
      for (i = j = 0, len = records.length; j < len; i = ++j) {
        record = records[i];
        if (!(this.eql(record))) {
          continue;
        }
        records.splice(i, 1);
        break;
      }
      this.constructor.records = records;
      if (options.clear) {
        delete this.constructor.irecords[this.id];
        return delete this.constructor.irecords[this.cid];
      }
    };

    Model.prototype.destroy = function(options) {
      if (options == null) {
        options = {};
      }
      if (options.clear == null) {
        options.clear = true;
      }
      this.trigger('beforeDestroy', this, options);
      this.remove(options);
      this.destroyed = true;
      this.trigger('destroy', this, options);
      this.trigger('change', this, 'destroy', options);
      if (this.listeningTo) {
        this.stopListening();
      }
      this.unbind();
      return this;
    };

    Model.prototype.dup = function(newRecord) {
      var atts, record;
      if (newRecord == null) {
        newRecord = true;
      }
      atts = this.attributes();
      if (newRecord) {
        delete atts.id;
      } else {
        atts.cid = this.cid;
      }
      record = new this.constructor(atts);
      if (!newRecord) {
        this._callbacks && (record._callbacks = this._callbacks);
      }
      return record;
    };

    Model.prototype.clone = function() {
      return createObject(this);
    };

    Model.prototype.reload = function() {
      var original;
      if (this.isNew()) {
        return this;
      }
      original = this.constructor.find(this.id);
      this.load(original.attributes());
      return original;
    };

    Model.prototype.refresh = function(atts) {
      atts = this.constructor.fromJSON(atts);
      if (atts.id && this.id !== atts.id) {
        this.changeID(atts.id);
      }
      this.constructor.irecords[this.id].load(atts);
      this.trigger('refresh', this);
      this.trigger('change', this, 'refresh');
      return this;
    };

    Model.prototype.toJSON = function() {
      return this.attributes();
    };

    Model.prototype.toString = function() {
      return "<" + this.constructor.className + " (" + (JSON.stringify(this)) + ")>";
    };

    Model.prototype.fromForm = function(form) {
      var checkbox, j, k, key, l, len, len1, len2, name, name1, ref, ref1, ref2, result;
      result = {};
      ref = $(form).find('[type=checkbox]:not([value])');
      for (j = 0, len = ref.length; j < len; j++) {
        checkbox = ref[j];
        result[checkbox.name] = $(checkbox).prop('checked');
      }
      ref1 = $(form).find('[type=checkbox][name$="[]"]');
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        checkbox = ref1[k];
        name = checkbox.name.replace(/\[\]$/, '');
        result[name] || (result[name] = []);
        if ($(checkbox).prop('checked')) {
          result[name].push(checkbox.value);
        }
      }
      ref2 = $(form).serializeArray();
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        key = ref2[l];
        result[name1 = key.name] || (result[name1] = key.value);
      }
      return this.load(result);
    };

    Model.prototype.exists = function() {
      return this.constructor.exists(this.id);
    };

    Model.prototype.update = function(options) {
      var clone, records;
      this.trigger('beforeUpdate', this, options);
      records = this.constructor.irecords;
      records[this.id].load(this.attributes());
      this.constructor.sort();
      clone = records[this.id].clone();
      clone.trigger('update', clone, options);
      clone.trigger('change', clone, 'update', options);
      return clone;
    };

    Model.prototype.create = function(options) {
      var clone, record;
      this.trigger('beforeCreate', this, options);
      this.id || (this.id = this.cid);
      record = this.dup(false);
      this.constructor.addRecord(record, options.idx);
      this.constructor.sort();
      clone = record.clone();
      clone.trigger('create', clone, options);
      clone.trigger('change', clone, 'create', options);
      return clone;
    };

    Model.prototype.bind = function() {
      var record;
      record = this.constructor.irecords[this.id] || this;
      return Events.bind.apply(record, arguments);
    };

    Model.prototype.one = function() {
      var record;
      record = this.constructor.irecords[this.id] || this;
      return Events.one.apply(record, arguments);
    };

    Model.prototype.unbind = function() {
      var record;
      record = this.constructor.irecords[this.id] || this;
      return Events.unbind.apply(record, arguments);
    };

    Model.prototype.trigger = function() {
      var ref;
      Events.trigger.apply(this, arguments);
      if (arguments[0] === 'refresh') {
        return true;
      }
      return (ref = this.constructor).trigger.apply(ref, arguments);
    };

    return Model;

  })(Module);

  Model.prototype.on = Model.prototype.bind;

  Model.prototype.off = Model.prototype.unbind;

  Controller = (function(superClass) {
    extend(Controller, superClass);

    Controller.include(Events);

    Controller.include(Log);

    Controller.prototype.eventSplitter = /^(\S+)\s*(.*)$/;

    Controller.prototype.tag = 'div';

    function Controller(options) {
      this.release = bind(this.release, this);
      var context, key, parent_prototype, ref, value;
      this.options = options;
      ref = this.options;
      for (key in ref) {
        value = ref[key];
        this[key] = value;
      }
      if (!this.el) {
        this.el = document.createElement(this.tag);
      }
      this.el = $(this.el);
      if (this.className) {
        this.el.addClass(this.className);
      }
      if (this.attributes) {
        this.el.attr(this.attributes);
      }
      if (!this.events) {
        this.events = this.constructor.events;
      }
      if (!this.elements) {
        this.elements = this.constructor.elements;
      }
      context = this;
      while (parent_prototype = context.constructor.__super__) {
        if (parent_prototype.events) {
          this.events = $.extend({}, parent_prototype.events, this.events);
        }
        if (parent_prototype.elements) {
          this.elements = $.extend({}, parent_prototype.elements, this.elements);
        }
        context = parent_prototype;
      }
      if (this.events) {
        this.delegateEvents(this.events);
      }
      if (this.elements) {
        this.refreshElements();
      }
      Controller.__super__.constructor.apply(this, arguments);
    }

    Controller.prototype.release = function() {
      this.trigger('release', this);
      this.el.remove();
      this.unbind();
      return this.stopListening();
    };

    Controller.prototype.$ = function(selector) {
      return this.el.find(selector);
    };

    Controller.prototype.delegateEvents = function(events) {
      var eventName, key, match, method, results, selector;
      results = [];
      for (key in events) {
        method = events[key];
        if (typeof method === 'function') {
          method = (function(_this) {
            return function(method) {
              return function() {
                method.apply(_this, arguments);
                return true;
              };
            };
          })(this)(method);
        } else {
          if (!this[method]) {
            throw new Error(method + " doesn't exist");
          }
          method = (function(_this) {
            return function(method) {
              return function() {
                _this[method].apply(_this, arguments);
                return true;
              };
            };
          })(this)(method);
        }
        match = key.match(this.eventSplitter);
        eventName = match[1];
        selector = match[2];
        if (selector === '') {
          results.push(this.el.bind(eventName, method));
        } else {
          results.push(this.el.on(eventName, selector, method));
        }
      }
      return results;
    };

    Controller.prototype.refreshElements = function() {
      var key, ref, results, value;
      ref = this.elements;
      results = [];
      for (key in ref) {
        value = ref[key];
        results.push(this[value] = this.$(key));
      }
      return results;
    };

    Controller.prototype.delay = function(func, timeout) {
      return setTimeout(this.proxy(func), timeout || 0);
    };

    Controller.prototype.html = function(element) {
      this.el.html(element.el || element);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.append = function() {
      var e, elements, ref;
      elements = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      elements = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = elements.length; j < len; j++) {
          e = elements[j];
          results.push(e.el || e);
        }
        return results;
      })();
      (ref = this.el).append.apply(ref, elements);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.appendTo = function(element) {
      this.el.appendTo(element.el || element);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.prepend = function() {
      var e, elements, ref;
      elements = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      elements = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = elements.length; j < len; j++) {
          e = elements[j];
          results.push(e.el || e);
        }
        return results;
      })();
      (ref = this.el).prepend.apply(ref, elements);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.replace = function(element) {
      var previous, ref, ref1;
      element = element.el || element;
      if (typeof element === "string") {
        element = $.trim(element);
      }
      ref1 = [this.el, $(((ref = $.parseHTML(element)) != null ? ref[0] : void 0) || element)], previous = ref1[0], this.el = ref1[1];
      previous.replaceWith(this.el);
      this.delegateEvents(this.events);
      this.refreshElements();
      return this.el;
    };

    return Controller;

  })(Module);

  $ = (typeof window !== "undefined" && window !== null ? window.jQuery : void 0) || (typeof window !== "undefined" && window !== null ? window.Zepto : void 0) || function(element) {
    return element;
  };

  createObject = Object.create || function(o) {
    var Func;
    Func = function() {};
    Func.prototype = o;
    return new Func();
  };

  makeArray = function(args) {
    return Array.prototype.slice.call(args, 0);
  };

  Spine = this.Spine = {};

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Spine;
  }

  Spine.version = '1.6.1';

  Spine.$ = $;

  Spine.Events = Events;

  Spine.Log = Log;

  Spine.Module = Module;

  Spine.Controller = Controller;

  Spine.Model = Model;

  Module.extend.call(Spine, Events);

  Module.create = Module.sub = Controller.create = Controller.sub = Model.sub = function(instances, statics) {
    var Result;
    Result = (function(superClass) {
      extend(Result, superClass);

      function Result() {
        return Result.__super__.constructor.apply(this, arguments);
      }

      return Result;

    })(this);
    if (instances) {
      Result.include(instances);
    }
    if (statics) {
      Result.extend(statics);
    }
    if (typeof Result.unbind === "function") {
      Result.unbind();
    }
    return Result;
  };

  Model.setup = function(name, attributes) {
    var Instance;
    if (attributes == null) {
      attributes = [];
    }
    Instance = (function(superClass) {
      extend(Instance, superClass);

      function Instance() {
        return Instance.__super__.constructor.apply(this, arguments);
      }

      return Instance;

    })(this);
    Instance.configure.apply(Instance, [name].concat(slice.call(attributes)));
    return Instance;
  };

  Spine.Class = Module;

}).call(this);

//# sourceMappingURL=spine.js.map

}).call(this);},

/*ZB:  spine/index */
'index': function(exports, require, module) {(function() {
module.exports = require('./lib/spine');
}).call(this);}
});


/*ZB: JoinNow */
require.define('JoinNow', {

/*ZB:  JoinNow/index */
'index': function(exports, require, module) {(function() {
(function() {
  var AUTOIO, Controller, JoinNow,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Controller = require("spine").Controller;

  AUTOIO = require("CSLib").AUTOIO;

  JoinNow = (function(superClass) {
    extend(JoinNow, superClass);

    function JoinNow(el, url, sourceId) {
      this.el = el;
      this.url = url;
      this.sourceId = sourceId;
      JoinNow.__super__.constructor.apply(this, arguments);
      this.url = this.url + "?source_id=" + this.sourceId;
      this.render_template();
    }

    JoinNow.prototype.render_template = function() {
      return AUTOIO.GET(this.url, (function(_this) {
        return function(data) {
          if (data.tmpl) {
            _this.el.addClass("b-info-panel b-info-panel_theme_white b-info-panel_border-solid_grey b-info-panel_padding_30");
            return _this.el.html(data.tmpl);
          }
        };
      })(this));
    };

    return JoinNow;

  })(Controller);

  module.exports = JoinNow;

}).call(this);

}).call(this);}
});


/*ZB: Metrics */
require.define('Metrics', {

/*ZB:  Metrics/index */
'index': function(exports, require, module) {(function() {
(function() {
  var Metrics, Trackers;

  Trackers = {
    ga: function(category, action, label, value) {
      if (typeof console.log === "function") {
        console.log("track GA Event", arguments);
      }
      return window._gaq.push(["_trackEvent", category, action, label, value]);
    }
  };

  Metrics = {
    trackEvent: function(category, action, label, value) {
      return Trackers.ga(category, action, label, value);
    }
  };

  module.exports = Metrics;

}).call(this);

}).call(this);}
});


/*ZB: Usefulness */
require.define('Usefulness', {

/*ZB:  Usefulness/index */
'index': function(exports, require, module) {(function() {
(function() {
  var $, Metrics, Usefulness, form_view, thankyou_view;

  $ = require('jquery');

  form_view = require('Usefulness/usefulness_form');

  thankyou_view = require('Usefulness/thankyou');

  Metrics = require('Metrics');

  Usefulness = function(node_selector, url) {
    var no_click_hadler, render_form, render_thankyou, yes_click_handler;
    render_form = function() {
      return $(node_selector).html(form_view());
    };
    render_thankyou = function() {
      return $(node_selector).html(thankyou_view());
    };
    yes_click_handler = function() {
      Metrics.trackEvent("Support_vote", "Yes", url, 1);
      return render_thankyou();
    };
    no_click_hadler = function() {
      Metrics.trackEvent("Support_vote", "No", url, 0);
      return render_thankyou();
    };
    $(node_selector).on("click", ".js_yes_button", yes_click_handler);
    $(node_selector).on("click", ".js_no_button", no_click_hadler);
    return render_form();
  };

  module.exports = Usefulness;

}).call(this);

}).call(this);},

/*ZB:  Usefulness/thankyou */
'thankyou': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      __out.push('<div class="b-usefull-article grey-color">\n    Благодарим за отзыв!\n</div>\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);},

/*ZB:  Usefulness/usefulness_form */
'usefulness_form': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      __out.push('<div class="b-usefull-article">\n    <span class="h-inline-block h-layout-margin-right-15 grey-color">Эта публикация была полезной для вас?</span>\n    <span class="b-usefull-article__button js_yes_button">Да</span>\n    <span class="b-usefull-article__button js_no_button">Нет</span>\n</div>\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);}
});


/*ZB: Popup */
require.define('Popup', {

/*ZB:  Popup/controllers/PopupController */
'controllers/PopupController': function(exports, require, module) {(function() {
(function() {
  var $, ARROW_CLS, CLOSE_BUTTON_CLASS, CSS_ARROW_EAST, CSS_ARROW_NORTH, CSS_ARROW_SOUTH, CSS_ARROW_WEST, CTX_ACTIVE_CLS, DATA, DEFAULT_ORIENTATION, EAST, EVENT, EVENT_CREATE_POPUP_HELP, EVENT_CREATE_POPUP_HINT, EVENT_HIDE_ALL_POPUPS, EVENT_HIDE_POPUPS, EVENT_POPUP_CLICKED, EVENT_POPUP_CREATED, EVENT_POPUP_HIDDEN, EVENT_POPUP_REMOVED, EVENT_POPUP_SHOWN, EVENT_REMOVE_POPUPS, EVENT_SHOW_POPUPS, KEY_ESCAPE, NORTH, POPUP_ARROW_CLASS, POPUP_BODY_CLASS, POPUP_CLASS, PopupController, SOUTH, Spine, WEST, Z_INDEX, Z_INDEX_INCREMENT_STEP, is_east, is_north, is_south, is_west, scalar_to_list, uuid, viewport_bottom, viewport_left, viewport_right, viewport_top,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Spine = require('spine');

  $ = require('jquery');

  uuid = require('CSLib').uuid;

  POPUP_CLASS = 'b-popup';

  POPUP_ARROW_CLASS = 'b-popup__tail';

  CLOSE_BUTTON_CLASS = 'b-popup__close';

  POPUP_BODY_CLASS = 'b-popup__body';

  NORTH = 'N';

  EAST = 'E';

  SOUTH = 'S';

  WEST = 'W';

  DEFAULT_ORIENTATION = SOUTH;

  EVENT_CREATE_POPUP_HELP = 'Popup.create_popup_help';

  EVENT_CREATE_POPUP_HINT = 'Popup.create_popup_hint';

  EVENT_HIDE_POPUPS = 'Popup.hide_popup';

  EVENT_HIDE_ALL_POPUPS = 'Popup.hide_all_popups';

  EVENT_SHOW_POPUPS = 'Popup.show_popup';

  EVENT_REMOVE_POPUPS = 'Popup.remove_popup';

  EVENT_POPUP_CREATED = 'Popup.popup_created';

  EVENT_POPUP_HIDDEN = 'Popup.popup_hidden';

  EVENT_POPUP_SHOWN = 'Popup.popup_shown';

  EVENT_POPUP_REMOVED = 'Popup.popup_removed';

  EVENT_POPUP_CLICKED = 'Popup.popup_clicked';

  ARROW_CLS = 'b-popup__tail';

  CTX_ACTIVE_CLS = 'js-active';

  CSS_ARROW_EAST = "b-popup__tail_orientation_east";

  CSS_ARROW_SOUTH = "b-popup__tail_orientation_south";

  CSS_ARROW_WEST = "b-popup__tail_orientation_west";

  CSS_ARROW_NORTH = "b-popup__tail_orientation_north";

  Z_INDEX = 9999999;

  Z_INDEX_INCREMENT_STEP = 1;

  EVENT = {
    CLICK: 'click',
    MOUSEENTER: 'mouseenter'
  };

  KEY_ESCAPE = 27;

  DATA = {
    TITLE: 'title',
    BODY: 'body',
    DISABLE_SELECTOR: 'disable-selector'
  };

  scalar_to_list = function(s) {
    if ($.isArray(s)) {
      return s;
    } else {
      return [s];
    }
  };

  viewport_top = function() {
    return $(document).scrollTop();
  };

  viewport_right = function() {
    return $(window).width();
  };

  viewport_bottom = function() {
    return $(document).scrollTop() + $(window).height();
  };

  viewport_left = function() {
    return 0;
  };

  is_north = function(orient) {
    return orient === NORTH;
  };

  is_east = function(orient) {
    return orient === EAST;
  };

  is_south = function(orient) {
    return orient === SOUTH;
  };

  is_west = function(orient) {
    return orient === WEST;
  };

  PopupController = (function(superClass) {
    extend(PopupController, superClass);

    function PopupController() {
      this._bind_hide_on_leave_handler = bind(this._bind_hide_on_leave_handler, this);
      this.has_overlaps = bind(this.has_overlaps, this);
      this.hide_all_popups = bind(this.hide_all_popups, this);
      this._event_create_popup_hint = bind(this._event_create_popup_hint, this);
      this._event_create_popup_help = bind(this._event_create_popup_help, this);
      this._event_show_popups = bind(this._event_show_popups, this);
      this._event_hide_popups = bind(this._event_hide_popups, this);
      this._event_remove_popups = bind(this._event_remove_popups, this);
      var _event_create_popup_help, _event_create_popup_hint;
      PopupController.__super__.constructor.apply(this, arguments);
      this.popups = {};
      this.z_index = Z_INDEX;
      Spine.bind(EVENT_REMOVE_POPUPS, this._event_remove_popups);
      Spine.bind(EVENT_HIDE_POPUPS, this._event_hide_popups);
      Spine.bind(EVENT_HIDE_ALL_POPUPS, this.hide_all_popups);
      Spine.bind(EVENT_SHOW_POPUPS, this._event_show_popups);
      Spine.bind(EVENT_CREATE_POPUP_HELP, this._event_create_popup_help);
      Spine.bind(EVENT_CREATE_POPUP_HINT, this._event_create_popup_hint);
      $(document).keyup(function(event) {
        if (event.keyCode === KEY_ESCAPE) {
          Spine.trigger(EVENT_HIDE_ALL_POPUPS);
        }
        return true;
      });
      $(window).scroll(function() {
        Spine.trigger(EVENT_HIDE_ALL_POPUPS);
        return true;
      });
      _event_create_popup_help = (function(_this) {
        return function(ev) {
          var body, content, ctx_el, title;
          ctx_el = $(ev.currentTarget);
          title = ctx_el.data(DATA.TITLE);
          body = ctx_el.data(DATA.BODY);
          content = {
            title: title,
            body: body
          };
          return _this._event_create_popup_help(ctx_el, content);
        };
      })(this);
      _event_create_popup_hint = (function(_this) {
        return function(ev) {
          var body, content, ctx_el, disable_selector, settings, title;
          ctx_el = $(ev.currentTarget);
          title = ctx_el.data(DATA.TITLE);
          body = ctx_el.data(DATA.BODY);
          disable_selector = ctx_el.data(DATA.DISABLE_SELECTOR);
          content = {
            title: title,
            body: body
          };
          settings = {
            disable_selector: disable_selector
          };
          return _this._event_create_popup_hint(ctx_el, content, settings);
        };
      })(this);
      ($(document.body)).delegate(".js-popup-help", EVENT.CLICK, _event_create_popup_help);
      ($(document.body)).delegate(".js-popup-hint", EVENT.MOUSEENTER, _event_create_popup_hint);
    }

    PopupController.prototype._find_popups = function(ids) {
      var i, ref, ref1, results;
      ref = this.popups;
      results = [];
      for (i in ref) {
        if (!hasProp.call(ref, i)) continue;
        if (ref1 = this.popups[i].popup_id, indexOf.call(scalar_to_list(ids), ref1) >= 0) {
          results.push(this.popups[i]);
        }
      }
      return results;
    };

    PopupController.prototype._get_popup_by_id = function(id) {
      return this._find_popups(id).pop();
    };

    PopupController.prototype._get_popup_id_on_click = function(target) {
      var parents;
      parents = target.parents("." + POPUP_CLASS);
      if ((parents.length === 0) && target.hasClass(POPUP_CLASS)) {
        return target.attr('id');
      } else if (parents.hasClass(POPUP_CLASS)) {
        return parents.attr('id');
      } else {
        return null;
      }
    };

    PopupController.prototype._event_remove_popups = function(ids) {
      return this.remove_popups(this._find_popups(ids));
    };

    PopupController.prototype._event_hide_popups = function(ids) {
      var i, j, len, ref, results;
      ref = scalar_to_list(ids);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push(this.hide_popup(i));
      }
      return results;
    };

    PopupController.prototype._event_show_popups = function(ids) {
      var i, j, len, ref, results;
      ref = scalar_to_list(ids);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push(this.show_popup(i));
      }
      return results;
    };

    PopupController.prototype._event_create_popup_help = function(elem, content, settings) {
      var popup_id;
      settings || (settings = {});
      settings.hide_on_leave = false;
      return popup_id = this.popup_help(elem, content, settings);
    };

    PopupController.prototype._event_create_popup_hint = function(elem, content, settings) {
      var popup_id;
      settings || (settings = {});
      settings.hide_on_leave = true;
      return popup_id = this.popup_help(elem, content, settings);
    };

    PopupController.prototype.place_popup_at_default_position = function(popup_id) {
      if (is_north(this._get_default_orient(popup_id))) {
        this.place_popup_at_north(popup_id);
      }
      if (is_east(this._get_default_orient(popup_id))) {
        this.place_popup_at_east(popup_id);
      }
      if (is_south(this._get_default_orient(popup_id))) {
        this.place_popup_at_south(popup_id);
      }
      if (is_west(this._get_default_orient(popup_id))) {
        return this.place_popup_at_west(popup_id);
      }
    };

    PopupController.prototype._get_default_orient = function(popup_id) {
      return this._get_popup_by_id(popup_id).settings.default_orientation;
    };

    PopupController.prototype.rotate_arrow_to_north = function(popup_id) {
      return $("#" + popup_id + " ." + POPUP_ARROW_CLASS).removeClass(CSS_ARROW_EAST).removeClass(CSS_ARROW_SOUTH).removeClass(CSS_ARROW_WEST).addClass(CSS_ARROW_NORTH);
    };

    PopupController.prototype.rotate_arrow_to_east = function(popup_id) {
      return $("#" + popup_id + " ." + POPUP_ARROW_CLASS).removeClass(CSS_ARROW_NORTH).removeClass(CSS_ARROW_SOUTH).removeClass(CSS_ARROW_WEST).addClass(CSS_ARROW_EAST);
    };

    PopupController.prototype.rotate_arrow_to_south = function(popup_id) {
      return $("#" + popup_id + " ." + POPUP_ARROW_CLASS).removeClass(CSS_ARROW_NORTH).removeClass(CSS_ARROW_EAST).removeClass(CSS_ARROW_WEST).addClass(CSS_ARROW_SOUTH);
    };

    PopupController.prototype.rotate_arrow_to_west = function(popup_id) {
      return $("#" + popup_id + " ." + POPUP_ARROW_CLASS).removeClass(CSS_ARROW_NORTH).removeClass(CSS_ARROW_EAST).removeClass(CSS_ARROW_SOUTH).addClass(CSS_ARROW_WEST);
    };

    PopupController.prototype.place_popup_at_north = function(popup_id) {
      this._get_popup_by_id(popup_id).settings.orientation = NORTH;
      return this.rotate_arrow_to_south(popup_id);
    };

    PopupController.prototype.place_popup_at_east = function(popup_id) {
      this._get_popup_by_id(popup_id).settings.orientation = EAST;
      return this.rotate_arrow_to_west(popup_id);
    };

    PopupController.prototype.place_popup_at_south = function(popup_id) {
      this._get_popup_by_id(popup_id).settings.orientation = SOUTH;
      return this.rotate_arrow_to_north(popup_id);
    };

    PopupController.prototype.place_popup_at_west = function(popup_id) {
      this._get_popup_by_id(popup_id).settings.orientation = WEST;
      return this.rotate_arrow_to_east(popup_id);
    };

    PopupController.prototype.is_hint = function(popup_id) {
      return this._get_popup_by_id(popup_id).settings.hide_on_leave;
    };

    PopupController.prototype.is_help = function(popup_id) {
      return !this._get_popup_by_id(popup_id).settings.hide_on_leave;
    };

    PopupController.prototype.remove_popups = function(popups) {
      var j, len, popup, ref, results;
      ref = scalar_to_list(popups);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        popup = ref[j];
        $(popup.wrapper).remove();
        $("#" + popup.popup_id).unbind('mouseenter', popup['_on_popup_mouseenter']).unbind('mouseleave', popup['_on_mouseleave']);
        $("#" + popup.ctx_el_id).unbind('mouseenter', popup['_on_ctx_mouseenter']).unbind('mouseleave', popup['_on_mouseleave']);
        Spine.trigger(EVENT_POPUP_REMOVED, popup.popup_id);
        results.push(delete this.popups[popup.ctx_el_id]);
      }
      return results;
    };

    PopupController.prototype.show_popup = function(popup_id) {
      var _show_popup, ctx_el, disable_selector, popup, target;
      target = $("#" + popup_id);
      popup = this._get_popup_by_id(popup_id);
      ctx_el = $("#" + popup.ctx_el_id);
      disable_selector = popup.settings.disable_selector;
      _show_popup = (function(_this) {
        return function() {
          if (!target.is(":visible")) {
            target.show();
            _this.update_appearance(popup_id);
            return Spine.trigger(EVENT_POPUP_SHOWN, popup_id);
          }
        };
      })(this);
      if (disable_selector !== void 0) {
        if (!($(disable_selector).find(ctx_el).length || $(disable_selector).closest(ctx_el).length)) {
          return _show_popup();
        }
      } else {
        return _show_popup();
      }
    };

    PopupController.prototype.hide_popup = function(popup_id) {
      var target;
      target = $("#" + popup_id);
      if (true || target.is(":visible")) {
        $("#" + popup_id).hide();
        return Spine.trigger(EVENT_POPUP_HIDDEN, popup_id);
      }
    };

    PopupController.prototype.hide_all_popups = function() {
      var i, popup_id, ref, results;
      ref = this.popups;
      results = [];
      for (i in ref) {
        if (!hasProp.call(ref, i)) continue;
        popup_id = this.popups[i].popup_id;
        results.push(this.hide_popup(popup_id));
      }
      return results;
    };

    PopupController.prototype.get_ctx_el_id = function(ctx_el) {
      var id;
      if (ctx_el.attr('id')) {
        return ctx_el.attr('id');
      } else {
        id = uuid();
        ctx_el.attr('id', id);
        return id;
      }
    };

    PopupController.prototype.make_popup_id = function(ctx_el) {
      return 'popup_' + this.get_ctx_el_id(ctx_el);
    };

    PopupController.prototype.format_text = function(content, id, class_) {
      var format_data, ref;
      format_data = content.format_data["#" + id] || content.format_data["." + class_] || [];
      return (ref = content.body).format.apply(ref, format_data);
    };

    PopupController.prototype.render_body = function(popup_id, content, settings) {
      return require('views/popup_hint')({
        content: content,
        popup_id: popup_id
      });
    };

    PopupController.prototype.increment_z_index = function() {
      return this.z_index += Z_INDEX_INCREMENT_STEP;
    };

    PopupController.prototype.update_z_index = function(popup_id) {
      var current_z_index;
      current_z_index = parseInt($("#" + popup_id).css('z-index'), 10);
      if (current_z_index > this.z_index) {
        this.z_index = current_z_index;
      }
      this.increment_z_index();
      return $("#" + popup_id).css('z-index', this.z_index);
    };

    PopupController.prototype.get_visible_popups = function() {
      var i, j, len, ref, results;
      ref = $("." + POPUP_CLASS + ":visible");
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if ((i.id != null) && i.id !== "") {
          results.push(i.id);
        }
      }
      return results;
    };

    PopupController.prototype.has_overlaps = function(popup_id) {
      var arrow_offset, bottom, j, left, len, ref, ref1, ref2, right, top, visible_popup, visible_popup_id, visible_popup_offset;
      arrow_offset = $("#" + popup_id + " ." + POPUP_ARROW_CLASS).offset();
      if (!arrow_offset) {
        return false;
      }
      ref = this.get_visible_popups();
      for (j = 0, len = ref.length; j < len; j++) {
        visible_popup_id = ref[j];
        visible_popup = $("#" + visible_popup_id);
        visible_popup_offset = visible_popup.offset();
        top = visible_popup_offset.top;
        bottom = top + visible_popup.height();
        left = visible_popup_offset.left;
        right = left + visible_popup.width();
        if (((top < (ref1 = arrow_offset.top) && ref1 < bottom)) && ((left < (ref2 = arrow_offset.left) && ref2 < right))) {
          return true;
        }
      }
      return false;
    };

    PopupController.prototype.align_popup_to_ctx_el = function(popup_id) {
      var arrow_el, ctx_el, orientation, popup_el, popup_el_x, popup_el_y, popup_obj;
      popup_obj = this._get_popup_by_id(popup_id);
      popup_el = $("#" + popup_id);
      ctx_el = $("#" + popup_obj.ctx_el_id);
      orientation = popup_obj.settings.orientation;
      popup_el_x = ctx_el.offset().left - popup_obj.settings.offset_x;
      popup_el_y = ctx_el.offset().top - popup_obj.settings.offset_y;
      arrow_el = $("#" + popup_id + " ." + ARROW_CLS);
      switch (orientation) {
        case EAST:
          return popup_el.offset({
            left: popup_el_x + ctx_el.width() + arrow_el.width(),
            top: popup_el_y - popup_el.height() / 2 + ctx_el.height() / 2
          });
        case WEST:
          return popup_el.offset({
            left: popup_el_x - popup_el.width() - arrow_el.width(),
            top: popup_el_y - popup_el.height() / 2 + ctx_el.height() / 2
          });
        case SOUTH:
          return popup_el.offset({
            left: popup_el_x - popup_el.width() / 2 + ctx_el.width() / 2,
            top: popup_el_y + ctx_el.height() + arrow_el.height()
          });
        default:
          return popup_el.offset({
            left: popup_el_x - popup_el.width() / 2 + ctx_el.width() / 2,
            top: popup_el_y - popup_el.height() - arrow_el.height()
          });
      }
    };

    PopupController.prototype.align_arrow = function(popup_id) {
      var arrow_el, arrow_x, arrow_y, gap_x, gap_y, orientation, popup_el, popup_height, popup_obj, popup_width;
      popup_obj = this._get_popup_by_id(popup_id);
      popup_el = $("#" + popup_id);
      orientation = popup_obj.settings.orientation;
      popup_width = popup_el.outerWidth();
      popup_height = popup_el.outerHeight();
      gap_x = popup_el.outerWidth() - popup_el.innerWidth();
      gap_y = popup_el.outerHeight() - popup_el.innerHeight();
      arrow_el = $("#" + popup_id + " ." + ARROW_CLS);
      switch (orientation) {
        case NORTH:
          arrow_y = popup_height - gap_y;
          arrow_x = (popup_width - arrow_el.width()) / 2;
          this.rotate_arrow_to_south(popup_id);
          break;
        case EAST:
          arrow_y = (popup_height - arrow_el.height()) / 2;
          arrow_x = -1 * arrow_el.width();
          this.rotate_arrow_to_west(popup_id);
          break;
        case SOUTH:
          arrow_y = -1 * arrow_el.height();
          arrow_x = (popup_width - arrow_el.width()) / 2;
          this.rotate_arrow_to_north(popup_id);
          break;
        case WEST:
          arrow_y = (popup_height - arrow_el.height()) / 2;
          arrow_x = popup_width - gap_x;
          this.rotate_arrow_to_east(popup_id);
          break;
        default:
          arrow_x = 0;
          arrow_y = 0;
          if (typeof console !== "undefined" && console !== null) {
            console.log("PopupController: no arrow orientation");
          }
      }
      return $("#" + popup_id + " ." + POPUP_ARROW_CLASS).css("left", arrow_x).css("top", arrow_y);
    };

    PopupController.prototype.update_arrow_visibility = function(popup_id) {
      if (this.has_overlaps(popup_id)) {
        return $("#" + popup_id + " ." + POPUP_ARROW_CLASS).css('visibility', 'hidden');
      } else {
        return $("#" + popup_id + " ." + POPUP_ARROW_CLASS).css('visibility', 'visible');
      }
    };

    PopupController.prototype.fits_to_viewport = function(arg, arg1) {
      var X_p_0, X_p_1, X_v_0, X_v_1, Y_p_0, Y_p_1, Y_v_0, Y_v_1;
      X_p_0 = arg[0], Y_p_0 = arg[1];
      X_p_1 = arg1[0], Y_p_1 = arg1[1];

      /*
              X_v_0
        Y_v_0 +------------------------------------+
              |  X_p_0       viewport              |
              |Y_p_0  _____________________        |
              |      |/                   \|       |
              |      |     popup box       |       |
              |      |\________  _________/|       |
              |      |_________\/__________|X_p_1  |
              |                           Y_p_1    |
              +------------------------------------+ X_v_1
                                                 Y_v_1
       */
      X_v_0 = parseInt(viewport_left(), 0);
      Y_v_0 = parseInt(viewport_top(), 0);
      X_v_1 = parseInt(viewport_right(), 0);
      Y_v_1 = parseInt(viewport_bottom(), 0);
      if ((X_v_0 < X_p_0 && X_p_0 < X_v_1) && (Y_v_0 < Y_p_0 && Y_p_0 < Y_v_1) && (X_v_0 < X_p_1 && X_p_1 < X_v_1) && (Y_v_0 < Y_p_1 && Y_p_1 < Y_v_1)) {
        return true;
      } else {
        return false;
      }
    };

    PopupController.prototype._get_placement_requisites = function(popup_id) {
      var ctx_el, popup_el, popup_obj;
      popup_obj = this._get_popup_by_id(popup_id);
      ctx_el = $("#" + popup_obj.ctx_el_id);
      popup_el = $("#" + popup_id);
      return {
        popup_obj: popup_obj,
        ctx_el: ctx_el,
        popup_el: popup_el,
        ctx_el_offset: ctx_el.offset(),
        ctx_el_width: ctx_el.width(),
        ctx_el_height: ctx_el.height(),
        popup_el_width: popup_el.width(),
        popup_el_height: popup_el.height()
      };
    };

    PopupController.prototype.can_place_at_north = function(popup_id) {
      var X_p_0, X_p_1, Y_p_0, Y_p_1, ctx_el, ctx_el_height, ctx_el_offset, ctx_el_width, popup_el, popup_el_height, popup_el_width, popup_obj, ref;
      ref = this._get_placement_requisites(popup_id), popup_obj = ref.popup_obj, ctx_el = ref.ctx_el, popup_el = ref.popup_el, ctx_el_offset = ref.ctx_el_offset, ctx_el_width = ref.ctx_el_width, ctx_el_height = ref.ctx_el_height, popup_el_width = ref.popup_el_width, popup_el_height = ref.popup_el_height;
      X_p_0 = (ctx_el_offset.left + ctx_el_width / 2) - (popup_el_width / 2);
      Y_p_0 = ctx_el_offset.top - popup_el_height;
      X_p_1 = (ctx_el_offset.left + ctx_el_width / 2) + (popup_el_width / 2);
      Y_p_1 = ctx_el_offset.top;
      return this.fits_to_viewport([X_p_0, Y_p_0], [X_p_1, Y_p_1]);
    };

    PopupController.prototype.can_place_at_east = function(popup_id) {
      var X_p_0, X_p_1, Y_p_0, Y_p_1, ctx_el, ctx_el_height, ctx_el_offset, ctx_el_width, popup_el, popup_el_height, popup_el_width, popup_obj, ref;
      ref = this._get_placement_requisites(popup_id), popup_obj = ref.popup_obj, ctx_el = ref.ctx_el, popup_el = ref.popup_el, ctx_el_offset = ref.ctx_el_offset, ctx_el_width = ref.ctx_el_width, ctx_el_height = ref.ctx_el_height, popup_el_width = ref.popup_el_width, popup_el_height = ref.popup_el_height;
      X_p_0 = ctx_el_offset.left + ctx_el_width;
      Y_p_0 = (ctx_el_offset.top + ctx_el_height / 2) - (popup_el_height / 2);
      X_p_1 = (ctx_el_offset.left + ctx_el_width) + popup_el_width;
      Y_p_1 = (ctx_el_offset.top + ctx_el_height / 2) + (popup_el_height / 2);
      return this.fits_to_viewport([X_p_0, Y_p_0], [X_p_1, Y_p_1]);
    };

    PopupController.prototype.can_place_at_south = function(popup_id) {
      var X_p_0, X_p_1, Y_p_0, Y_p_1, ctx_el, ctx_el_height, ctx_el_offset, ctx_el_width, popup_el, popup_el_height, popup_el_width, popup_obj, ref;
      ref = this._get_placement_requisites(popup_id), popup_obj = ref.popup_obj, ctx_el = ref.ctx_el, popup_el = ref.popup_el, ctx_el_offset = ref.ctx_el_offset, ctx_el_width = ref.ctx_el_width, ctx_el_height = ref.ctx_el_height, popup_el_width = ref.popup_el_width, popup_el_height = ref.popup_el_height;
      X_p_0 = (ctx_el_offset.left + ctx_el_width / 2) - (popup_el_width / 2);
      Y_p_0 = ctx_el_offset.top + ctx_el_height;
      X_p_1 = (ctx_el_offset.left + ctx_el_width / 2) + (popup_el_width / 2);
      Y_p_1 = ctx_el_offset.top + ctx_el_height + popup_el_height;
      return this.fits_to_viewport([X_p_0, Y_p_0], [X_p_1, Y_p_1]);
    };

    PopupController.prototype.can_place_at_west = function(popup_id) {
      var X_p_0, X_p_1, Y_p_0, Y_p_1, ctx_el, ctx_el_height, ctx_el_offset, ctx_el_width, popup_el, popup_el_height, popup_el_width, popup_obj, ref;
      ref = this._get_placement_requisites(popup_id), popup_obj = ref.popup_obj, ctx_el = ref.ctx_el, popup_el = ref.popup_el, ctx_el_offset = ref.ctx_el_offset, ctx_el_width = ref.ctx_el_width, ctx_el_height = ref.ctx_el_height, popup_el_width = ref.popup_el_width, popup_el_height = ref.popup_el_height;
      X_p_0 = ctx_el_offset.left - popup_el_width;
      Y_p_0 = (ctx_el_offset.top + ctx_el_height / 2) - (popup_el_height / 2);
      X_p_1 = ctx_el_offset.left;
      Y_p_1 = (ctx_el_offset.top + ctx_el_height / 2) + (popup_el_height / 2);
      return this.fits_to_viewport([X_p_0, Y_p_0], [X_p_1, Y_p_1]);
    };

    PopupController.prototype.can_place_at_default_pos = function(popup_id) {
      var default_orientation;
      default_orientation = this._get_default_orient(popup_id);
      if (is_north(default_orientation) && this.can_place_at_north(popup_id)) {
        return true;
      } else if (is_east(default_orientation) && this.can_place_at_east(popup_id)) {
        return true;
      } else if (is_south(default_orientation) && this.can_place_at_south(popup_id)) {
        return true;
      } else if (is_west(default_orientation) && this.can_place_at_west(popup_id)) {
        return true;
      } else {
        return false;
      }
    };

    PopupController.prototype.place_popup_on_free_space = function(popup_id) {
      if (this.can_place_at_north(popup_id)) {
        return this.place_popup_at_north(popup_id);
      } else if (this.can_place_at_east(popup_id)) {
        return this.place_popup_at_east(popup_id);
      } else if (this.can_place_at_south(popup_id)) {
        return this.place_popup_at_south(popup_id);
      } else if (this.can_place_at_west(popup_id)) {
        return this.place_popup_at_west(popup_id);
      }
    };

    PopupController.prototype.update_orientation = function(popup_id) {
      if (this.can_place_at_default_pos(popup_id)) {
        this.place_popup_at_default_position(popup_id);
        this.align_popup_to_ctx_el(popup_id);
      } else {
        this.place_popup_on_free_space(popup_id);
        this.align_popup_to_ctx_el(popup_id);
      }
      return this.align_arrow(popup_id);
    };

    PopupController.prototype.update_appearance = function(popup_id) {
      this.align_popup_to_ctx_el(popup_id);
      this.update_orientation(popup_id);
      return this.update_z_index(popup_id);
    };

    PopupController.prototype.recalc_width = function(popup_id, settings) {
      var content_width, full_width, outer_space, popup, settings_width, width;
      popup = $("#" + popup_id);
      content_width = popup.find('.' + settings.recalc_width_sel).width();
      width = popup.find("." + POPUP_BODY_CLASS).width();
      full_width = popup.width();
      outer_space = full_width - width;
      if (content_width < width) {
        settings_width = content_width + outer_space;
        return popup.css('min-width', settings_width);
      }
    };

    PopupController.prototype._bind_hide_on_leave_handler = function(ctx_el, popup_id) {
      var _on_ctx_mouseenter, _on_ctx_mouseleave, _on_popup_mouseenter, _on_popup_mouseleave, popup, popup_obj, timer_id;
      timer_id = null;
      popup = $("#" + popup_id);
      popup_obj = this._get_popup_by_id(popup_id);
      popup_obj['_on_ctx_mouseenter'] = _on_ctx_mouseenter = (function(_this) {
        return function() {
          clearTimeout(timer_id);
          return _this.show_popup(popup_id);
        };
      })(this);
      popup_obj['_on_mouseleave'] = _on_ctx_mouseleave = _on_popup_mouseleave = (function(_this) {
        return function() {
          return timer_id = setTimeout(function() {
            return _this.hide_popup(popup_id);
          }, 75);
        };
      })(this);
      popup_obj['_on_popup_mouseenter'] = _on_popup_mouseenter = (function(_this) {
        return function() {
          return clearTimeout(timer_id);
        };
      })(this);
      ctx_el.mouseleave(_on_ctx_mouseleave);
      ctx_el.mouseenter(_on_ctx_mouseenter);
      popup.mouseenter(_on_popup_mouseenter);
      return popup.mouseleave(_on_popup_mouseleave);
    };

    PopupController.prototype.popup_help = function(elem, content, settings) {
      var _cb, _create_popup, ctx_el, ctx_el_id, popup, popup_id, ref;
      ctx_el = $(elem);
      ctx_el_id = this.get_ctx_el_id(ctx_el);
      settings = $.extend({
        offset_x: 0,
        offset_y: 0,
        z_index: ctx_el.zIndex(),
        hide_on_leave: false,
        disable_selector: void 0,
        fixed: false,
        css_class: null,
        css_id: null,
        update_body: false,
        orientation: DEFAULT_ORIENTATION,
        ctx_sel: null
      }, settings);
      if (settings.update_body && this.popups[ctx_el_id]) {
        this.remove_popups(this.popups[ctx_el_id]);
        popup_id = null;
      }
      popup_id = (ref = this.popups[ctx_el_id]) != null ? ref.popup_id : void 0;
      if (popup_id) {
        popup = $("#" + popup_id);
        this.show_popup(popup_id);
      } else {
        if (content.title || content.body) {
          popup_id = this.make_popup_id(ctx_el);
          _create_popup = (function(_this) {
            return function(content) {
              var container, wrapper;
              if (content.format_data) {
                content.body = _this.format_text(content, ctx_el_id, ctx_el.attr('class'));
              }
              wrapper = document.createElement('div');
              _this.popups[ctx_el_id] = {
                popup_id: popup_id,
                settings: settings,
                content: content,
                wrapper: wrapper,
                ctx_el_id: ctx_el_id
              };
              $(wrapper).html(_this.render_body(popup_id, content, settings));
              container = settings.ctx_sel || document.body;
              container = $(container);
              container.append(wrapper);
              popup = $("#" + popup_id);
              if (settings.hide_on_leave) {
                _this._bind_hide_on_leave_handler(ctx_el, popup_id);
              } else {
                $(document.body).click(function(event) {
                  var clicked_id, i, j, len, ref1, target;
                  target = $(event.target);
                  clicked_id = _this._get_popup_id_on_click(target);
                  if (clicked_id !== popup_id) {
                    if ((ctx_el.has(target)).length < 1 && !ctx_el.is(target)) {
                      _this.hide_popup(popup_id);
                      ref1 = _this.get_visible_popups();
                      for (j = 0, len = ref1.length; j < len; j++) {
                        i = ref1[j];
                        _this.update_arrow_visibility(i);
                      }
                    }
                  }
                  return true;
                });
              }
              if (settings.css_class) {
                popup.addClass(settings.css_class);
              }
              if (settings.fixed) {
                popup.css('position', 'fixed');
              }
              if (settings.z_index) {
                popup.css('z-index', settings.z_index);
              }
              if (settings.width) {
                popup.css('min-width', settings.width);
              }
              if (settings.recalc_width_sel) {
                _this.recalc_width(popup_id, settings);
              }
              settings.default_orientation = settings.orientation;
              _this.update_appearance(popup_id);
              if (typeof settings.callback === "function") {
                settings.callback(popup_id);
              }
              return Spine.trigger(EVENT_POPUP_CREATED, popup_id);
            };
          })(this);
          if ($.isFunction(content.body)) {
            _cb = function(body) {
              return _create_popup({
                title: '',
                body: body
              });
            };
            content.body(_cb);
          } else {
            _create_popup(content);
          }
        } else {
          if (typeof console !== "undefined" && console !== null) {
            console.log("PopupController: no title nor body");
          }
        }
      }
      return popup_id;
    };

    return PopupController;

  })(Spine.Controller);

  module.exports = PopupController;

}).call(this);

}).call(this);},

/*ZB:  Popup/index */
'index': function(exports, require, module) {(function() {
(function() {
  var Popup, PopupController, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  PopupController = require('controllers/PopupController');

  Popup = (function(superClass) {
    extend(Popup, superClass);

    function Popup() {
      Popup.__super__.constructor.apply(this, arguments);
      this.popup_controller = new PopupController;
    }

    return Popup;

  })(Spine.Controller);

  module.exports = Popup;

}).call(this);

}).call(this);},

/*ZB:  Popup/views/popup_help */
'views/popup_help': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      __out.push('<div id="');
    
      __out.push(__sanitize(this.popup_id));
    
      __out.push('" class="b-popup b-popup_type_hint-with-closer" name="popup">\n    <div class="b-popup__tail"></div>\n    <div class="b-popup__close">&#215;</div>\n    ');
    
      if (this.content.title) {
        __out.push('\n        <h4 class="b-popup__header">\n            ');
        __out.push(this.content.title);
        __out.push('\n        </h4>\n    ');
      }
    
      __out.push('\n    <div class="b-popup__body">\n        ');
    
      __out.push(this.content.body);
    
      __out.push('\n    </div>\n</div>\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);},

/*ZB:  Popup/views/popup_hint */
'views/popup_hint': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      __out.push('<div id="');
    
      __out.push(__sanitize(this.popup_id));
    
      __out.push('" class="b-popup" name="popup">\n    <div class="b-popup__tail"></div>\n    ');
    
      if (this.content.title) {
        __out.push('\n        <h4 class="b-popup__header">\n            ');
        __out.push(this.content.title);
        __out.push('\n        </h4>\n    ');
      }
    
      __out.push('\n    <div class="b-popup__body">\n        ');
    
      __out.push(this.content.body);
    
      __out.push('\n    </div>\n</div>\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);}
});


/*ZB: Header */
require.define('Header', {

/*ZB:  Header/index */
'index': function(exports, require, module) {(function() {
(function() {
  var $, CSLib, Header;

  $ = require('jquery');

  CSLib = require('CSLib');

  Header = (function() {
    function Header(header_el, footer_el, url) {
      this.header_el = header_el;
      this.footer_el = footer_el;
      this.url = url;
      this.get_header();
    }

    Header.prototype.get_header = function() {
      return CSLib.AUTOIO.GET(this.url, (function(_this) {
        return function(data) {
          console.log('data reieved', data);
          $(_this.header_el).html(_this.sanitize(data.header));
          return $(_this.footer_el).html(_this.sanitize(data.footer));
        };
      })(this));
    };

    Header.prototype.sanitize = function(data) {
      return data.replace('None', '');
    };

    return Header;

  })();

  module.exports = Header;

}).call(this);

}).call(this);}
});


/*ZB: UserProfile */
require.define('UserProfile', {

/*ZB:  UserProfile/index */
'index': function(exports, require, module) {(function() {
(function() {
  var $, CSLib, Spine, UserProfile,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = require('jquery');

  CSLib = require('CSLib');

  UserProfile = (function(superClass) {
    extend(UserProfile, superClass);

    function UserProfile(el) {
      this.el = el;
      UserProfile.__super__.constructor.apply(this, arguments);
      this._get_user_info(this.el.data());
    }

    UserProfile.prototype.draw_user_profile = function(user) {
      return this.el.prepend(require("views/user_profile_view")({
        user: user
      }));
    };

    UserProfile.prototype._get_user_info = function(arg) {
      var user_id, users_public_info_url;
      users_public_info_url = arg.users_public_info_url, user_id = arg.user_id;
      return CSLib.AUTOIO.GET(users_public_info_url + "/?id=" + user_id, (function(_this) {
        return function(data) {
          return _this.draw_user_profile(data);
        };
      })(this));
    };

    return UserProfile;

  })(Spine.Controller);

  module.exports = UserProfile;

}).call(this);

}).call(this);},

/*ZB:  UserProfile/views/user_profile_view */
'views/user_profile_view': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      __out.push('<div class="b-teachers-info__cite">\n    <img class="b-teachers-info__cite-image" src="');
    
      __out.push(__sanitize(this.user.photo));
    
      __out.push('" alt="avatar"/>\n    <div class="b-teachers-info__name">\n        ');
    
      __out.push(__sanitize(this.user.name));
    
      __out.push('\n    </div>\n    <div class="b-teachers-info__position">\n        ');
    
      __out.push(__sanitize(this.user.job_title));
    
      __out.push('\n    </div>\n</div>\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);}
});


/*ZB: MainSuggest */
require.define('MainSuggest', {

/*ZB:  MainSuggest/index */
'index': function(exports, require, module) {(function() {
(function() {
  var $, Autocomplete, ITEM_STATUS, MainSuggest, PopupExtend, popup_params,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  $ = require('jquery');

  Autocomplete = require('PAutocomplete');

  PopupExtend = require('CSLib/lib/popup_extend');

  popup_params = {
    z_index: 10000002,
    orientation: "N",
    is_popup_hint: false
  };

  ITEM_STATUS = {
    live: 0,
    dead: 1
  };

  MainSuggest = (function(superClass) {
    extend(MainSuggest, superClass);

    function MainSuggest(autocomplete_options, main_suggest_options, warning_selector) {
      var build_suggest_params, dropdown_predicate, selected_item_handler, val;
      this.warning_selector = warning_selector;
      this._hide_warning = bind(this._hide_warning, this);
      this._show_warning = bind(this._show_warning, this);
      MainSuggest.__super__.constructor.apply(this, arguments);
      dropdown_predicate = function(items) {
        var key, val;
        for (key in items) {
          val = items[key];
          if (val.length) {
            return true;
          }
        }
        return false;
      };
      selected_item_handler = (function(_this) {
        return function(data) {
          var val;
          if (data) {
            if (!data.ask_question) {
              return location.href = data.url;
            } else {
              return location.href = main_suggest_options.search_form_url;
            }
          } else {
            val = $(_this.input).val();
            if (val.length) {
              return _this.search_navigate(main_suggest_options.search_url, val);
            } else {
              return _this._show_warning();
            }
          }
        };
      })(this);
      build_suggest_params = (function(_this) {
        return function() {
          var term;
          term = $(_this.input).val();
          return {
            filters: JSON.stringify({
              status: ITEM_STATUS.live,
              visible: true
            }),
            match: JSON.stringify({
              title: term
            })
          };
        };
      })(this);
      autocomplete_options.dropdown_predicate = dropdown_predicate;
      autocomplete_options.selected_item_handler = selected_item_handler;
      autocomplete_options.build_suggest_params_handler = build_suggest_params;
      this.autocomplete = new Autocomplete(autocomplete_options);
      this.input = autocomplete_options.input_selector;
      this.input_container = autocomplete_options.input_container;
      this._init_main_suggest(main_suggest_options);
      val = $(this.input).val();
      $(this.input).focus().val('').val(val);
      $(this.input).keydown((function(_this) {
        return function(ev) {
          if ($(_this.input).val().length) {
            _this._hide_warning();
          }
          return true;
        };
      })(this));
    }

    MainSuggest.prototype._init_main_suggest = function(arg) {
      var search_btn_s, search_url;
      search_btn_s = arg.search_btn_s, search_url = arg.search_url;
      return $(search_btn_s).click((function(_this) {
        return function(ev) {
          var val;
          ev.preventDefault();
          val = $(_this.input).val();
          if (val.length) {
            return _this.search_navigate(search_url, val);
          } else {
            return _this._show_warning();
          }
        };
      })(this));
    };

    MainSuggest.prototype.search_navigate = function(search_url, val) {
      return location.href = search_url + "?term=" + val;
    };

    MainSuggest.prototype._show_warning = function() {
      return $(this.warning_selector).removeClass("h-hidden");
    };

    MainSuggest.prototype._hide_warning = function() {
      return $(this.warning_selector).addClass("h-hidden");
    };

    return MainSuggest;

  })(Spine.Controller);

  module.exports = MainSuggest;

}).call(this);

}).call(this);},

/*ZB:  MainSuggest/views/support_autocomplete */
'views/support_autocomplete': function(exports, require, module) {(function() {
module.exports = function(__obj) {
  if (!__obj) __obj = {};
  var __out = [], __capture = function(callback) {
    var out = __out, result;
    __out = [];
    callback.call(this);
    result = __out.join('');
    __out = out;
    return __safe(result);
  }, __sanitize = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else if (typeof value !== 'undefined' && value != null) {
      return __escape(value);
    } else {
      return '';
    }
  }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
  __safe = __obj.safe = function(value) {
    if (value && value.ecoSafe) {
      return value;
    } else {
      if (!(typeof value !== 'undefined' && value != null)) value = '';
      var result = new String(value);
      result.ecoSafe = true;
      return result;
    }
  };
  if (!__escape) {
    __escape = __obj.escape = function(value) {
      return ('' + value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
  }
  (function() {
    (function() {
      var i, item, j, len, len1, ref, ref1;
    
      __out.push('<ul id="search_autocomplete" class="b-autocomplete search_autocomplete">\n    ');
    
      if (this.items) {
        __out.push('\n        ');
        if (this.items[0].length) {
          __out.push('\n            <li class="b-autocomplete__wrapper">\n                <span class="b-autocomplete__title">\n                    <i class="icon-answers-to-questions\n                    h-vertical-middle h-layout-margin-right-5"></i>Вопросы\n                </span>\n                <ul class="b-autocomplete__suggest-list">\n                    ');
          ref = this.items[0];
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            __out.push('\n                        <li class="b-autocomplete__item">\n                            <a \n                                data-id="');
            __out.push(__sanitize(item['id']));
            __out.push('"\n                                data-url="');
            __out.push(__sanitize(item['public_link']));
            __out.push('"\n                                class="b-autocomplete__link js_item">\n\n                                ');
            __out.push(__sanitize(item['title']));
            __out.push('\n                            </a>\n                        </li>\n                    ');
          }
          __out.push('\n                </ul>\n            </li>\n        ');
        }
        __out.push('\n        ');
        if (this.items.length > 1) {
          __out.push('\n            ');
          if (this.items[1].length) {
            __out.push('\n                <li class="b-autocomplete__wrapper">\n                    <span class="b-autocomplete__title">\n                        <i class="icon-documentation\n                        h-vertical-middle h-layout-margin-right-5"></i>Документы\n                    </span>\n                    <ul class="b-autocomplete__suggest-list">\n                        ');
            ref1 = this.items[1];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              item = ref1[j];
              __out.push('\n                            <li class="b-autocomplete__item">\n                                <a \n                                    data-id="');
              __out.push(__sanitize(item['id']));
              __out.push('"\n                                    data-url="');
              __out.push(__sanitize(item['public_link']));
              __out.push('"\n                                    class="b-autocomplete__link js_item">\n\n                                    ');
              __out.push(__sanitize(item['title']));
              __out.push('\n                                </a>\n                            </li>\n                        ');
            }
            __out.push('\n                    </ul>\n                </li>\n            ');
          }
          __out.push('\n        ');
        }
        __out.push('\n    ');
      }
    
      __out.push('\n    <li class="b-autocomplete__item">\n        <a class="b-autocomplete__action-link js_item" data-ask_question="true">\n            Задать вопрос\n        </a>\n    </li>\n</ul>\n\n');
    
    }).call(this);
    
  }).call(__obj);
  __obj.safe = __objSafe, __obj.escape = __escape;
  return __out.join('');
}
}).call(this);}
});


/*ZB: WormholeServer */
require.define('WormholeServer', {

/*ZB:  WormholeServer/index */
'index': function(exports, require, module) {(function() {
(function() {
  var STATUS_SERVER_READY, WormholeServer, _postMessage, _receiveMessage, debug, error, get_config, get_cookie, info, ref, ref1, services, warn,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('lib/PostMessage'), _postMessage = ref[0], _receiveMessage = ref[1];

  STATUS_SERVER_READY = require('lib/defs').STATUS_SERVER_READY;

  get_config = require('config').get_config;

  get_cookie = require('./lib/cookie').get_cookie;

  ref1 = (require('console-logger')).ns('WormholeServer'), info = ref1.info, warn = ref1.warn, error = ref1.error, debug = ref1.debug;

  services = require('./services');

  WormholeServer = (function() {
    function WormholeServer(CLIENT_URLS1, CLIENT_WINDOW1) {
      var CLIENT_ORIGINS, CLIENT_URLS, CLIENT_WINDOW;
      this.CLIENT_URLS = CLIENT_URLS1;
      this.CLIENT_WINDOW = CLIENT_WINDOW1 != null ? CLIENT_WINDOW1 : parent;
      this.CLIENT_ORIGINS = this.CLIENT_URLS.map(function(i) {
        return i.split('/').slice(0, 3).join('/');
      });
      CLIENT_ORIGINS = this.CLIENT_ORIGINS;
      CLIENT_URLS = this.CLIENT_URLS;
      CLIENT_WINDOW = this.CLIENT_WINDOW;
      _receiveMessage(function(event) {
        var e, payload;
        payload = (function() {
          try {
            return JSON.parse(event.data);
          } catch (_error) {
            e = _error;
            error("Unexpected data from [Wormhole Client] '" + event.data, event);
            return null;
          }
        })();
        if (payload != null ? payload._type : void 0) {
          if (services[payload._type]) {
            return services[payload._type](payload, function(r) {
              return _postMessage(r, CLIENT_URLS, CLIENT_WINDOW);
            });
          } else {
            return error("Message with unknown type received: '" + payload._type + "'", payload);
          }
        }
      }, function(e_origin) {
        return indexOf.call(CLIENT_ORIGINS, e_origin) >= 0;
      });
      _postMessage({
        _status: STATUS_SERVER_READY,
        _cfg: {
          user: get_config('CS.USER'),
          shopping_cart_cookie: get_cookie('shopping-cart')
        }
      }, CLIENT_URLS, CLIENT_WINDOW);
    }

    return WormholeServer;

  })();

  module.exports = {
    Server: WormholeServer
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/lib/ajax */
'lib/ajax': function(exports, require, module) {(function() {
(function() {
  var ACCEPT_HEADER, CSRF_TOKEN_COOKIE, CSRF_TOKEN_HEADER, FORM_ENCODED, JSON_ENCODED, PROMUSER_HEADER, REQUESTED_WITH_HEADER, ajax, bind, bool, debug, error, get_config, get_cookie, get_xhr, info, is_array, is_object, is_string, ref, ref1, transform_from_request_data, transform_to_request_data, urlencode_dict, warn,
    hasProp = {}.hasOwnProperty;

  get_cookie = require('./lib/cookie').get_cookie;

  get_config = require('config').get_config;

  ref = (require('console-logger')).ns('WormholeServerAjax'), info = ref.info, warn = ref.warn, error = ref.error, debug = ref.debug;

  ref1 = require('libprotein'), bool = ref1.bool, is_object = ref1.is_object, is_string = ref1.is_string, is_array = ref1.is_array;

  bind = function(xhr, f) {
    var e;
    try {
      return xhr.addEventListener(READYSTATECHANGE_EVENT_NAME, f);
    } catch (_error) {
      e = _error;
      return xhr.onreadystatechange = f;
    }
  };

  get_xhr = function() {
    var e;
    try {
      return new XMLHttpRequest;
    } catch (_error) {
      e = _error;
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP.6.0");
    } catch (_error) {
      e = _error;
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP.3.0");
    } catch (_error) {
      e = _error;
    }
    try {
      return new ActiveXObject("Microsoft.XMLHTTP");
    } catch (_error) {
      e = _error;
    }
    throw new Error("This browser does not support XMLHttpRequest.");
  };

  CSRF_TOKEN_HEADER = 'X-CSRFToken';

  CSRF_TOKEN_COOKIE = 'csrf_token';

  PROMUSER_HEADER = 'X-PromUserID';

  ACCEPT_HEADER = 'application/json, text/javascript, */*; q=0.01';

  REQUESTED_WITH_HEADER = 'XMLHttpRequest';

  FORM_ENCODED = 'application/x-www-form-urlencoded';

  JSON_ENCODED = 'application/json';

  transform_to_request_data = function(mtype, data) {
    var data_map, i, k, len, mlower, name, ref2, v, value;
    mlower = mtype.toLowerCase();
    if ((mlower.indexOf(FORM_ENCODED)) > -1) {
      if (is_object(data)) {
        data_map = {};
        for (k in data) {
          if (!hasProp.call(data, k)) continue;
          v = data[k];
          data_map[k] = v;
        }
        return urlencode_dict(data_map);
      } else if (is_array(data)) {
        data_map = {};
        for (i = 0, len = data.length; i < len; i++) {
          ref2 = data[i], name = ref2.name, value = ref2.value;
          data_map[name] = value;
        }
        return urlencode_dict(data_map);
      } else if (is_string(data)) {
        return data;
      } else {
        error("POST data has uknown type", data);
        throw "POST data has uknown type" + data;
      }
    } else if ((mlower.indexOf(JSON_ENCODED)) > -1) {
      return data;
    } else {
      warn("Unknown mimetipe: ", mtype);
      return data;
    }
  };

  transform_from_request_data = function(type, data) {
    switch (type) {
      case 'json':
        return JSON.parse(data);
      case 'jsonp':
        throw "No jsonp here";
        break;
      case 'html':
      case 'xml':
        return data;
      case 'text':
        return data;
      case 'script':
        return data;
      default:
        return data;
    }
  };

  urlencode_dict = function(d) {
    var k, v;
    return ((function() {
      var results;
      results = [];
      for (k in d) {
        v = d[k];
        results.push((encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
      }
      return results;
    })()).join('&');
  };

  ajax = function(url, payload) {
    var encoded_data, full_url, xhr;
    xhr = get_xhr();
    bind(xhr, function() {
      var pseudo_xhr;
      if (xhr.readyState === 4) {
        if (xhr.status === 200 || xhr.status === 304) {
          return typeof payload.success === "function" ? payload.success(transform_from_request_data(payload.dataType, xhr.responseText), xhr.status, xhr) : void 0;
        } else {
          pseudo_xhr = {
            responseText: xhr.responseText,
            readyState: xhr.readyState,
            status: xhr.status,
            statusText: xhr.statusText
          };
          return typeof payload.error === "function" ? payload.error(pseudo_xhr, xhr.status, xhr.statusText) : void 0;
        }
      }
    });
    full_url = (payload.type.toUpperCase() === 'GET') && (bool(payload.data)) ? (url.indexOf('?')) > -1 ? url + '&' + (urlencode_dict(payload.data)) : url + '?' + (urlencode_dict(payload.data)) : url;
    xhr.open(payload.type, full_url, payload.async);
    xhr.setRequestHeader('Content-Type', payload.contentType);
    xhr.setRequestHeader('Accept', ACCEPT_HEADER);
    xhr.setRequestHeader('X-Requested-With', REQUESTED_WITH_HEADER);
    xhr.setRequestHeader(CSRF_TOKEN_HEADER, get_cookie(CSRF_TOKEN_COOKIE));
    if (get_config('CS.USER.id')) {
      xhr.setRequestHeader(PROMUSER_HEADER, get_config('CS.USER.id'));
    }
    encoded_data = transform_to_request_data(payload.contentType, payload.data);
    return xhr.send(encoded_data);
  };

  module.exports = {
    ajax: ajax
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/lib/cookie */
'lib/cookie': function(exports, require, module) {(function() {
(function() {
  var RE1, RE2, get_cookie, get_cookies, trimLeft, trimRight;

  trimLeft = function(s) {
    return s.replace(/^\s+/, "");
  };

  trimRight = function(s) {
    return s.replace(/\s+$/, "");
  };

  RE1 = /^\s*\$Version=(?:"1"|1);\s*(.*)/;

  RE2 = /(?:^|\s+)([!#$%&'*+\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\-.0-9A-Z^`a-z|~]*|"(?:[\x20-\x7E\x80\xFF]|\\[\x00-\x7F])*")(?=\s*[,;]|$)/g;

  get_cookies = function() {
    var c, cookies, v;
    c = document.cookie;
    v = 0;
    cookies = {};
    if (document.cookie.match(RE1)) {
      c = RegExp.$1;
      v = 1;
    }
    if (v === 0) {
      c.split(/[,;]/).map(function(cookie) {
        var name, parts;
        parts = cookie.split('=', 2);
        name = decodeURIComponent(trimLeft(parts[0]));
        return cookies[name] = parts.length > 1 ? decodeURIComponent(trimRight(parts[1])) : null;
      });
    } else {
      c.match(RE2).map(function(name, maybe_value) {
        return cookies[name] = maybe_value.charAt(0) === '"' ? maybe_value.substr(1, -1).replace(/\\(.)/g, "$1") : maybe_value;
      });
    }
    return cookies;
  };

  get_cookie = function(name) {
    return get_cookies()[name];
  };

  module.exports = {
    get_cookie: get_cookie
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/services/index */
'services/index': function(exports, require, module) {(function() {
(function() {
  module.exports = {
    io: require('./services/io'),
    storage: require('./services/storage')
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/services/io */
'services/io': function(exports, require, module) {(function() {
(function() {
  var DEFAULT_CONTENT_TYPE, SENT_CONTENT_TYPE, ajax, relative_url;

  ajax = require('../lib/ajax').ajax;

  relative_url = require('lib/util').relative_url;

  DEFAULT_CONTENT_TYPE = 'json';

  SENT_CONTENT_TYPE = 'application/json; charset=utf-8';

  module.exports = function(payload, cont) {
    payload.options || (payload.options = {});
    return ajax(relative_url(payload.url), {
      type: payload.method,
      dataType: payload.options.dataType || DEFAULT_CONTENT_TYPE,
      contentType: payload.options.contentType || SENT_CONTENT_TYPE,
      data: payload.data,
      async: payload.options.async === false ? false : true,
      success: function(ret, status, xhr) {
        ret = {
          transaction_id: payload.transaction_id,
          xhr: xhr,
          status: status,
          data: ret,
          _type: payload._type
        };
        return cont(ret);
      },
      error: function(xhr, status, error) {
        var ret;
        ret = {
          transaction_id: payload.transaction_id,
          xhr: xhr,
          status: status,
          error: error,
          _type: payload._type
        };
        return cont(ret);
      }
    });
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/services/storage */
'services/storage': function(exports, require, module) {(function() {
(function() {
  module.exports = function(payload, cont) {
    var data, key, method, ns, result, store, value;
    ns = payload.ns, key = payload.key, method = payload.method, value = payload.value;
    store = new Store(ns);
    data = (function() {
      switch (method) {
        case 'get':
          return store.get(key);
        case 'set':
          return store.set(key, value);
        case 'remove':
          return store.remove(key);
        default:
          error('Illegal operations for LocalStorage', payload);
          return void 0;
      }
    })();
    result = {
      transaction_id: payload.transaction_id,
      data: data,
      error: null,
      status: 'ok',
      _type: payload._type
    };
    return cont(result);
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/lib/PostMessage */
'lib/PostMessage': function(exports, require, module) {(function() {
(function() {
  var ADD_EVENT_LISTENER, ATTACH_EVENT, DETACH_EVENT, HAS_POST_MESSAGE, POST_MESSAGE, REMOVE_EVENT_LISTENER, ROOT_OBJECT, cache_bust, is_function, last_hash, p_receiveMessage, postMessage;

  is_function = require('libprotein').is_function;

  ADD_EVENT_LISTENER = 'addEventListener';

  REMOVE_EVENT_LISTENER = 'removeEventListener';

  ATTACH_EVENT = 'attachEvent';

  DETACH_EVENT = 'detachEvent';

  POST_MESSAGE = 'postMessage';

  ROOT_OBJECT = window;

  HAS_POST_MESSAGE = !!ROOT_OBJECT[POST_MESSAGE];

  cache_bust = 1;

  last_hash = '';

  postMessage = function(message, target_urls, target) {
    var target_url;
    target_url = Array.isArray(target_urls) ? target_urls[0] : target_urls;
    if (target_url && target) {
      message = typeof message === 'string' ? message : JSON.stringify(message);
      if (HAS_POST_MESSAGE) {
        target[POST_MESSAGE](message, target_url.replace(/([^:]+:\/\/[^\/]+).*/, '$1'));
      } else if (target_url) {
        target.location = target_url.replace(/#.*$/, '') + '#' + (+(new Date)) + (cache_bust++) + '&' + message;
      }
      return true;
    } else {
      return false;
    }
  };

  p_receiveMessage = function(callback, source_origin, delay) {
    var interval_id, rm_callback;
    if (typeof source_origin === 'string' && source_origin.substr(source_origin.length - 1) === '/') {
      source_origin = source_origin.substr(0, source_origin.length - 1);
    }
    if (HAS_POST_MESSAGE) {
      if (callback) {
        (typeof rm_callback !== "undefined" && rm_callback !== null) && p_receiveMessage();
        rm_callback = function(e) {
          if ((typeof source_origin === 'string' && e.origin === source_origin) || (is_function(source_origin) && source_origin(e.origin) === true)) {
            return callback(e);
          }
        };
      }
      if (ROOT_OBJECT[ADD_EVENT_LISTENER]) {
        return ROOT_OBJECT[callback ? ADD_EVENT_LISTENER : REMOVE_EVENT_LISTENER]('message', rm_callback, false);
      } else {
        return ROOT_OBJECT[callback ? ATTACH_EVENT : DETACH_EVENT]('onmessage', rm_callback);
      }
    } else {
      (typeof interval_id !== "undefined" && interval_id !== null) && clearInterval(interval_id);
      interval_id = null;
      if (callback) {
        delay = typeof source_origin === 'number' ? source_origin : typeof delay === 'number' ? delay : 100;
      }
      return interval_id = setInterval(function() {
        var hash, re;
        hash = document.location.hash;
        re = /^#?\d+&/;
        if (hash !== last_hash && re.test(hash)) {
          last_hash = hash;
          return callback({
            data: hash.replace(re, '')
          });
        }
      }, delay);
    }
  };

  module.exports = [postMessage, p_receiveMessage];

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/lib/defs */
'lib/defs': function(exports, require, module) {(function() {
(function() {
  module.exports = {
    STATUS_SERVER_READY: 'wormhole_server_ready'
  };

}).call(this);

}).call(this);},

/*ZB:  WormholeServer/lib/util */
'lib/util': function(exports, require, module) {(function() {
(function() {
  var has_hostname, relative_url, uuid;

  relative_url = function(url) {
    var a;
    a = document.createElement('a');
    a.href = url;
    return a.pathname + a.search;
  };

  has_hostname = function(url) {
    return (url != null) && (url.match(/https?:\/\//) != null);
  };

  uuid = function() {
    var i, itoh, s;
    s = [];
    itoh = '0123456789ABCDEF'.split('');
    s = (function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 36; i = ++j) {
        results.push(Math.floor(Math.random() * 0x10));
      }
      return results;
    })();
    s[14] = 4;
    s[19] = (s[19] & 0x3) | 0x8;
    s = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = s.length; j < len; j++) {
        i = s[j];
        results.push(itoh[s[i]]);
      }
      return results;
    })();
    s[8] = s[13] = s[18] = s[23] = '-';
    return s.join('');
  };

  module.exports = {
    relative_url: relative_url,
    has_hostname: has_hostname,
    uuid: uuid
  };

}).call(this);

}).call(this);}
});